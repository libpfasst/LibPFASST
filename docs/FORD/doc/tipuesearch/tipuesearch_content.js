var tipuesearch = {"pages":[{"text":"LibPFASST Developer Info Matthew Emmett. Michael Minion, Sebastian Goetschel, Brandon Krull, Francois Hamon, Tommaso Buvoli","tags":"home","loc":"index.html","title":" LibPFASST "},{"text":"Restriction operators This file depends on sourcefile~~pf_restrict.f90~~EfferentGraph sourcefile~pf_restrict.f90 pf_restrict.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_restrict.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_restrict.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_restrict.f90->sourcefile~pf_hooks.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_restrict.f90~~AfferentGraph sourcefile~pf_restrict.f90 pf_restrict.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_restrict.f90 sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_restrict.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pf_parallel.f90->sourcefile~pf_restrict.f90 sourcefile~pf_parallel.f90->sourcefile~pf_interpolate.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_restrict Source Code pf_restrict.f90 Source Code !!  Restriction operators ! ! This file is part of LIBPFASST. ! module pf_mod_restrict !!  Module to restrict solutions between pfasst levels and create the FAS tau correction use pf_mod_dtype use pf_mod_timer use pf_mod_hooks implicit none contains subroutine restrict_time_space_fas ( pf , t0 , dt , level_index , flags , mystep ) !! Restrict (in time and space) fine level to coarse and set coarse level FAS correction. !! !! The coarse function values are re-evaluated after restriction. !! Note that even if the number of variables and nodes is the same, !! we should still compute the FAS correction since the function !! evaluations may be different. type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 !!  time at beginning of step real ( pfdp ), intent ( in ) :: dt !!  time step integer , intent ( in ) :: level_index !! defines which level to restrict integer , optional , intent ( in ) :: flags , mystep !>  Local variables class ( pf_level_t ), pointer :: c_lev_ptr class ( pf_level_t ), pointer :: f_lev_ptr integer :: m , step real ( pfdp ), allocatable :: c_times (:) !!  Simulation time at coarse nodes real ( pfdp ), allocatable :: f_times (:) !!  Simulation time at fine nodes class ( pf_encap_t ), allocatable :: & c_tmp_array (:), & ! coarse integral of coarse function values f_int_array (:), & ! fine integral of fine function values f_int_arrayr (:) ! coarse integral of restricted fine function values f_lev_ptr => pf % levels ( level_index ); c_lev_ptr => pf % levels ( level_index - 1 ) step = pf % state % step + 1 if ( present ( mystep )) step = mystep call call_hooks ( pf , level_index , PF_PRE_RESTRICT_ALL ) call start_timer ( pf , TRESTRICT + level_index - 1 ) !> create workspaces call c_lev_ptr % ulevel % factory % create_array ( c_tmp_array , c_lev_ptr % nnodes , & c_lev_ptr % index , c_lev_ptr % shape ) call c_lev_ptr % ulevel % factory % create_array ( f_int_arrayr , c_lev_ptr % nnodes , & c_lev_ptr % index , c_lev_ptr % shape ) call c_lev_ptr % ulevel % factory % create_array ( f_int_array , f_lev_ptr % nnodes , & f_lev_ptr % index , f_lev_ptr % shape ) allocate ( c_times ( c_lev_ptr % nnodes )) allocate ( f_times ( f_lev_ptr % nnodes )) !> restrict q's and recompute f's c_times = t0 + dt * c_lev_ptr % nodes f_times = t0 + dt * f_lev_ptr % nodes call restrict_sdc ( f_lev_ptr , c_lev_ptr , f_lev_ptr % Q , c_lev_ptr % Q , . false ., f_times , flags ) !>  Recompute the functions call c_lev_ptr % ulevel % sweeper % evaluate_all ( c_lev_ptr , c_times , flags = flags , step = step ) !>  Compute  FAS correction do m = 1 , c_lev_ptr % nnodes - 1 call c_lev_ptr % tauQ ( m )% setval ( 0.0_pfdp , flags ) end do if ( pf % state % iter >= pf % taui0 ) then ! compute '0 to node' integral on the coarse level call c_lev_ptr % ulevel % sweeper % integrate ( c_lev_ptr , c_lev_ptr % Q , & c_lev_ptr % F , dt , c_tmp_array , flags ) ! compute '0 to node' integral on the fine level call f_lev_ptr % ulevel % sweeper % integrate ( f_lev_ptr , f_lev_ptr % Q , & f_lev_ptr % F , dt , f_lev_ptr % I , flags ) !  put tau in on fine level if ( allocated ( f_lev_ptr % tauQ )) then do m = 1 , f_lev_ptr % nnodes - 1 call f_lev_ptr % I ( m )% axpy ( 1.0_pfdp , f_lev_ptr % tauQ ( m ), flags ) end do end if ! restrict '0 to node' integral on the fine level  in time and space call restrict_sdc ( f_lev_ptr , c_lev_ptr , f_lev_ptr % I , f_int_arrayr , . true ., f_times , flags ) ! compute '0 to node' tau correction do m = 1 , c_lev_ptr % nnodes - 1 call c_lev_ptr % tauQ ( m )% axpy ( 1.0_pfdp , f_int_arrayr ( m ), flags ) call c_lev_ptr % tauQ ( m )% axpy ( - 1.0_pfdp , c_tmp_array ( m ), flags ) end do end if call end_timer ( pf , TRESTRICT + level_index - 1 ) call call_hooks ( pf , level_index , PF_POST_RESTRICT_ALL ) !>  Clean up call c_lev_ptr % ulevel % factory % destroy_array ( c_tmp_array , c_lev_ptr % nnodes , & c_lev_ptr % index , c_lev_ptr % shape ) call c_lev_ptr % ulevel % factory % destroy_array ( f_int_arrayr , c_lev_ptr % nnodes , & c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % destroy_array ( f_int_array , f_lev_ptr % nnodes , & f_lev_ptr % index , f_lev_ptr % shape ) deallocate ( c_times ) deallocate ( f_times ) end subroutine restrict_time_space_fas subroutine restrict_sdc ( f_lev_ptr , c_lev_ptr , f_encap_array , c_encap_array , IS_INTEGRAL , f_time , flags ) !! Restrict (in time and space) f_sol_array  to c_sol_array !! Depending on the flag INTEGRAL, we may be restricting solutions, or integrals of F class ( pf_level_t ), intent ( inout ) :: f_lev_ptr !!   pointer to fine level class ( pf_level_t ), intent ( inout ) :: c_lev_ptr !!   pointer to coarse level class ( pf_encap_t ), intent ( inout ) :: f_encap_array (:) !! array of fine level data to be restricted class ( pf_encap_t ), intent ( inout ) :: c_encap_array (:) !! array of coarse level data to be computed logical , intent ( in ) :: IS_INTEGRAL !! flag determines if it is integral data being restricted real ( pfdp ), intent ( in ) :: f_time (:) !! time at the fine nodes integer , optional , intent ( in ) :: flags class ( pf_encap_t ), allocatable :: f_encap_array_c (:) !!  fine solution restricted in space only integer :: m , j integer :: f_nnodes , c_nnodes f_nnodes = f_lev_ptr % nnodes c_nnodes = c_lev_ptr % nnodes !!  do the restriction if ( IS_INTEGRAL ) then ! Restriction of integrals call c_lev_ptr % ulevel % factory % create_array ( f_encap_array_c , f_nnodes - 1 , c_lev_ptr % index , c_lev_ptr % shape ) !  spatial restriction do m = 1 , f_nnodes - 1 call f_lev_ptr % ulevel % restrict ( f_lev_ptr , c_lev_ptr , f_encap_array ( m ), f_encap_array_c ( m ), f_time ( m ), flags ) end do ! temporal restriction ! when restricting '0 to node' integral terms, skip the first entry since it is zero if ( present ( flags )) then if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) & call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat ( 2 :, 2 :), f_encap_array_c , . true ., flags = 1 ) if (( flags . eq . 0 ) . or . ( flags . eq . 2 )) & call pf_apply_mat_backward ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat ( 2 :, 2 :), f_encap_array_c , . true ., flags = 2 ) else call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat ( 2 :, 2 :), f_encap_array_c , . true .) end if call c_lev_ptr % ulevel % factory % destroy_array ( f_encap_array_c , f_nnodes - 1 , c_lev_ptr % index , c_lev_ptr % shape ) else call c_lev_ptr % ulevel % factory % create_array ( f_encap_array_c , f_nnodes , c_lev_ptr % index , c_lev_ptr % shape ) !  spatial restriction do m = 1 , f_nnodes call f_lev_ptr % ulevel % restrict ( f_lev_ptr , c_lev_ptr , f_encap_array ( m ), f_encap_array_c ( m ), f_time ( m ), flags ) end do ! temporal restriction if ( present ( flags )) then if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) & call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat , f_encap_array_c , . true ., flags ) if (( flags . eq . 0 ) . or . ( flags . eq . 2 )) & call pf_apply_mat_backward ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat , f_encap_array_c , . true ., flags = 2 ) else call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat , f_encap_array_c , . true .) end if call c_lev_ptr % ulevel % factory % destroy_array ( f_encap_array_c , f_nnodes , c_lev_ptr % index , c_lev_ptr % shape ) end if end subroutine restrict_sdc subroutine pf_apply_mat ( dst , a , mat , src , zero , flags ) !! Apply a matrix (tmat or rmat) to src and add to dst. !! Mathematically this is !!     dst= dst + a*mat*src !!  Where dst and src are vectors, mat is a matrix, and a is a scalar !!  If the optional variable \"zero\" is provided and is true, then we compute !!     dst=  a*mat*src class ( pf_encap_t ), intent ( inout ) :: dst (:) !!  destination vector real ( pfdp ), intent ( in ) :: a !!  scalar real ( pfdp ), intent ( in ) :: mat (:, :) !!  matrix class ( pf_encap_t ), intent ( in ) :: src (:) !!  src vector logical , intent ( in ), optional :: zero !! If false, don't zero out the the dst variable before computing integer , intent ( in ), optional :: flags !! Used for choosing which variable to operate on !!  Local variables logical :: lzero !!  local version of input parameter zero integer :: which !!  local version of flags integer :: n , m !!  size of mat integer :: i , j !!  loop variables lzero = . true .; if ( present ( zero )) lzero = zero which = 1 ; if ( present ( flags )) which = flags n = size ( mat , dim = 1 ) m = size ( mat , dim = 2 ) do i = 1 , n if ( lzero ) call dst ( i )% setval ( 0.0_pfdp , flags ) do j = 1 , m if ( a * mat ( i , j ) /= 0.0_pfdp ) call dst ( i )% axpy ( a * mat ( i , j ), src ( j ), flags ) end do end do end subroutine pf_apply_mat subroutine pf_apply_mat_backward ( dst , a , mat , src , zero , flags ) !! Apply a matrix (tmat or rmat) to src and add to dst. class ( pf_encap_t ), intent ( inout ) :: dst (:) !!  destination vector real ( pfdp ), intent ( in ) :: a !!  scalar real ( pfdp ), intent ( in ) :: mat (:, :) !!  matrix class ( pf_encap_t ), intent ( in ) :: src (:) !!  src vector logical , intent ( in ), optional :: zero !! If false, don't zero out the the dst variable before computing integer , intent ( in ), optional :: flags !! Used for choosing which variable to operate on !!  Local variables logical :: lzero !!  local version of input parameter zero integer :: which !!  local version of flags integer :: n , m !!  size of mat integer :: i , j !!  loop variables lzero = . true .; if ( present ( zero )) lzero = zero which = 2 ; if ( present ( flags )) which = flags if ( which /= 2 ) & stop \"pf_apply_mat_backward can only be used for restricting the backward integrals with which==2\" n = size ( mat , dim = 1 ) m = size ( mat , dim = 2 ) do i = 1 , n if ( lzero ) call dst ( n + 1 - i )% setval ( 0.0_pfdp , 2 ) do j = 1 , m if ( a * mat ( i , j ) /= 0.0_pfdp ) call dst ( n + 1 - i )% axpy ( a * mat ( i , j ), src ( m + 1 - j ), 2 ) end do end do end subroutine pf_apply_mat_backward end module pf_mod_restrict","tags":"","loc":"sourcefile/pf_restrict.f90.html","title":"pf_restrict.f90 – LibPFASST"},{"text":"Quadrature matrices and accompanying routines This file depends on sourcefile~~pf_quadrature.f90~~EfferentGraph sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_quadrature.f90~~AfferentGraph sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_imexq.f90 pf_imexQ.f90 sourcefile~pf_imexq.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_comm.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_imexq.f90 sourcefile~pfasst.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 sourcefile~pf_parallel.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_quadrature Source Code pf_quadrature.f90 Source Code !! Quadrature matrices and accompanying routines ! ! This file is part of LIBPFASST. ! ! !> Module to create quadrature matrices and accompanying routines module pf_mod_quadrature use pf_mod_dtype use pf_mod_utils implicit none integer , parameter :: qp = c_long_double integer , parameter :: dp = c_double real ( qp ), parameter :: eps = 1.0e-23_qp private :: qsort_partition interface poly_eval module procedure poly_eval module procedure poly_eval_complex end interface contains !>  Initialize the sdcmats type with the correct nodes and quadrature matrices subroutine pf_init_sdcmats ( pf , SDCmats , nnodes , nflags ) use pf_mod_utils type ( pf_pfasst_t ), intent ( in ) :: pf !!  PFASST structure type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats integer , intent ( in ) :: nnodes ! Number of ndoes integer , intent ( inout ) :: nflags ( nnodes ) integer :: ierr integer :: nnodes0 !  Copy some info SDCmats % nnodes = nnodes SDCmats % qtype = pf % qtype SDCmats % use_proper_nodes = pf % use_proper_nodes SDCmats % use_composite_nodes = pf % use_composite_nodes SDCmats % use_no_left_q = pf % use_no_left_q !> Decide what the base integration type is if ( SDCmats % use_composite_nodes ) then nnodes0 = pf % levels ( 1 )% nnodes !  Will use the coarsest quadrature rule in composite else nnodes0 = pf % levels ( pf % nlevels )% nnodes ! Will use the end if !  Allocate nodes and collocation matrices allocate ( SDCmats % qnodes ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , & __ LINE__ , \"allocate error qnodes\" ) allocate ( SDCmats % qmat ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmat\" ) allocate ( SDCmats % s0mat ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error s0mat\" ) !  Make the nodes and collocation matrices call pf_quadrature ( SDCmats % qtype , nnodes , nnodes0 , & SDCmats % qnodes , nflags , SDCmats % s0mat , SDCmats % qmat , & SDCmats % use_proper_nodes , SDCmats % use_composite_nodes , SDCmats % use_no_left_q ) !  Make the substepping matrices call pf_make_matrices ( SDCmats ) end subroutine pf_init_sdcmats !>  Destroy the sdcmats structure subroutine pf_destroy_sdcmats ( SDCmats ) type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats deallocate ( SDCmats % qmat ) deallocate ( SDCmats % qmatFE ) deallocate ( SDCmats % qmatBE ) deallocate ( SDCmats % qmatTrap ) deallocate ( SDCmats % qmatVer ) deallocate ( SDCmats % qmatLU ) deallocate ( SDCmats % s0mat ) deallocate ( SDCmats % qnodes ) end subroutine pf_destroy_sdcmats !>  Routine to compute the LU decomposition of spectral integration matrix subroutine myLUq ( Q , QLU , Nnodes , fillq ) integer , intent ( in ) :: Nnodes real ( pfdp ), intent ( in ) :: Q ( Nnodes - 1 , Nnodes ) real ( pfdp ), intent ( inout ) :: QLU ( Nnodes - 1 , Nnodes ) integer , intent ( in ) :: fillq ! Return the QLU=U&#94;T where U is the LU decomposition of Q without pivoting ! if fillq is positive, then the first row of QLU is filled to make ! the matrix consistent integer :: i , j , N real ( pfdp ) :: c real ( pfdp ) :: U ( Nnodes - 1 , Nnodes - 1 ) real ( pfdp ) :: L ( Nnodes - 1 , Nnodes - 1 ) real ( pfdp ) :: LUerror L = 0.0_pfdp U = 0.0_pfdp N = Nnodes - 1 U = transpose ( Q ( 1 : Nnodes - 1 , 2 : Nnodes )) do i = 1 , N if ( abs ( U ( i , i )) . gt . 1.0e-15_pfdp ) then do j = i + 1 , N c = U ( j , i ) / U ( i , i ) U ( j , i : N ) = U ( j , i : N ) - c * U ( i , i : N ) L ( j , i ) = c end do end if L ( i , i ) = 1.0_pfdp end do !  Check LUerror = maxval ( abs ( matmul ( L , U ) - transpose ( Q ( 1 : Nnodes - 1 , 2 : Nnodes )))) if ( LUerror . gt . 1 e - 14 ) then call pf_stop ( __ FILE__ , __ LINE__ , 'error in LU too high' ) end if QLU = 0.0_pfdp QLU ( 1 : Nnodes - 1 , 2 : Nnodes ) = transpose ( U ) !  Now scale the columns of U to match the sum of A if ( fillq . eq . 1 ) then do j = 1 , Nnodes - 1 QLU ( j , 1 ) = sum ( Q ( j , 1 : Nnodes )) - sum ( U ( j , 1 : Nnodes - 1 )) end do end if end subroutine myLUq !>  Subroutine to create quadrature nodes and matrices subroutine pf_quadrature ( qtype , nnodes , nnodes0 , nodes , nflags , smat , qmat , proper , composite , no_left ) integer , intent ( in ) :: qtype ! Type of nodes integer , intent ( in ) :: nnodes ! Number of nodes on this level integer , intent ( in ) :: nnodes0 ! Number of node on base level (either finest or coarsest) real ( pfdp ), intent ( out ) :: nodes ( nnodes ) !  The nodes real ( pfdp ), intent ( out ) :: smat ( nnodes - 1 , nnodes ) !  node to node integration matrix real ( pfdp ), intent ( out ) :: qmat ( nnodes - 1 , nnodes ) !  O to node collocation matrix integer , intent ( out ) :: nflags ( nnodes ) !  Flags logical , intent ( in ) :: composite !  Use composite nodes logical , intent ( in ) :: proper !  Use proper nodes instead of node restriction logical , intent ( in ) :: no_left !  Don't use left hand end point real ( pfdp ) :: dt !  The size of the composite base rule real ( pfqp ) :: qnodes0 ( nnodes0 ) ! quad precision base nodes real ( pfqp ) :: qnodes ( nnodes ) ! quad precision nodes real ( pfdp ) :: qmat0 ( nnodes0 - 1 , nnodes0 ), smat0 ( nnodes0 - 1 , nnodes0 ), qcomp0 ( nnodes0 - 1 , nnodes0 ) integer :: flags0 ( nnodes0 ) integer :: i , j , ri , rj , refine , m qmat = 0 smat = 0 flags0 = 0 nflags = 0 if ( composite ) then ! nodes are given by repeating the coarsest set of nodes.  note ! that in this case nnodes0 corresponds to the coarsest number ! of nodes. refine = ( nnodes - 1 ) / ( nnodes0 - 1 ) call sdc_qnodes ( qnodes0 , flags0 , qtype , nnodes0 ) !  Make coarsest level nodes call sdc_qmats ( qmat0 , smat0 , qnodes0 , qnodes0 , flags0 , nnodes0 , nnodes0 ) !  Make coarsest level qmat !  This block matrix will be used to fill in composite qmat do m = 1 , nnodes0 - 1 qcomp0 ( m ,:) = qmat0 ( nnodes0 - 1 ,:) !  load each row with the integral over the whole composite step end do !  Build big block matrix dt = 1.0_pfdp / refine do i = 1 , refine ri = ( i - 1 ) * ( nnodes0 - 1 ) + 1 !  beginning of ith composite rule qnodes ( ri : ri + nnodes0 - 1 ) = dt * (( i - 1 ) + qnodes0 ) !  Assigns endpoints of composites twice, but no biggie smat ( ri : ri + nnodes0 - 2 , ri : ri + nnodes0 - 1 ) = dt * smat0 ! Make block diagonal smat qmat ( ri : ri + nnodes0 - 2 , ri : ri + nnodes0 - 1 ) = dt * qmat0 ! Make block diagonal qmat do j = 1 , i - 1 !   column blocks to left of diag rj = ( j - 1 ) * ( nnodes0 - 1 ) + 1 qmat ( ri : ri + nnodes0 - 2 , rj : rj + nnodes0 - 1 ) = qmat ( ri : ri + nnodes0 - 2 , rj : rj + nnodes0 - 1 ) + dt * qcomp0 end do end do else if ( proper ) then ! nodes are given by proper quadrature rules call sdc_qnodes ( qnodes , nflags , qtype , nnodes ) call sdc_qmats ( qmat , smat , qnodes , qnodes , nflags , nnodes , nnodes ) else ! nodes are given by refining the finest set of nodes.  note ! that in this case nnodes0 corresponds to the finest number of ! nodes. refine = ( nnodes0 - 1 ) / ( nnodes - 1 ) call sdc_qnodes ( qnodes0 , flags0 , qtype , nnodes0 ) !  Make finest nodes qnodes = qnodes0 ( :: refine ) nflags = flags0 ( :: refine ) if ( no_left ) nflags ( 1 ) = 0 call sdc_qmats ( qmat , smat , qnodes , qnodes , nflags , nnodes , nnodes ) end if nodes = real ( qnodes , pfdp ) if ( all ( nodes == 0.0d0 )) then call pf_stop ( __ FILE__ , __ LINE__ ,& 'ERROR: pf_quadrature: invalid SDC nnodes.' ) end if end subroutine pf_quadrature subroutine pf_make_matrices ( SDCmats ) type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats integer :: nnodes integer :: ierr , m , n nnodes = SDCmats % nnodes allocate ( SDCmats % qmatFE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmatFE\" ) allocate ( SDCmats % qmatBE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmatBE\" ) allocate ( SDCmats % qmatTrap ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmatBE\" ) allocate ( SDCmats % qmatVer ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmatBE\" ) allocate ( SDCmats % qmatLU ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmatLU\" ) !  Make implicit Euler matrices SDCmats % qmatBE = 0.0_pfdp do m = 1 , nnodes - 1 do n = 1 , m SDCmats % qmatBE ( m , n + 1 ) = SDCmats % qnodes ( n + 1 ) - SDCmats % qnodes ( n ) end do end do ! Make explicit matrix SDCmats % qmatFE = 0.0_pfdp do m = 1 , nnodes - 1 do n = 1 , m SDCmats % qmatFE ( m , n ) = SDCmats % qnodes ( n + 1 ) - SDCmats % qnodes ( n ) end do end do !  Trapezoid matrix SDCmats % qmatTrap = 0.5_pfdp * ( SDCmats % qmatFE + SDCmats % qmatBE ) !  Get the LU call myLUq ( SDCmats % qmat , SDCmats % qmatLU , nnodes , 0 ) end subroutine pf_make_matrices !>  Function to decide if the restriction of the nodes is pointwise, e.g. coarse nodes are every other fine node logical function not_proper ( flags , node ) integer , intent ( in ) :: flags (:) integer , intent ( in ) :: node not_proper = . not . btest ( flags ( node ), 0 ) end function not_proper !> Subroutine to compute high precision quadrature nodes. subroutine sdc_qnodes ( qnodes , flags , qtype , nnodes ) integer , intent ( in ), value :: nnodes !!  Number of nodes integer , intent ( in ), value :: qtype !!  Type of nodes (see pf_dtype) real ( pfqp ), intent ( out ) :: qnodes ( nnodes ) !!  The computed quadrature nodes integer , intent ( out ) :: flags ( nnodes ) !! integer :: j , degree real ( pfqp ), allocatable :: roots (:) real ( pfqp ), allocatable :: coeffs (:), coeffs2 (:) real ( pfqp ), parameter :: pi = 3.141592653589793115997963468544185161590576171875_pfdp flags = 0 select case ( qtype ) case ( SDC_GAUSS_LEGENDRE ) degree = nnodes - 2 allocate ( roots ( degree )) allocate ( coeffs ( degree + 1 )) call poly_legendre ( coeffs , degree ) call poly_roots ( roots , coeffs , degree ) qnodes ( 1 ) = 0.0_pfqp qnodes ( 2 : nnodes - 1 ) = 0.5_pfqp * ( 1.0_pfqp + roots ) qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs ) deallocate ( roots ) do j = 2 , nnodes - 1 flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_GAUSS_LOBATTO ) degree = nnodes - 1 allocate ( roots ( degree - 1 )) allocate ( coeffs ( degree + 1 )) call poly_legendre ( coeffs , degree ) call poly_diff ( coeffs , degree ) call poly_roots ( roots , coeffs (: degree ), degree - 1 ) qnodes ( 1 ) = 0.0_pfqp qnodes ( 2 : nnodes - 1 ) = 0.5_pfqp * ( 1.0_pfqp + roots ) qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs ) deallocate ( roots ) do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_GAUSS_RADAU ) degree = nnodes - 1 allocate ( roots ( degree )) allocate ( coeffs ( degree + 1 )) allocate ( coeffs2 ( degree )) call poly_legendre ( coeffs , degree ) call poly_legendre ( coeffs2 , degree - 1 ) coeffs (: degree ) = coeffs (: degree ) + coeffs2 call poly_roots ( roots , coeffs , degree ) qnodes ( 1 ) = 0.0_pfqp do j = 2 , nnodes - 1 qnodes ( j ) = 0.5_pfqp * ( 1.0_pfqp - roots ( nnodes + 1 - j )) end do qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs2 ) deallocate ( coeffs ) deallocate ( roots ) do j = 2 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_CLENSHAW_CURTIS ) do j = 0 , nnodes - 1 qnodes ( j + 1 ) = 0.5_pfqp * ( 1.0_pfqp - cos ( j * pi / ( nnodes - 1 ))) end do do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_UNIFORM ) do j = 0 , nnodes - 1 qnodes ( j + 1 ) = j * ( 1.0_pfqp / ( nnodes - 1 )) end do do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_CHEBYSHEV ) qnodes ( 1 ) = 0.0_pfqp do j = 1 , nnodes - 2 qnodes ( j + 1 ) = 0.5_pfqp * ( 1.0_pfqp - cos (( j - 1 / 2 ) * pi / ( nnodes - 2 ))) end do qnodes ( nnodes ) = 0.0_pfqp do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , qtype ) end select end subroutine sdc_qnodes !>  Subroutine to compute the quadrature matrices subroutine sdc_qmats ( qmat , smat , dst , src , flags , ndst , nsrc ) integer , intent ( in ), value :: ndst !!  Number of destination points integer , intent ( in ), value :: nsrc !!  Number of source points real ( pfqp ), intent ( in ) :: dst ( ndst ) !!  Destination points real ( pfqp ), intent ( in ) :: src ( nsrc ) !!  Source points real ( pfdp ), intent ( out ) :: qmat ( ndst - 1 , nsrc ) !!  O to dst quadrature weights real ( pfdp ), intent ( out ) :: smat ( ndst - 1 , nsrc ) !! dst(m) to dst(m+1) quadrature weights integer , intent ( in ) :: flags ( nsrc ) integer :: i , j , m real ( pfqp ) :: q , s , den , p ( 0 : nsrc ) qmat = 0.0_pfdp smat = 0.0_pfdp ! construct qmat and smat do i = 1 , nsrc if ( not_proper ( flags , i )) cycle ! construct interpolating polynomial coefficients p = 0.0_pfdp p ( 0 ) = 1.0_pfdp do m = 1 , nsrc if ( not_proper ( flags , m ) . or . m == i ) cycle p = eoshift ( p , - 1 ) - src ( m ) * p end do den = poly_eval ( p , nsrc , src ( i )) call poly_int ( p , nsrc ) ! evaluate integrals do j = 2 , ndst q = poly_eval ( p , nsrc , dst ( j )) - poly_eval ( p , nsrc , 0.0_pfqp ) s = poly_eval ( p , nsrc , dst ( j )) - poly_eval ( p , nsrc , dst ( j - 1 )) qmat ( j - 1 , i ) = real ( q / den , pfdp ) smat ( j - 1 , i ) = real ( s / den , pfdp ) end do end do end subroutine sdc_qmats !> Polynomial manipulation routines. !! !! A polynomial p !! !!   p(x) = a_n x&#94;n + ... + a_2 x&#94;2 + a_1 x + a_0 !! !! is stored as a Fortran array p(0:n) according to !! !!   p = [ a_0, a_1, ..., a_n ]. !! !> Function to evaluate real polynomial real ( pfqp ) function poly_eval ( p , n , x ) result ( v ) integer , intent ( in ), value :: n real ( pfqp ), intent ( in ) :: p ( 0 : n ), x integer :: j v = p ( n ) do j = n - 1 , 0 , - 1 v = x * v + p ( j ) end do end function !> Function to evaluate complex polynomial complex ( pfqp ) function poly_eval_complex ( p , n , x ) result ( v ) integer , intent ( in ), value :: n real ( pfqp ), intent ( in ) :: p ( 0 : n ) complex ( pfqp ), intent ( in ) :: x integer :: j v = p ( n ) do j = n - 1 , 0 , - 1 v = x * v + p ( j ) end do end function !> Subroutine to differentiate polynomial (in place) subroutine poly_diff ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( inout ) :: p ( 0 : n ) integer :: j real ( pfqp ) :: pp ( 0 : n ) pp = 0.0_pfqp do j = 1 , n pp ( j - 1 ) = j * p ( j ) end do p = pp end subroutine poly_diff !> Subroutine to integrate polynomial (in place) subroutine poly_int ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( inout ) :: p ( 0 : n ) integer :: j real ( pfqp ) :: pp ( 0 : n ) pp = 0.0_pfqp do j = 0 , n - 1 pp ( j + 1 ) = p ( j ) / ( j + 1 ) end do p = pp end subroutine poly_int !> Subroutine to compute Legendre polynomial coefficients using Bonnet's recursion formula. subroutine poly_legendre ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( out ) :: p ( 0 : n ) real ( pfqp ), dimension ( 0 : n ) :: p0 , p1 , p2 integer :: j , m if ( n == 0 ) then p = [ 1.0_pfqp ] return end if if ( n == 1 ) then p = [ 0.0_pfqp , 1.0_pfqp ] return end if p0 = 0.0_pfqp ; p1 = 0.0_pfqp ; p2 = 0.0_pfqp p0 ( 0 ) = 1.0_pfqp p1 ( 1 ) = 1.0_pfqp ! (n + 1) P_{n+1} = (2n + 1) x P_{n} - n P_{n-1} do m = 1 , n - 1 do j = 1 , n p2 ( j ) = ( ( 2 * m + 1 ) * p1 ( j - 1 ) - m * p0 ( j ) ) / ( m + 1 ) end do p2 ( 0 ) = - m * p0 ( 0 ) / ( m + 1 ) p0 = p1 p1 = p2 end do p = p2 end subroutine poly_legendre !> Subroutine to compute polynomial roots using the Durand-Kerner algorithm. !! The roots are assumed to be real. subroutine poly_roots ( roots , p0 , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( out ) :: roots ( n ) real ( pfqp ), intent ( in ) :: p0 ( 0 : n ) integer :: i , j , k complex ( pfqp ) :: num , den , z0 ( n ), z1 ( n ) real ( pfqp ) :: p ( 0 : n ) real ( pfqp ) :: eps eps = epsilon ( 1.0_pfqp ) * 10 0.0_pfqp p = p0 / p0 ( n ) ! initial guess do i = 1 , n z0 ( i ) = ( 0.4_pfqp , 0.9_pfqp ) ** i end do ! durand-kerner-weierstrass iterations z1 = z0 do k = 1 , 100 do i = 1 , n ! evaluate poly at z0(i) num = poly_eval_complex ( p , n , z0 ( i )) ! evaluate denominator den = 1.0_pfqp do j = 1 , n if ( j == i ) cycle den = den * ( z0 ( i ) - z0 ( j )) end do ! update z0 ( i ) = z0 ( i ) - num / den end do ! converged? if ( sum ( abs ( z0 - z1 )) < eps ) exit z1 = z0 end do roots = real ( z0 ) where ( abs ( roots ) < eps ) roots = 0.0_pfqp call qsort ( roots ) end subroutine poly_roots !> Subroutine to sort (inplace) using the quick sort algorithm. !> Adapted from http://www.fortran.com/qsort_c.f95. recursive subroutine qsort ( a ) real ( pfqp ), intent ( inout ) :: a (:) integer :: iq if ( size ( a ) > 1 ) then call qsort_partition ( a , iq ) call qsort ( a (: iq - 1 )) call qsort ( a ( iq :)) end if end subroutine qsort subroutine qsort_partition ( a , marker ) real ( pfqp ), intent ( inout ) :: a (:) integer , intent ( out ) :: marker integer :: i , j real ( pfqp ) :: temp , x x = a ( 1 ) i = 0 j = size ( a ) + 1 do j = j - 1 do if ( a ( j ) <= x ) exit j = j - 1 end do i = i + 1 do if ( a ( i ) >= x ) exit i = i + 1 end do if ( i < j ) then temp = a ( i ) a ( i ) = a ( j ) a ( j ) = temp else if ( i == j ) then marker = i + 1 return else marker = i return endif end do end subroutine qsort_partition end module pf_mod_quadrature","tags":"","loc":"sourcefile/pf_quadrature.f90.html","title":"pf_quadrature.f90 – LibPFASST"},{"text":"N-dimensional array encapsulation. This file depends on sourcefile~~pf_ndsysarray.f90~~EfferentGraph sourcefile~pf_ndsysarray.f90 pf_ndsysarray.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_ndsysarray.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_ndsysarray Source Code pf_ndsysarray.f90 Source Code !!  N-dimensional array encapsulation. ! ! This file is part of LIBPFASST. ! !> System of N-dimensional arrays encapsulation. !! !! When a new solution is created by a PFASST level, this encapsulation !! uses the levels 'arr_shape' attribute to create a new multi-component array with that !! shape.  Thus, the 'arr_shape' attributes of the PFASST levels should be !! set appropriately.  The last component of arr_shape is the number of components in the system !! !! For example, before calling pf_pfasst_run we can !! set the arr_shape of the coarsest level by doing: !! !!   allocate(pf%levels(1)%arr_shape(3)) !!   pf%levels(1)%arr_shape = [ nx, ny, 3 ] !! !! Which would imply that a 3 component system of two-dimensional solutions. !! !! The helper routines array1, array2, array3, etc can be used to !! extract pointers to a component of  encapsulated system !! performing any copies. !! module pf_mod_ndsysarray use iso_c_binding use pf_mod_dtype implicit none !>  Type to create and destroy systems of N-dimensional arrays type , extends ( pf_factory_t ) :: ndsysarray_factory contains procedure :: create_single => ndsysarray_create_single procedure :: create_array => ndsysarray_create_array procedure :: destroy_single => ndsysarray_destroy_single procedure :: destroy_array => ndsysarray_destroy_array end type ndsysarray_factory !> Type for system of  N-dimensional arrays,  extends the abstract encap type type , extends ( pf_encap_t ) :: ndsysarray integer :: dim !  The spatial dimension of each component in system integer :: ncomp !  The number of components in the system integer :: ndof !  The number of variables in each component integer , allocatable :: arr_shape (:) real ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => ndsysarray_setval procedure :: copy => ndsysarray_copy procedure :: norm => ndsysarray_norm procedure :: pack => ndsysarray_pack procedure :: unpack => ndsysarray_unpack procedure :: axpy => ndsysarray_axpy procedure :: eprint => ndsysarray_eprint end type ndsysarray !> Interfaces to output routines in pf_numpy.c interface !>  Subroutine to make a directory for output subroutine ndsysarray_mkdir ( dname , dlen ) bind ( c ) use iso_c_binding character ( c_char ), intent ( in ) :: dname integer , intent ( in ), value :: dlen end subroutine ndsysarray_mkdir !>  Subroutine to write an the array to a file subroutine ndsysarray_dump_numpy ( dname , fname , endian , dim , mpibuflen , arr_shape , array ) bind ( c ) use iso_c_binding character ( c_char ), intent ( in ) :: dname , fname , endian ( 5 ) integer , intent ( in ), value :: dim , mpibuflen integer , intent ( in ) :: arr_shape ( dim ) real ( c_double ), intent ( in ) :: array ( mpibuflen ) end subroutine ndsysarray_dump_numpy end interface contains !>  Subroutine to allocate the array and set the size parameters subroutine ndsysarray_build ( q , arr_shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: arr_shape (:) select type ( q ) class is ( ndsysarray ) allocate ( q % arr_shape ( size ( arr_shape ))) q % dim = size ( arr_shape ) - 1 q % ncomp = arr_shape ( q % dim + 1 ) q % ndof = product ( arr_shape ( 1 : q % dim )) q % arr_shape = arr_shape allocate ( q % flatarray ( product ( arr_shape ))) end select end subroutine ndsysarray_build !> Subroutine to  create a single array subroutine ndsysarray_create_single ( this , x , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( ndsysarray :: x ) call ndsysarray_build ( x , shape ) end subroutine ndsysarray_create_single !> Subroutine to create an array of arrays subroutine ndsysarray_create_array ( this , x , n , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndsysarray :: x ( n )) do i = 1 , n call ndsysarray_build ( x ( i ), shape ) end do end subroutine ndsysarray_create_array !!$ !>  Subroutine to destroy array (simple) subroutine ndsysarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndsysarray ), pointer :: ndsysarray_obj ndsysarray_obj => cast_as_ndsysarray ( encap ) deallocate ( ndsysarray_obj % arr_shape ) deallocate ( ndsysarray_obj % flatarray ) nullify ( ndsysarray_obj ) end subroutine ndsysarray_destroy !> Subroutine to destroy an single array subroutine ndsysarray_destroy_single ( this , x , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) select type ( x ) class is ( ndsysarray ) deallocate ( x % arr_shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine ndsysarray_destroy_single !> Subroutine to destroy an array of arrays subroutine ndsysarray_destroy_array ( this , x , n , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i select type ( x ) class is ( ndsysarray ) do i = 1 , n deallocate ( x ( i )% arr_shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine ndsysarray_destroy_array !>  The following are the base subroutines that all encapsulations must provide !! !> Subroutine to set array to a scalare  value. subroutine ndsysarray_setval ( this , val , flags ) class ( ndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine ndsysarray_setval !> Subroutine to copy an array subroutine ndsysarray_copy ( this , src , flags ) class ( ndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( ndsysarray ) this % flatarray = src % flatarray class default stop \"TYPE ERROR\" end select end subroutine ndsysarray_copy !> Subroutine to pack an array into a flat array for sending subroutine ndsysarray_pack ( this , z , flags ) class ( ndsysarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags z = this % flatarray end subroutine ndsysarray_pack !> Subroutine to unpack a flatarray after receiving subroutine ndsysarray_unpack ( this , z , flags ) class ( ndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags this % flatarray = z end subroutine ndsysarray_unpack !> Subroutine to define the norm of the array (here the max norm) function ndsysarray_norm ( this , flags ) result ( norm ) class ( ndsysarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function ndsysarray_norm !> Subroutine to compute y = a x + y where a is a scalar and x and y are arrays subroutine ndsysarray_axpy ( this , a , x , flags ) class ( ndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( ndsysarray ) this % flatarray = a * x % flatarray + this % flatarray class default stop \"TYPE ERROR\" end select end subroutine ndsysarray_axpy !>  Subroutine to print the array to the screen (mainly for debugging purposes) subroutine ndsysarray_eprint ( this , flags ) class ( ndsysarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % flatarray ( 1 : 10 ) !print *, this%flatarray end subroutine ndsysarray_eprint function cast_as_ndsysarray ( encap_polymorph ) result ( ndsysarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndsysarray ), pointer :: ndsysarray_obj select type ( encap_polymorph ) type is ( ndsysarray ) ndsysarray_obj => encap_polymorph end select end function cast_as_ndsysarray !>  Helper function to return the array part function get_array1d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) select type ( x ) type is ( ndsysarray ) r => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array1d function get_array2d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( ndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array2d function get_array3d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( ndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 ), 1 : x % arr_shape ( 3 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array3d end module pf_mod_ndsysarray","tags":"","loc":"sourcefile/pf_ndsysarray.f90.html","title":"pf_ndsysarray.f90 – LibPFASST"},{"text":"This file depends on sourcefile~~pf_fftw.f90~~EfferentGraph sourcefile~pf_fftw.f90 pf_fftw.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_fftw.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_fftw.f90->sourcefile~pf_utils.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_fftpackage Source Code pf_fftw.f90 Source Code ! ! This file is part of LIBPFASST. ! !>  Module for providing FFTs based on fftw !!  To use this module, fftw must be installed. !!  This can be done by the libpfasst make system with the comment !!   > make fftw3 module pf_mod_fftpackage use pf_mod_dtype use pf_mod_utils implicit none !  include 'fftw3.f03' real ( pfdp ), parameter :: two_pi = 6.2831853071795862_pfdp !>  Define the fft package type :: pf_fft_t type ( c_ptr ) :: ffft , ifft !! fftw pointers integer :: dim !! spatial number of dimensions integer :: nx , ny , nz !! grid sizes real ( pfdp ) :: Lx , Ly , Lz !! domain size real ( pfdp ) :: normfact !! normalization factor complex ( pfdp ), pointer :: wk_1d (:) !! work space complex ( pfdp ), pointer :: wk_2d (:,:) !! work space complex ( pfdp ), pointer :: wk_3d (:,:,:) !! work space contains procedure :: fft_setup procedure :: fft_destroy procedure :: fftf procedure :: fftb procedure , private :: conv_1d , conv_2d , conv_3d generic :: conv => conv_1d , conv_2d , conv_3d procedure :: get_wk_ptr_1d procedure :: get_wk_ptr_2d procedure :: get_wk_ptr_3d procedure :: make_lap_1d procedure :: make_lap_2d procedure :: make_lap_3d procedure :: make_deriv_1d procedure :: make_deriv_2d procedure :: make_deriv_3d end type pf_fft_t contains !> Routines to return the pointer to the work variable function get_wk_ptr_1d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:) ! work space wk => this % wk_1d end function get_wk_ptr_1d function get_wk_ptr_2d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:,:) ! work space wk => this % wk_2d end function get_wk_ptr_2d function get_wk_ptr_3d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:,:,:) ! work space wk => this % wk_3d end function get_wk_ptr_3d !> Initialize the package subroutine fft_setup ( this , grid_shape , dim , grid_size ) class ( pf_fft_t ), intent ( inout ) :: this integer , intent ( in ) :: dim integer , intent ( in ) :: grid_shape ( dim ) real ( pfdp ), optional , intent ( in ) :: grid_size ( dim ) integer :: nx , ny , nz real ( pfdp ) :: kx , ky type ( c_ptr ) :: wk this % dim = dim nx = grid_shape ( 1 ) this % nx = nx ! Defaults for grid_size this % Lx = 1.0_pfdp this % Ly = 1.0_pfdp this % Lz = 1.0_pfdp if ( present ( grid_size )) this % Lx = grid_size ( 1 ) if ( present ( grid_size )) this % Ly = grid_size ( 2 ) if ( present ( grid_size )) this % Lz = grid_size ( 3 ) select case ( dim ) case ( 1 ) this % normfact = real ( nx , pfdp ) wk = fftw_alloc_complex ( int ( nx , c_size_t )) call c_f_pointer ( wk , this % wk_1d , [ nx ]) this % ffft = fftw_plan_dft_1d ( nx , & this % wk_1d , this % wk_1d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifft = fftw_plan_dft_1d ( nx , & this % wk_1d , this % wk_1d , FFTW_BACKWARD , FFTW_ESTIMATE ) case ( 2 ) ny = grid_shape ( 2 ) this % ny = ny this % normfact = real ( nx * ny , pfdp ) ! create in-place, complex fft plans wk = fftw_alloc_complex ( int ( nx * ny , c_size_t )) call c_f_pointer ( wk , this % wk_2d , [ nx , ny ]) this % ffft = fftw_plan_dft_2d ( nx , ny , & this % wk_2d , this % wk_2d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifft = fftw_plan_dft_2d ( nx , ny , & this % wk_2d , this % wk_2d , FFTW_BACKWARD , FFTW_ESTIMATE ) case ( 3 ) ny = grid_shape ( 2 ) nz = grid_shape ( 3 ) this % ny = ny this % nz = nz this % normfact = real ( nx * ny * nz , pfdp ) wk = fftw_alloc_complex ( int ( nx * ny * nz , c_size_t )) call c_f_pointer ( wk , this % wk_3d , [ nx , ny , nz ]) this % ffft = fftw_plan_dft_3d ( nx , ny , nz , & this % wk_3d , this % wk_3d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifft = fftw_plan_dft_3d ( nx , ny , nz , & this % wk_3d , this % wk_3d , FFTW_BACKWARD , FFTW_ESTIMATE ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_setup !>  Destroy the package subroutine fft_destroy ( this ) class ( pf_fft_t ), intent ( inout ) :: this call fftw_destroy_plan ( this % ffft ) call fftw_destroy_plan ( this % ifft ) select case ( this % dim ) case ( 1 ) deallocate ( this % wk_1d ) case ( 2 ) deallocate ( this % wk_2d ) case ( 3 ) deallocate ( this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_destroy !>  Routine to take foreward FFT subroutine fftf ( this ) class ( pf_fft_t ), intent ( inout ) :: this select case ( this % dim ) case ( 1 ) call fftw_execute_dft ( this % ffft , this % wk_1d , this % wk_1d ) case ( 2 ) call fftw_execute_dft ( this % ffft , this % wk_2d , this % wk_2d ) case ( 3 ) call fftw_execute_dft ( this % ffft , this % wk_3d , this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftf !>  Routine to take inverse or backward FFT subroutine fftb ( this ) class ( pf_fft_t ), intent ( inout ) :: this !  Normalize the fft select case ( this % dim ) case ( 1 ) this % wk_1d = this % wk_1d / this % normfact call fftw_execute_dft ( this % ifft , this % wk_1d , this % wk_1d ) case ( 2 ) this % wk_2d = this % wk_2d / this % normfact call fftw_execute_dft ( this % ifft , this % wk_2d , this % wk_2d ) case ( 3 ) this % wk_3d = this % wk_3d / this % normfact call fftw_execute_dft ( this % ifft , this % wk_3d , this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftb ! START private convolution procedures subroutine conv_1d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:) ! Compute Convolution call fftf ( this ) this % wk_1d = this % wk_1d * g call fftb ( this ) end subroutine conv_1d subroutine conv_2d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:) ! Compute Convolution call fftf ( this ) this % wk_2d = this % wk_2d * g call fftb ( this ) end subroutine conv_2d subroutine conv_3d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:,:) ! Compute Convolution call fftf ( this ) this % wk_3d = this % wk_3d * g call fftb ( this ) end subroutine conv_3d ! END private convolution procedures !>  Routines to construct spectral differential operators subroutine make_lap_1d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:) integer :: i , nx real ( pfdp ) :: kx nx = this % nx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if lap ( i ) = - kx ** 2 end do end subroutine make_lap_1d subroutine make_deriv_1d ( this , ddx ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: ddx (:) integer :: i , nx real ( pfdp ) :: kx nx = this % nx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if ddx ( i ) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do end subroutine make_deriv_1d subroutine make_lap_2d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:) integer :: i , j , nx , ny real ( pfdp ) :: kx , ky nx = this % nx ny = this % ny do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / this % Ly * dble ( j - 1 ) else ky = two_pi / this % Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if lap ( i , j ) = - ( kx ** 2 + ky ** 2 ) end do end do end subroutine make_lap_2d subroutine make_deriv_2d ( this , deriv , dir ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:) integer , intent ( in ) :: dir integer :: i , j , nx , ny real ( pfdp ) :: kx , ky nx = this % nx ny = this % ny do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / this % Ly * dble ( j - 1 ) else ky = two_pi / this % Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if if ( dir . eq . 1 ) then deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * kx else deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * ky endif end do end do end subroutine make_deriv_2d subroutine make_lap_3d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:,:) integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz nx = this % nx ny = this % ny nz = this % nz do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / this % Lz * dble ( k - 1 ) else kz = two_pi / this % Lz * dble ( - nz + k - 1 ) end if do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / this % Ly * dble ( j - 1 ) else ky = two_pi / this % Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if lap ( i , j , k ) = - ( kx ** 2 + ky ** 2 + kz ** 2 ) end do end do end do end subroutine make_lap_3d subroutine make_deriv_3d ( this , deriv , dir ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:,:) integer , intent ( in ) :: dir integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz nx = this % nx ny = this % ny nz = this % nz select case ( dir ) case ( 1 ) do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if deriv ( i ,:,:) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do case ( 2 ) do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / this % Ly * dble ( j - 1 ) else ky = two_pi / this % Ly * dble ( - ny + j - 1 ) end if deriv (:, j ,:) = ( 0.0_pfdp , 1.0_pfdp ) * ky end do case ( 3 ) do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / this % Lz * dble ( k - 1 ) else kz = two_pi / this % Lz * dble ( - nz + k - 1 ) end if deriv (:,:, k ) = ( 0.0_pfdp , 1.0_pfdp ) * kz end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , dir ) end select end subroutine make_deriv_3d end module pf_mod_fftpackage","tags":"","loc":"sourcefile/pf_fftw.f90.html","title":"pf_fftw.f90 – LibPFASST"},{"text":"Some convenient use statements This file depends on sourcefile~~pfasst.f90~~EfferentGraph sourcefile~pfasst.f90 pfasst.f90 sourcefile~pf_imexq.f90 pf_imexQ.f90 sourcefile~pfasst.f90->sourcefile~pf_imexq.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_results.f90 pf_results.f90 sourcefile~pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pfasst.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pfasst.f90->sourcefile~pf_mpi.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_imexq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imexq.f90->sourcefile~pf_dtype.f90 sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_imexq.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_imexq.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_imexq.f90->sourcefile~pf_utils.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_results.f90->sourcefile~pf_dtype.f90 sourcefile~pf_results.f90->sourcefile~pf_utils.f90 sourcefile~pf_parallel.f90->sourcefile~pf_hooks.f90 sourcefile~pf_parallel.f90->sourcefile~pf_results.f90 sourcefile~pf_parallel.f90->sourcefile~pf_dtype.f90 sourcefile~pf_parallel.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_parallel.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_parallel.f90->sourcefile~pf_timer.f90 sourcefile~pf_parallel.f90->sourcefile~pf_utils.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 sourcefile~pf_restrict.f90 pf_restrict.f90 sourcefile~pf_parallel.f90->sourcefile~pf_restrict.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_dtype.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_mpi.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_dtype.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_hooks.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_dtype.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_timer.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_utils.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_restrict.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_restrict.f90->sourcefile~pf_hooks.f90 sourcefile~pf_restrict.f90->sourcefile~pf_dtype.f90 sourcefile~pf_restrict.f90->sourcefile~pf_timer.f90 var pansourcefilepfasstf90EfferentGraph = svgPanZoom('#sourcefilepfasstf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pfasst Source Code pfasst.f90 Source Code !! Some convenient use statements ! ! This file is part of LIBPFASST. ! !>  Module containing a collection of \"use\" statements to simplify !!  including the common main modules in writing applications that use libpfasst module pfasst use pf_mod_dtype use pf_mod_hooks use pf_mod_results use pf_mod_parallel use pf_mod_pfasst #ifndef NOMPI use pf_mod_comm_mpi #endif use pf_mod_imexQ end module pfasst","tags":"","loc":"sourcefile/pfasst.f90.html","title":"pfasst.f90 – LibPFASST"},{"text":"This file depends on sourcefile~~pf_fftpack.f90~~EfferentGraph sourcefile~pf_fftpack.f90 pf_fftpack.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_fftpack.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_fftpack.f90->sourcefile~pf_utils.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_fftpackage Source Code pf_fftpack.f90 Source Code ! ! This file is part of LIBPFASST. ! !>  Module for reading parameters for the problem module pf_mod_fftpackage use pf_mod_dtype use pf_mod_utils implicit none real ( pfdp ), parameter :: two_pi = 6.2831853071795862_pfdp type :: pf_fft_t integer :: nx , ny , nz !! grid sizes integer :: dim !! spatial dimension integer :: lensavx , lensavy , lensavz !! workspace lengths real ( pfdp ) :: Lx , Ly , Lz !! domain size real ( pfdp ) :: normfact !! normalization factor real ( pfdp ), allocatable :: wsavex (:) ! work space real ( pfdp ), allocatable :: wsavey (:) ! work space real ( pfdp ), allocatable :: wsavez (:) ! work space complex ( pfdp ), pointer :: workhatx (:) ! work space complex ( pfdp ), pointer :: workhaty (:) ! work space complex ( pfdp ), pointer :: workhatz (:) ! work space complex ( pfdp ), pointer :: wk_1d (:) ! work space complex ( pfdp ), pointer :: wk_2d (:,:) ! work space complex ( pfdp ), pointer :: wk_3d (:,:,:) ! work space contains procedure :: fft_setup procedure :: fft_destroy procedure :: fftf procedure :: fftb procedure , private :: conv_1d , conv_2d , conv_3d generic :: conv => conv_1d , conv_2d , conv_3d procedure :: get_wk_ptr_1d procedure :: get_wk_ptr_2d procedure :: get_wk_ptr_3d procedure :: make_lap_1d procedure :: make_lap_2d procedure :: make_lap_3d procedure :: make_deriv_1d procedure :: make_deriv_2d procedure :: make_deriv_3d end type pf_fft_t contains function get_wk_ptr_1d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:) ! work space wk => this % wk_1d end function get_wk_ptr_1d function get_wk_ptr_2d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:,:) ! work space wk => this % wk_2d end function get_wk_ptr_2d function get_wk_ptr_3d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:,:,:) ! work space wk => this % wk_3d end function get_wk_ptr_3d subroutine fft_setup ( this , grid_shape , dim , grid_size ) class ( pf_fft_t ), intent ( inout ) :: this integer , intent ( in ) :: dim integer , intent ( in ) :: grid_shape ( dim ) real ( pfdp ), optional , intent ( in ) :: grid_size ( dim ) integer :: nx , ny , nz this % dim = dim !  FFT Storage parameters nx = grid_shape ( 1 ) this % nx = nx this % lensavx = 4 * nx + 15 this % normfact = nx allocate ( this % workhatx ( nx )) !  complex transform allocate ( this % wsavex ( this % lensavx )) this % Lx = 1.0_pfdp if ( present ( grid_size )) this % Lx = grid_size ( 1 ) !  Initialize FFT call ZFFTI ( nx , this % wsavex ) if ( dim > 1 ) then !  FFT Storage ny = grid_shape ( 2 ) this % ny = ny this % lensavy = 4 * ny + 15 this % normfact = nx * ny allocate ( this % workhaty ( ny )) !  complex transform allocate ( this % wsavey ( this % lensavy )) this % Ly = 1.0_pfdp if ( present ( grid_size )) this % Ly = grid_size ( 2 ) !  Initialize FFT call ZFFTI ( ny , this % wsavey ) if ( dim > 2 ) then !  FFT Storage nz = grid_shape ( 3 ) this % nz = nz this % lensavz = 4 * nz + 15 this % normfact = nx * ny * nz allocate ( this % workhatz ( nz )) !  complex transform allocate ( this % wsavez ( this % lensavz )) this % Lz = 1.0_pfdp if ( present ( grid_size )) this % Lz = grid_size ( 3 ) !  Initialize FFT call ZFFTI ( nz , this % wsavez ) endif endif select case ( this % dim ) case ( 1 ) allocate ( this % wk_1d ( nx )) case ( 2 ) allocate ( this % wk_2d ( nx , ny )) case ( 3 ) allocate ( this % wk_3d ( nx , ny , nz )) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_setup subroutine fft_destroy ( this ) class ( pf_fft_t ), intent ( inout ) :: this deallocate ( this % workhatx ) deallocate ( this % wsavex ) if ( this % dim > 1 ) then deallocate ( this % workhaty ) deallocate ( this % wsavey ) if ( this % dim > 2 ) then deallocate ( this % workhatz ) deallocate ( this % wsavez ) end if end if select case ( this % dim ) case ( 1 ) deallocate ( this % wk_1d ) case ( 2 ) deallocate ( this % wk_2d ) case ( 3 ) deallocate ( this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_destroy subroutine fftf ( this ) class ( pf_fft_t ), intent ( inout ) :: this integer i , j , k select case ( this % dim ) case ( 1 ) call zfftf ( this % nx , this % wk_1d , this % wsavex ) case ( 2 ) do j = 1 , this % ny this % workhatx = this % wk_2d (:, j ) call zfftf ( this % nx , this % workhatx , this % wsavex ) this % wk_2d (:, j ) = this % workhatx end do do i = 1 , this % nx this % workhaty = this % wk_2d ( i ,:) call zfftf ( this % ny , this % workhaty , this % wsavey ) this % wk_2d ( i ,:) = this % workhaty end do case ( 3 ) do k = 1 , this % nz do j = 1 , this % ny this % workhatx = this % wk_3d (:, j , k ) call zfftf ( this % nx , this % workhatx , this % wsavex ) this % wk_3d (:, j , k ) = this % workhatx end do end do do k = 1 , this % nz do i = 1 , this % nx this % workhaty = this % wk_3d ( i ,:, k ) call zfftf ( this % ny , this % workhaty , this % wsavey ) this % wk_3d ( i ,:, k ) = this % workhaty end do end do do j = 1 , this % ny do i = 1 , this % nx this % workhatz = this % wk_3d ( i , j ,:) call zfftf ( this % nz , this % workhatz , this % wsavez ) this % wk_3d ( i , j ,:) = this % workhatz end do end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftf subroutine fftb ( this ) class ( pf_fft_t ), intent ( inout ) :: this integer i , j , k select case ( this % dim ) case ( 1 ) this % wk_1d = this % wk_1d / this % normfact call zfftb ( this % nx , this % wk_1d , this % wsavex ) case ( 2 ) this % wk_2d = this % wk_2d / this % normfact do j = 1 , this % ny this % workhatx = this % wk_2d (:, j ) call zfftb ( this % nx , this % workhatx , this % wsavex ) this % wk_2d (:, j ) = this % workhatx end do do i = 1 , this % nx this % workhaty = this % wk_2d ( i ,:) call zfftb ( this % ny , this % workhaty , this % wsavey ) this % wk_2d ( i ,:) = this % workhaty end do case ( 3 ) this % wk_3d = this % wk_3d / this % normfact do k = 1 , this % nz do j = 1 , this % ny this % workhatx = this % wk_3d (:, j , k ) call zfftb ( this % nx , this % workhatx , this % wsavex ) this % wk_3d (:, j , k ) = this % workhatx end do end do do k = 1 , this % nz do i = 1 , this % nx this % workhaty = this % wk_3d ( i ,:, k ) call zfftb ( this % ny , this % workhaty , this % wsavey ) this % wk_3d ( i ,:, k ) = this % workhaty end do end do do j = 1 , this % ny do i = 1 , this % nx this % workhatz = this % wk_3d ( i , j ,:) call zfftb ( this % nz , this % workhatz , this % wsavez ) this % wk_3d ( i , j ,:) = this % workhatz end do end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftb ! START private convolution procedures subroutine conv_1d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:) ! Compute Convolution call fftf ( this ) this % wk_1d = this % wk_1d * g call fftb ( this ) end subroutine conv_1d subroutine conv_2d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:) ! Compute Convolution call fftf ( this ) this % wk_2d = this % wk_2d * g call fftb ( this ) end subroutine conv_2d subroutine conv_3d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:,:) ! Compute Convolution call fftf ( this ) this % wk_3d = this % wk_3d * g call fftb ( this ) end subroutine conv_3d ! END private convolution procedures subroutine make_lap_1d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:) integer :: i , nx real ( pfdp ) :: kx , Lx nx = this % nx Lx = this % Lx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i ) = - kx ** 2 end do end subroutine make_lap_1d subroutine make_deriv_1d ( this , ddx ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: ddx (:) integer :: i , nx real ( pfdp ) :: kx , Lx nx = this % nx Lx = this % Lx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if ddx ( i ) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do end subroutine make_deriv_1d subroutine make_lap_2d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:) integer :: i , j , nx , ny real ( pfdp ) :: kx , ky , Lx , Ly nx = this % nx ny = this % ny Lx = this % Lx Ly = this % Ly do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i , j ) = - ( kx ** 2 + ky ** 2 ) end do end do end subroutine make_lap_2d subroutine make_deriv_2d ( this , deriv , dir ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:) integer , intent ( in ) :: dir integer :: i , j , nx , ny real ( pfdp ) :: kx , ky , Lx , Ly nx = this % nx ny = this % ny Lx = this % Lx Ly = this % Ly do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if if ( dir . eq . 1 ) then deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * kx else deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * ky endif end do end do end subroutine make_deriv_2d subroutine make_lap_3d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:,:) integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz , Lx , Ly , Lz nx = this % nx ny = this % ny nz = this % nz Lx = this % Lx Ly = this % Ly Lz = this % Lz do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / Lz * dble ( k - 1 ) else kz = two_pi / Ly * dble ( - nz + k - 1 ) end if do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i , j , k ) = - ( kx ** 2 + ky ** 2 + kz ** 2 ) end do end do end do end subroutine make_lap_3d subroutine make_deriv_3d ( this , deriv , dir ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:,:) integer , intent ( in ) :: dir integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz , Lx , Ly , Lz nx = this % nx ny = this % ny nz = this % nz Lx = this % Lx Ly = this % Ly Lz = this % Lz select case ( dir ) case ( 1 ) do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if deriv ( i ,:,:) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do case ( 2 ) do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if deriv (:, j ,:) = ( 0.0_pfdp , 1.0_pfdp ) * ky end do case ( 3 ) do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / Lz * dble ( k - 1 ) else kz = two_pi / Ly * dble ( - nz + k - 1 ) end if deriv (:,:, k ) = ( 0.0_pfdp , 1.0_pfdp ) * kz end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , dir ) end select end subroutine make_deriv_3d end module pf_mod_fftpackage","tags":"","loc":"sourcefile/pf_fftpack.f90.html","title":"pf_fftpack.f90 – LibPFASST"},{"text":"N-dimensional complex array encapsulation. This file depends on sourcefile~~pf_zndsysarray.f90~~EfferentGraph sourcefile~pf_zndsysarray.f90 pf_zndsysarray.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_zndsysarray.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_zndsysarray Source Code pf_zndsysarray.f90 Source Code !!  N-dimensional complex array encapsulation. ! ! This file is part of LIBPFASST. ! !> System of complex N-dimensional arrays encapsulation. !! !! When a new solution is created by a PFASST level, this encapsulation !! uses the levels 'arr_shape' attribute to create a new multi-component array with that !! shape.  Thus, the 'arr_shape' attributes of the PFASST levels should be !! set appropriately.  The last component of arr_shape is the number of components in the system !! !! For example, before calling pf_pfasst_run we can !! set the arr_shape of the coarsest level by doing: !! !!   allocate(pf%levels(1)%arr_shape(3)) !!   pf%levels(1)%arr_shape = [ nx, ny, 3 ] !! !! Which would imply that a 3 component system of two-dimensional solutions. !! !! The helper routines array1, array2, array3, etc can be used to !! extract pointers to a component of  encapsulated system !! performing any copies. !! module pf_mod_zndsysarray use iso_c_binding use pf_mod_dtype implicit none !>  Type to create and destroy the arrays type , extends ( pf_factory_t ) :: zndsysarray_factory contains procedure :: create_single => zndsysarray_create_single procedure :: create_array => zndsysarray_create_array procedure :: destroy_single => zndsysarray_destroy_single procedure :: destroy_array => zndsysarray_destroy_array end type zndsysarray_factory !>  Type to extend the abstract encap and set procedure pointers type , extends ( pf_encap_t ) :: zndsysarray integer :: dim !  The spatial dimension of each component in system integer :: ncomp !  The number of components in the system integer :: ndof !  The number of variables in each component integer , allocatable :: arr_shape (:) complex ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => zndsysarray_setval procedure :: copy => zndsysarray_copy procedure :: norm => zndsysarray_norm procedure :: pack => zndsysarray_pack procedure :: unpack => zndsysarray_unpack procedure :: axpy => zndsysarray_axpy procedure :: eprint => zndsysarray_eprint end type zndsysarray !> Interfaces to output routines in pf_numpy.c interface !>  Subroutine to make a directory for output subroutine zndsysarray_mkdir ( dname , dlen ) bind ( c ) use iso_c_binding character ( c_char ), intent ( in ) :: dname integer , intent ( in ), value :: dlen end subroutine zndsysarray_mkdir !>  Subroutine to write an the array to a file subroutine zndsysarray_dump_numpy ( dname , fname , endian , dim , mpibuflen , arr_shape , array ) bind ( c ) use iso_c_binding character ( c_char ), intent ( in ) :: dname , fname , endian ( 5 ) integer , intent ( in ), value :: dim , mpibuflen integer , intent ( in ) :: arr_shape ( dim ) real ( c_double ), intent ( in ) :: array ( mpibuflen ) end subroutine zndsysarray_dump_numpy end interface contains !>  Subroutine to allocate the array and set the size parameters subroutine zndsysarray_build ( q , arr_shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: arr_shape (:) select type ( q ) class is ( zndsysarray ) allocate ( q % arr_shape ( size ( arr_shape ))) q % dim = size ( arr_shape ) - 1 q % ncomp = arr_shape ( q % dim + 1 ) q % ndof = product ( arr_shape ( 1 : q % dim )) q % arr_shape = arr_shape allocate ( q % flatarray ( product ( arr_shape ))) end select end subroutine zndsysarray_build !> Subroutine to  create a single array subroutine zndsysarray_create_single ( this , x , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) integer :: i allocate ( zndsysarray :: x ) call zndsysarray_build ( x , shape ) end subroutine zndsysarray_create_single !> Subroutine to create an array of arrays subroutine zndsysarray_create_array ( this , x , n , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( zndsysarray :: x ( n )) do i = 1 , n call zndsysarray_build ( x ( i ), shape ) end do end subroutine zndsysarray_create_array !>  Subroutine to destroy array subroutine zndsysarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( zndsysarray ), pointer :: zndsysarray_obj zndsysarray_obj => cast_as_zndsysarray ( encap ) deallocate ( zndsysarray_obj % arr_shape ) deallocate ( zndsysarray_obj % flatarray ) nullify ( zndsysarray_obj ) end subroutine zndsysarray_destroy !> Subroutine to destroy an single array subroutine zndsysarray_destroy_single ( this , x , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) select type ( x ) class is ( zndsysarray ) deallocate ( x % arr_shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine zndsysarray_destroy_single !> Subroutine to destroy an array of arrays subroutine zndsysarray_destroy_array ( this , x , n , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i select type ( x ) class is ( zndsysarray ) do i = 1 , n deallocate ( x ( i )% arr_shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine zndsysarray_destroy_array !>  The following are the base subroutines that all encapsulations must provide !! !> Subroutine to set array to a scalare  value. subroutine zndsysarray_setval ( this , val , flags ) class ( zndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine zndsysarray_setval !> Subroutine to copy an array subroutine zndsysarray_copy ( this , src , flags ) class ( zndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( zndsysarray ) this % flatarray = src % flatarray class default stop \"TYPE ERROR\" end select end subroutine zndsysarray_copy !> Subroutine to pack an array into a flat array for sending subroutine zndsysarray_pack ( this , z , flags ) class ( zndsysarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: ntot ntot = this % ndof * this % ncomp z ( 1 : ntot ) = real ( this % flatarray , pfdp ) z ( ntot + 1 : 2 * ntot ) = aimag ( this % flatarray ) end subroutine zndsysarray_pack !> Subroutine to unpack a flatarray after receiving subroutine zndsysarray_unpack ( this , z , flags ) class ( zndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: ntot ntot = this % ndof * this % ncomp this % flatarray = z ( 1 : ntot ) this % flatarray = this % flatarray + cmplx ( 0.0 , 1.0 , pfdp ) * z ( ntot + 1 : 2 * ntot ) this % flatarray = cmplx ( z ( 1 : ntot ), z ( ntot + 1 : 2 * ntot )) end subroutine zndsysarray_unpack !> Subroutine to define the norm of the array (here the max norm) function zndsysarray_norm ( this , flags ) result ( norm ) class ( zndsysarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function zndsysarray_norm !> Subroutine to compute y = a x + y where a is a scalar and x and y are arrays subroutine zndsysarray_axpy ( this , a , x , flags ) class ( zndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( zndsysarray ) this % flatarray = a * x % flatarray + this % flatarray class default stop \"TYPE ERROR\" end select end subroutine zndsysarray_axpy !>  Subroutine to print the array to the screen (mainly for debugging purposes) subroutine zndsysarray_eprint ( this , flags ) class ( zndsysarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % flatarray ( 1 : 10 ) !print *, this%flatarray end subroutine zndsysarray_eprint function cast_as_zndsysarray ( encap_polymorph ) result ( zndsysarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( zndsysarray ), pointer :: zndsysarray_obj select type ( encap_polymorph ) type is ( zndsysarray ) zndsysarray_obj => encap_polymorph end select end function cast_as_zndsysarray !>  Helper function to return the array part function get_array1d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:) select type ( x ) type is ( zndsysarray ) r => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array1d function get_array2d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( zndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array2d function get_array3d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( zndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 ), 1 : x % arr_shape ( 3 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array3d end module pf_mod_zndsysarray","tags":"","loc":"sourcefile/pf_zndsysarray.f90.html","title":"pf_zndsysarray.f90 – LibPFASST"},{"text":"This file depends on sourcefile~~pf_exp.f90~~EfferentGraph sourcefile~pf_exp.f90 pf_exp.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_exp.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_exp.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_exp.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_exp.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_exp Source Code pf_exp.f90 Source Code ! ===================================================================================== ! MODULE: pf_mod_exp ! !> @author !> Tommaso Buvoli ! ! Last Modified: Dec 28, 2018 ! ! Description ! !!  this module extends pf_sweeper_t and is used for creating an exponential sweeper !!  that solves equations of the form !!            y' = L y + N(t,y)   !!  When extending this class, you must supply the functions phib, swpPhib, and resPhib !!  that each compute matrix-vector products of the form !!          \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i  !!  in addition to the function f_eval for compluting the nonlinear term N(t,y). !!  The complete description of these three functions is contained below. ! ===================================================================================== module pf_mod_exp use pf_mod_dtype use pf_mod_utils implicit none ! Exponential SDC sweeper type, extends abstract pf_sweeper_t type , extends ( pf_sweeper_t ), abstract :: pf_exp_t real ( pfdp ), allocatable :: w (:,:,:) ! weights real ( pfdp ), allocatable :: nodes (:) ! nodes real ( pfdp ), allocatable :: eta (:) ! normalized substeps (on interval [0, 1]) class ( pf_encap_t ), allocatable :: b (:) ! scratch space for computing nonlinear derivatives class ( pf_encap_t ), allocatable :: f_old (:) ! scratch space for storing nonlinear terms class ( pf_encap_t ), allocatable :: newF ! scratch space for storing new function evaluations LOGICAL :: use_phib = . TRUE . ! if TRUE calls phib otherwise calls swpPhib and resPhib contains ! specialized procedures for exponential integrator procedure ( pf_f_eval_p ), deferred :: f_eval ! computes nonlinear term in equation procedure ( pf_phib ), deferred :: phib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i procedure ( pf_swpPhib ), deferred :: swpPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n,j} for j = 1, ... q - 1 procedure ( pf_resPhib ), deferred :: resPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n} for j = 1, ... q - 1 procedure , private :: weights procedure , private :: LocalDerivsAtNode ! generic functions procedure :: initialize => exp_initialize procedure :: sweep => exp_sweep procedure :: evaluate => exp_evaluate procedure :: integrate => exp_integrate procedure :: residual => exp_residual procedure :: spreadq0 => exp_spreadq0 procedure :: evaluate_all => exp_evaluate_all procedure :: destroy => exp_destroy ! functions that can be accessed directly by types that inherit pf_exp_t procedure :: exp_destroy procedure :: exp_initialize end type pf_exp_t interface ! DESCRIPTION OF REQUIRED FUNCTIONS ! =================================================================================             REMARK: ADDING ax operation would simplify dealing with h for b(2:end) ! PHIB: Computes the product of vectors and phi functions ! !       y(t) = exp(t h L) b_1 + h \\sum_{i=1}&#94;n t&#94;i \\varphi_i(t h L)b_{i+1} ! !       for a user specified t, and h. ! !       NOTE: The operator L is not passed in as a parameter, and must be !       implemented appropriately within the function. ! ! Arguments ! !   t   (input) DOUBLE !       evaluation time for expression ! !   h   (input) DOUBLE !       scaling factor for the linear opeartor AND the vectors b_i for i = 2 ... n ! !   b   (input) pf_encap_t(:) !       array that stores the vectors b_i ! !   y   (output) pf_encap_t !       once subroutine terminate this stores the result y(t) ! ================================================================================= subroutine pf_phib ( this , t , h , b , y ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: h class ( pf_encap_t ), intent ( in ) :: b (:) class ( pf_encap_t ), intent ( inout ) :: y end subroutine pf_phib ! ================================================================================= ! SWPPHIB: Computes the product of vectors and phi functions ! !           y(t) = \\varphi_0(h L) b_1 + h \\sum_{i=1}&#94;n t&#94;i \\varphi_i(t h L)b_{i+1} ! !       where the time t is ! !           t_{n,j+1} - t_{n,j}         j = 1, ... q - 1 ! !       and h is a user specified. This procedure is used when computing !       exponential correction sweeps. ! !       NOTE: The operator L is not passed in as a parameter, and must be !       implemented appropriately within the function. ! ! Arguments ! !   j   (input) Integer !       substep index for determining t: t = t_{n,j+1} - t_{n,j} ! !   h   (input) DOUBLE !       scaling factor for the linear opeartor AND the vectors b_i for i = 2 ... n ! !   b   (input) pf_encap_t(:) !       array that stores the vectors b_i ! !   y   (output) pf_encap_t !       once subroutine terminate this stores the result y(t) ! ================================================================================= subroutine pf_swpPhib ( this , j , h , b , y ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this integer , intent ( in ) :: j real ( pfdp ), intent ( in ) :: h class ( pf_encap_t ), intent ( in ) :: b (:) class ( pf_encap_t ), intent ( inout ) :: y end subroutine pf_swpPhib ! ================================================================================= ! RESPHIB: Computes the product of vectors and phi functions ! !           y(t) = \\varphi_0(h L) b_1 + h \\sum_{i=1}&#94;n t&#94;i \\varphi_i(t h L)b_{i+1} ! !       where the time t is ! !           t_{n,j} - t_{n} ! !       and h is a user specified. This procedure is used when computing !       exponential correction sweeps. ! !       NOTE: The operator L is not passed in as a parameter, and must be !       implemented appropriately within the function. ! ! Arguments ! !   j   (input) Integer !       substep index for determining t: t = t_{n,j+1} - t_{n} ! !   h   (input) DOUBLE !       scaling factor for the linear opeartor AND the vectors b_i for i = 2 ... n ! !   b   (input) pf_encap_t(:) !       array that stores the vectors b_i ! !   y   (output) pf_encap_t !       once subroutine terminate this stores the result y(t) ! ================================================================================= subroutine pf_resPhib ( this , j , h , b , y ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this integer , intent ( in ) :: j real ( pfdp ), intent ( in ) :: h class ( pf_encap_t ), intent ( in ) :: b (:) class ( pf_encap_t ), intent ( inout ) :: y end subroutine pf_resPhib ! ================================================================================= ! f_eval: computes the equations nonlinear term N(t,y) ! ! Arguments ! !   y     (input) pf_encap_t !         solution y(t) ! !   t     (input) DOUBLE !         time t ! !   level (input) INTEGER !         current level index ! !   f     (output) pf_encap_t !         N(t,y) ! ================================================================================= subroutine pf_f_eval_p ( this , y , t , level , n ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: n end subroutine pf_f_eval_p end interface contains ! ================================================================================= ! INITIALIZE: initializes the following internal parameters !      w        DOUBLE(:,:,:)     contains FD weights for computing local derivatives at t_{n,j} !      nodes    DOUBLE(:)         sdc nodes !      eta      DOUBLE(:)         normalized substeps (t_{n,j+1} - t_{n,j})/h !      npieces  INTEGER           number of RHS peices (always will be one) !      newF     pf_encap_t        stores new function evaluations !      b        pf_encap_t(:)     stores vectors b for computing phi products ! ================================================================================= subroutine exp_initialize ( this , lev ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev ! local variables integer :: i , nnodes real ( pfdp ), allocatable :: q (:) nnodes = lev % nnodes allocate ( this % eta ( nnodes - 1 )) allocate ( this % nodes ( nnodes )) allocate ( q ( nnodes )) ! set nodes and substeps this % nodes = lev % sdcmats % qnodes this % eta = this % nodes ( 2 : nnodes ) - this % nodes ( 1 : nnodes - 1 ) ! substeps ! compute weights allocate ( this % w ( nnodes - 1 , nnodes , nnodes )) do i = 1 , nnodes - 1 q = this % nodes - this % nodes ( i ); call weights ( this , real ( 0.0 , pfdp ), q , nnodes - 1 , this % W ( i , :, :)); end do ! set number of rhs components this % npieces = 1 ! initialize temporary storage objects call lev % ulevel % factory % create_single ( this % newF , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % b , nnodes + 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % f_old , nnodes , lev % index , lev % shape ) end subroutine exp_initialize ! SWEEP: exponential sweep subroutine =============================================== subroutine exp_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags ! local variables class ( pf_level_t ), pointer :: lev integer :: m , nnodes , j , k real ( pfdp ) :: t lev => pf % levels ( level_index ) nnodes = lev % nnodes call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) ! compute F_j&#94;{[k+1]} ! error sweeps do k = 1 , nsweeps call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! NOTE: ensure that lev%F has been properly initialized here do j = 1 , nnodes call this % f_old ( j )% copy ( lev % F ( j , 1 )) ! Save old f end do t = t0 do j = 1 , nnodes - 1 t = t0 + dt * this % eta ( j ) ! form b vectors !              call LocalDerivsAtNode(this, j, nnodes, lev%F(:,1), this%b(2:nnodes+1))  ! phi expansion for exponential picard integral call LocalDerivsAtNode ( this , j , nnodes , this % f_old (:), this % b ( 2 : nnodes + 1 )) ! phi expansion for exponential picard integral call this % b ( 1 )% copy ( lev % Q ( j )) ! add term \\phi_0(tL) y_n if ( j > 1 ) then ! add term \\phi_1(tL) (F_j&#94;{[k+1]} - F_j&#94;{[k]}) call this % b ( 2 )% axpy ( real ( - 1.0 , pfdp ), this % f_old ( j )) ! add -\\phi_1(tL) F_j&#94;{[k]} endif call this % f_eval ( lev % Q ( j ), t , lev % index , lev % F ( j , 1 )) ! compute F_j&#94;{[k+1]} if ( j > 1 ) then ! add term \\phi_1(tL) (F_j&#94;{[k+1]} - F_j&#94;{[k]}) call this % b ( 2 )% axpy ( real ( 1.0 , pfdp ), lev % F ( j , 1 )) ! add \\phi_1(tL) F_j&#94;{[k+1]} end if ! compute phi products if ( this % use_phib ) then call this % phib ( this % eta ( j ), dt , this % b , lev % Q ( j + 1 )) else call this % swpPhib ( j , dt , this % b , lev % Q ( j + 1 )) end if !!$              !  Now we have to add in the tauQ if ( allocated ( lev % tauQ )) then call lev % Q ( j + 1 )% axpy ( 1.0_pfdp , lev % tauQ ( j )) if ( j > 1 ) then ! The tau is not node to node !                    call lev%Q(j+1)%axpy(-1.0_pfdp, lev%tauQ(j-1)) end if end if !!$ end do call this % f_eval ( lev % Q ( nnodes ), t0 + dt , lev % index , lev % F ( nnodes , 1 )) ! eval last nonlinear term call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do end subroutine exp_sweep ! ================================================================================= ! INTEGRATE: computes the integrals for the exponential Picard residual ! !         r_j = A_j - B_j ! !     where ! !         A_j = \\left[ \\exp(t h L) y(t_n) - \\int_{t_n}&#94;{t_{n,j}} \\exp(L(t - t_n)) P(t) dt \\right] !         B_j = y(t_{n,j}) ! !     NOTE: This procedure computes the expression \\hat{r}_j = A_j - y(t_n). The !     term y(t_n) is subtracted from result since the generic calling function !     compute the residual as ! !        r_j = y(t_n) + exp_integrate() - y(t_{n,j}) ! !     thus incorrectly adding the term y_n ! ================================================================================= subroutine exp_integrate ( this , lev , qSDC , fSDC , dt , fintsdc , flags ) ! parameters class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev !!  Current level class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintsdc (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags ! local variables integer :: i , nnodes nnodes = lev % nnodes !!$        call LocalDerivsAtNode(this, 1, nnodes, fSDC(:,1), this%b(2:nnodes+1)) ! compute derivatives !!$        call this%b(1)%setval(real(0.0, pfdp)) !!$        call this%b(1)%axpy(real(1.0, pfdp), qSDC(1)) !!$        do i = 1, nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}} !!$            if (this%use_phib) then !!$                call this%phib(this%nodes(i+1), dt, this%b, fintsdc(i)) !!$            else !!$                call this%resPhib(i, dt, this%b, fintsdc(i)) !!$             end if !!$        end do do i = 1 , nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}} call LocalDerivsAtNode ( this , i , nnodes , fSDC (:, 1 ), this % b ( 2 : nnodes + 1 )) ! compute derivatives call this % b ( 1 )% copy ( qSDC ( i )) call fintsdc ( i )% setval ( 0.0_pfdp ) if ( this % use_phib ) then call this % phib ( this % eta ( i ), dt , this % b , fintsdc ( i )) else call this % resPhib ( i , dt , this % b , fintsdc ( i )) end if !             if (i > 1) then !                call fintsdc(i)%axpy(1.0_pfdp,fintsdc(i-1)) !             end if !             print *,'integrating',i,this%nodes(i+1),dt,this%eta(i) !          call fintsdc(i)%eprint() end do !        do i = 1, nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}} !             call fintsdc(i)%axpy(-1.0_pfdp,qSDC(1)) !        end do !             print *,'integrating',i,this%nodes(i+1),dt,this%eta(i) !          call fintsdc(i)%eprint() end subroutine exp_integrate ! RESIDUAL: compute  residual (generic) ==================================== subroutine exp_residual ( this , lev , dt , flags ) class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags integer :: m !>  Compute the integral of F from t_n to t_m at each node call lev % ulevel % sweeper % integrate ( lev , lev % Q , lev % F , dt , lev % I , flags ) !> add tau if it exists if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) if ( m > 1 ) then !     call lev%I(m)%axpy(-1.0_pfdp, lev%tauQ(m-1), flags) end if end do end if !> subtract out the solution value do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) !           call lev%R(m)%axpy(1.0_pfdp, lev%Q(1)) end do end subroutine exp_residual ! SPREADQ: spread solution (generic) ====================================== subroutine exp_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine exp_spreadq0 ! EVALUATE: evaluate the nonlinear term at node m ======================== subroutine exp_evaluate ( this , lev , t , m , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine exp_evaluate ! EVALUATE_ALL: evaluate the nonlinear term at all nodes ================= subroutine exp_evaluate_all ( this , lev , t , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine exp_evaluate_all ! DEALLOCATE: deallocate sweeper variables subroutine exp_destroy ( this , lev ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level deallocate ( this % w ) deallocate ( this % eta ) deallocate ( this % newF ) call lev % ulevel % factory % destroy_array ( this % b , lev % index , lev % nnodes , lev % shape ) call lev % ulevel % factory % destroy_array ( this % f_old , lev % index , lev % nnodes , lev % shape ) end subroutine exp_destroy ! ======================================================================= ! LocalDerivsAtNode: approximate the local derivative vector !           at the substep t_{n,i} for the nonlinear function N(y(t)) !           using the terms N(y{n,i}). Local coordinates coorespond to !           s = h t. ! Arguments ! !   i       (input) INTEGER !           index of the substep for which we want to approximate derivatives ! !   nnodes  (input) INTEGER !           number of nodes ! !   N_eval  (input) pf_encap_t(:) !           Nonlinear function evaluations; N_eval(i) contains N(y_{n,i}) ! !   N_deriv (output) pf_encap_t(:) !           N_deriv(i) approximates \\frac{d&#94;{i-1}}{dt&#94;{i-1}} N(y(t)) ! ======================================================================= subroutine LocalDerivsAtNode ( this , i , nnodes , N_eval , N_deriv ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this integer , intent ( in ) :: i integer , intent ( in ) :: nnodes class ( pf_encap_t ), intent ( in ) :: N_eval (:) class ( pf_encap_t ), intent ( inout ) :: N_deriv (:) ! local variables integer :: j , k ! form nonlinear derivative vectors b do j = 1 , nnodes ! loop over derivatives j = 1 ... n call N_deriv ( j )% setval ( real ( 0.0 , pfdp )) do k = 1 , nnodes ! look over nodes k = 1 ... n call N_deriv ( j )% axpy ( this % w ( i , k , j ), N_eval ( k )) end do end do end ! ======================================================================= ! WEIGHTS   Compute coefficients for finite difference approximation for !           the derivatives 1 to m at point z assuming data is known at !           points in array x. Based on the program \"weights\" in !           B. Fornberg, \"Calculation of weights in finite difference !           formulas\", SIAM Review 40 (1998), pp. 685-691. ! Arguments ! !   z   (input) DOUBLE !       location where approximations are to be accurate ! !   x   (input) DOUBLE Array !       array containing interpolation points ! !   m   (input) INTEGER !       highest derivative for which weights are sought ! !   W   (output) DOUBLE array, dimension(size(x),m+1) !       matrix that gives weights at grid locations x for !       derivative of order j<=m are found in c(:,j) ! ======================================================================= subroutine weights ( this , z , x , m , W ) ! Arguments class ( pf_exp_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z real ( pfdp ), intent ( in ) :: x (:) integer , intent ( in ) :: m real ( pfdp ), intent ( out ) :: W ( size ( x ), m + 1 ) ! Variable Declarations real ( pfdp ) :: c1 , c2 , c3 , c4 , c5 integer :: i , j , k , n , mn c1 = 1.0_pfdp c4 = x ( 1 ) - z W = 0.0_pfdp W ( 1 , 1 ) = 1.0_pfdp n = size ( x ) do i = 2 , n mn = min ( i , m + 1 ) c2 = 1.0_pfdp c5 = c4 c4 = x ( i ) - z do j = 1 , i - 1 c3 = x ( i ) - x ( j ) c2 = c2 * c3 ; if ( j == i - 1 ) then do k = mn , 2 , - 1 W ( i , k ) = c1 * ( real ( k - 1 , pfdp ) * W ( i - 1 , k - 1 ) - c5 * W ( i - 1 , k )) / c2 ; enddo W ( i , 1 ) = - c1 * c5 * W ( i - 1 , 1 ) / c2 ; endif do k = mn , 2 , - 1 W ( j , k ) = ( c4 * W ( j , k ) - real ( k - 1 , pfdp ) * W ( j , k - 1 )) / c3 ; enddo W ( j , 1 ) = c4 * W ( j , 1 ) / c3 ; enddo c1 = c2 ; enddo end subroutine weights end module pf_mod_exp","tags":"","loc":"sourcefile/pf_exp.f90.html","title":"pf_exp.f90 – LibPFASST"},{"text":"Verlet type sweeper for 2nd order problems! This file depends on sourcefile~~pf_verlet.f90~~EfferentGraph sourcefile~pf_verlet.f90 pf_verlet.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_verlet.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_verlet.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_verlet.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_verlet.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_verlet Source Code pf_verlet.f90 Source Code !! Verlet type sweeper for 2nd order problems! ! ! This file is part of LIBPFASST. ! !> Verlet type sweeper for 2nd order problems !! !!  This is intended for Hamiltonian problems of the form !! !!    q'=p, p'=f(q)  !! !! or !! !!     x'=v, x''=f(x)  !! !!  So p is not momentum here, but velocity module pf_mod_verlet use pf_mod_dtype use pf_mod_utils implicit none !> Define sweeper type type , extends ( pf_sweeper_t ), abstract :: pf_verlet_t integer :: whichQQ = 3 integer :: doLU real ( pfdp ) :: Htol , H0 !  Matrices real ( pfdp ), ALLOCATABLE :: Qmat (:,:) !  Spectral matrix for v real ( pfdp ), ALLOCATABLE :: QQmat (:,:) !  Spectral matrix for x real ( pfdp ), ALLOCATABLE :: Qver (:,:) !  Verlet matrix for v (Trapezoid) real ( pfdp ), ALLOCATABLE :: QQver (:,:) !  Verlet matrix for x real ( pfdp ), ALLOCATABLE :: Qtil (:,:) !  Approximate matrix for v real ( pfdp ), ALLOCATABLE :: QQtil (:,:) !  Approximate matrix for x real ( pfdp ), ALLOCATABLE :: DQver (:,:) !  Qmat-Qver real ( pfdp ), ALLOCATABLE :: DQQver (:,:) !  QQmat-QQver real ( pfdp ), ALLOCATABLE :: DQtil (:,:) !  Qmat-Qtil real ( pfdp ), ALLOCATABLE :: DQQtil (:,:) !  QQmat-QQtil real ( pfdp ), ALLOCATABLE :: bvec (:) !  Quadrature rule for v real ( pfdp ), ALLOCATABLE :: bbarvec (:) !  Quadrature rule for x real ( pfdp ), allocatable :: dtsdc (:) !  SDC step sizes real ( pfdp ), allocatable :: tsdc (:) !  SDC times logical :: iqend !  Decide whether to set qend by another Picard class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver procedure ( pf_hamiltonian_p ), deferred :: hamiltonian !!  Hamiltonian !>  Set the generic functions procedure :: sweep => verlet_sweep procedure :: initialize => verlet_initialize procedure :: evaluate => verlet_evaluate procedure :: integrate => verlet_integrate procedure :: residual => verlet_residual procedure :: spreadq0 => verlet_spreadq0 procedure :: evaluate_all => verlet_evaluate_all procedure :: destroy => verlet_destroy procedure :: verlet_destroy end type pf_verlet_t interface !>  This is the interface for the routine to compute the RHS function values !>  Evaluate f_piece(y), where piece is one or two subroutine pf_f_eval_p ( this , y , t , level_index , f ) !>  Evaluate f_piece(y), where piece is one or two import pf_verlet_t , pf_encap_t , pfdp class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y !!  Argument for evaluation real ( pfdp ), intent ( in ) :: t !!  Time at evaluation integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  RHS function value !       integer,    intent(in   ) :: piece           !!  Which piece to evaluate end subroutine pf_f_eval_p !>  Solve the equation y - dtq*f_2(y) =rhs subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece ) import pf_verlet_t , pf_encap_t , pfdp class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Solution of implicit solve real ( pfdp ), intent ( in ) :: t !!  Time of solve real ( pfdp ), intent ( in ) :: dtq !!  dt*quadrature weight class ( pf_encap_t ), intent ( in ) :: rhs !!  RHS for solve integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  f_2 of solution y integer , intent ( in ) :: piece !!  Which piece to evaluate end subroutine pf_f_comp_p function pf_hamiltonian_p ( this , y , t , level_index ) result ( H ) import pf_verlet_t , pf_encap_t , pfdp class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Variable real ( pfdp ), intent ( in ) :: t !!  Time of solve integer , intent ( in ) :: level_index !!  Level index real ( pfdp ) :: H end function pf_hamiltonian_p end interface contains !----------------------------------------------------------------------------- !> Perform one SDC sweep on level lev_index and set qend appropriately subroutine verlet_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: k , m , n , nnodes real ( pfdp ) :: t , dtmhalf , dtsq real ( pfdp ) :: H lev => pf % levels ( level_index ) !!  Assign level pointer nnodes = lev % nnodes call start_timer ( pf , TLEVEL + lev % index - 1 ) ! ! check hamiltonian ! !    call this%hamiltonian(t0+dt, Lev%qend, encapctx%m,H) !    print *,'Ham=',H,this%Htol,this%H0 !    if ((pf%state%iter > 1) .and. (abs(H-this%H0) < this%Htol)) then !       call Lev%encap%copy(Lev%qend, Lev%Q(nnodes)) !          print *, 'Skipping SDC sweep' !       return !    end if ! ! compute integrals and add fas correction ! dtsq = dt * dt do k = 1 , nsweeps do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) if ( pf % state % iter . eq . 1 ) then !  Do verlet on the first iteration do n = 1 , nnodes call lev % I ( m )% axpy ( dt * this % DQver ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dtsq * this % DQQver ( m , n ), lev % F ( n , 1 ), 2 ) end do else do n = 1 , nnodes call lev % I ( m )% axpy ( dt * this % DQtil ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dtsq * this % DQQtil ( m , n ), lev % F ( n , 1 ), 2 ) end do end if if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) end if t = t0 ! do the sub-stepping in sweep do m = 1 , nnodes - 1 t = t + dt * this % dtsdc ( m ) dtmhalf = 0.5d0 * dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp ) !  Lower triangular verlet to  new piece if ( pf % state % iter . eq . 1 ) then do n = 1 , m call this % rhs % axpy ( dtsq * this % QQver ( m , n ), lev % F ( n , 1 ), 2 ) end do else do n = 1 , m call this % rhs % axpy ( dtsq * this % QQtil ( m , n ), lev % F ( n , 1 ), 2 ) end do endif !>  Add the integral term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) !>  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 2 ) !>  Add the dt*v_0 call this % rhs % axpy ( t - t0 , lev % Q ( 1 ), 12 ) !  Update position term call lev % Q ( m + 1 )% copy ( this % rhs , 2 ) !  update function values call this % f_eval ( Lev % Q ( m + 1 ), t , lev % index , Lev % F ( m + 1 , 1 )) !  Now do the v peice call this % rhs % setval ( 0.0_pfdp , 1 ) !  Lower triangular verlet to  new piece if ( pf % state % iter . eq . 1 ) then do n = 1 , m + 1 call this % rhs % axpy ( dt * this % Qver ( m , n ), Lev % F ( n , 1 ), 1 ) end do else do n = 1 , m + 1 call this % rhs % axpy ( dt * this % Qtil ( m , n ), Lev % F ( n , 1 ), 1 ) end do end if call this % rhs % axpy ( 1.0_pfdp , Lev % I ( m ), 1 ); call this % rhs % axpy ( 1.0_pfdp , Lev % Q ( 1 ), 1 ) !  Start m+1 with value from 1 call lev % Q ( m + 1 )% copy ( this % rhs , 1 ) end do !!  End substep loop !  Set the value of qend !  If Gauss nodes, we must do integration !  unless the sweep was an initial Verlet !  For Lobatto nodes, we have a choice of whether to just use the !  value at the last node, or recompute it. !       if (this%iqend .and. pf%state%iter .gt. 1) then !          call Lev%encap%copy(Lev%qend, Lev%Q(1)) !          call Lev%encap%axpy(Lev%qend, dt, Lev%Q(1), 12)  !  Add the dt*v_0 term !          m = nnodes !          do n = 1, nnodes !             call Lev%encap%axpy(Lev%qend, dt*this%Qmat(m,n), Lev%F(n,1),1) !             call Lev%encap%axpy(Lev%qend, dtsq*this%QQmat(m,n), Lev%F(n,1),2) !          end do !          if (associated(Lev%tauQ)) then !             call Lev%encap%axpy(Lev%qend, 1.0_pfdp, Lev%tauQ(nnodes-1)) !             !          print *,'XXXXXXXXXXX  need code in verlet.f90' !          end if !       else !          call Lev%encap%copy(Lev%qend, Lev%Q(nnodes)) !       end if call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! end loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine verlet_sweep !----------------------------------------------------------------------------- !> Initialize integration matrices subroutine verlet_initialize ( this , lev ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev integer :: i , j , nnodes , ierr real ( pfdp ), allocatable :: qtemp (:,:) real ( pfdp ), allocatable :: qtemp2 (:,:) this % npieces = 1 nnodes = Lev % nnodes allocate ( this % Qmat ( nnodes - 1 , nnodes ), stat = ierr ) !  0  to node integral if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qmat\" allocate ( this % QQmat ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node double integral (like Qmat*Qmat) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQmat\" allocate ( this % Qtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0  to node integral  approximation of Qmat if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qtil\" allocate ( this % QQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node QQmat  aproximation if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQtil\" allocate ( this % Qver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node verlet  aproximation (trap) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qver\" allocate ( this % QQver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node verlet  aproximation if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQver\" allocate ( this % DQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node Qmat-Qtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQtil\" allocate ( this % DQQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  node to node QQmat-QQtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQQtil\" allocate ( this % DQver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node Qmat-Qtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQtil\" allocate ( this % DQQver ( nnodes - 1 , nnodes ), stat = ierr ) !  node to node QQmat-QQtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQQtil\" allocate ( this % bvec ( nnodes ), stat = ierr ) !  Integration rule for v if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DStil\" allocate ( this % bbarvec ( nnodes ), stat = ierr ) !  Integration rule for x if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DSStil\" allocate ( this % dtsdc ( nnodes - 1 ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for dtsdc\" allocate ( this % tsdc ( nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for tsdc\" !>  Array of substep sizes this % dtsdc = lev % sdcmats % qnodes ( 2 : nnodes ) - lev % sdcmats % qnodes ( 1 : nnodes - 1 ) this % tsdc = lev % sdcmats % qnodes - lev % sdcmats % qnodes ( 1 ) !  Build Q from qmat this % Qmat = lev % sdcmats % qmat !   I just use qmat now? !  The quadrature rule is the last row of Q this % bvec = this % Qmat ( nnodes - 1 ,:); allocate ( qtemp ( nnodes , nnodes ), stat = ierr ) allocate ( qtemp2 ( nnodes , nnodes ), stat = ierr ) !  form the QQ matrix depending on what you want select case ( this % whichQQ ) case ( 0 ) !  Collocation (make it the product) print * , 'Making QQ by collocation Q*Q' print * , size ( this % Qmat ) qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = lev % sdcmats % qmat qtemp = matmul ( qtemp , qtemp ) this % QQmat = qtemp ( 2 : nnodes ,:) print * , shape ( this % QQmat ) case ( 1 ) !  Make the pair like in Lobatto A/B pair print * , 'Making QQ by collocation Lobatto pair' qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = this % Qmat qtemp2 = 0.0_pfdp do i = 1 , nnodes do j = 1 , nnodes qtemp2 ( i , j ) = this % bvec ( j ) * ( 1.0_pfdp - qtemp ( j , i ) / this % bvec ( i )) end do end do qtemp2 = matmul ( qtemp , qtemp2 ) this % QQmat = 0.0_pfdp this % QQmat = qtemp2 ( 2 : nnodes ,:) this % bbarvec = this % QQmat ( nnodes - 1 ,:); case ( 2 ) !  Make the pair like in Lobatto B/A pair print * , 'Error Making QQ by collocation Lobatto pair' !!$       do i = 1,nnodes !!$          do j = 1,nnodes !!$             this%QQmat(i,j) =  this%bvec(j)*(1.0_pfdp-this%Qmat(j,i)/this%bvec(i)) !!$          end do !!$       end do !!$       this%QQmat = matmul(this%QQmat,this%Qmat) case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % whichQQ ) end select ! 0 to node this % Qver = lev % sdcmats % qmatTrap qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = lev % sdcmats % qmatFE qtemp2 ( 2 : nnodes ,:) = lev % sdcmats % qmatTrap qtemp = matmul ( qtemp , qtemp2 ) this % QQver = qtemp ( 2 : nnodes ,:) + 0.5_pfdp * lev % sdcmats % qmatFE * lev % sdcmats % qmatFE !  Get LU matrices if desired !    if (this%use_LUq .eq. 1) then !       print *,'Doing LU with doLU=',this%doLU !       call myLUq(SDCmats%qmat,SDCmats%qmatLU,nnodes,0) !       call pf_myLUexp(this%QQmat,L,U,nnodes,this%doLU) !      this%QQLU=U !      print *, 'U from LU',this%QQLU !   else this % Qtil = this % Qver !  Normal verlet all the time this % QQtil = this % QQver !  Normal verlet all the time !   end if this % Qver = 0.0d0 !  Normal verlet all the time this % QQver = 0.0d0 !  Normal verlet all the time this % Qtil = this % Qver !  Normal verlet all the time this % QQtil = this % QQver !  Normal verlet all the time ! !  Make differences this % DQtil = this % Qmat - this % Qtil this % DQQtil = this % QQmat - this % QQtil this % DQver = this % Qmat - this % Qver this % DQQver = this % QQmat - this % QQver deallocate ( qtemp ) deallocate ( qtemp2 ) !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine verlet_initialize !----------------------------------------------------------------------------- !> Integrate (t_n to node) subroutine verlet_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev !!  Current level class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags integer :: n , m do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) call fintSDC ( n )% axpy ( dt * this % tsdc ( n + 1 ), qSDC ( 1 ), 12 ) !  Add the dt*v_0 term do m = 1 , lev % nnodes call fintSDC ( n )% axpy ( dt * this % Qmat ( n , m ), fSDC ( m , 1 ), 1 ) call fintSDC ( n )% axpy ( dt * dt * this % QQmat ( n , m ), fSDC ( m , 1 ), 2 ) end do end do end subroutine verlet_integrate !----------------------------------------------------------------------------- !> Compute residual (t_n to node) subroutine verlet_residual ( this , lev , dt , flags ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags integer :: n , m call this % integrate ( lev , lev % Q , lev % F , dt , lev % I , flags ) ! add tau if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end subroutine verlet_residual !----------------------------------------------------------------------------- ! Integrate to fill qend ! !  subroutine verlet_qend_integrate(Lev, dt) !    type(pf_level_t), intent(in) :: Lev !    real(pfdp),       intent(in) :: dt ! ! !    real(pfdp) :: dtsdc(1:Lev%nnodes-1) !    integer :: nnodes, m !    type(pf_verlet_t), pointer :: verlet !    call c_f_pointer(Lev%sweeper%sweeperctx, verlet) ! !    nnodes = Lev%nnodes ! !    dtsdc = dt * (Lev%nodes(2:Lev%nnodes) - Lev%nodes(1:Lev%nnodes-1)) !    call Lev%encap%copy(Lev%qend, Lev%Q(1)) !    call Lev%encap%axpy(Lev%qend, dt, Lev%Q(1), 12)  !  Add the dt*v_0 term !    do m = 1, Lev%nnodes !       call Lev%encap%axpy(Lev%qend, dt*Lev%qmat(nnodes,m), Lev%F(m,1),1) !       call Lev%encap%axpy(Lev%qend, dt*dt*thisSSmat(nnodes,m), Lev%F(m,1),2) !    end do !  end subroutine verlet_qend_integrate !----------------------------------------------------------------------------- !> Destroy Verlet sweeper matrices subroutine verlet_destroy ( this , lev ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level deallocate ( this % Qmat ) deallocate ( this % QQmat ) deallocate ( this % Qtil ) deallocate ( this % QQtil ) deallocate ( this % Qver ) deallocate ( this % QQver ) deallocate ( this % DQtil ) deallocate ( this % DQQtil ) deallocate ( this % DQver ) deallocate ( this % DQQver ) deallocate ( this % bvec ) deallocate ( this % bbarvec ) deallocate ( this % dtsdc ) deallocate ( this % tsdc ) call lev % ulevel % factory % destroy_single ( this % rhs , lev % index , lev % shape ) end subroutine verlet_destroy !> Spread the intial data for Verlet sweepers subroutine verlet_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine verlet_spreadq0 !> Subroutine to evaluate function value at node m subroutine verlet_evaluate ( this , lev , t , m , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine verlet_evaluate !> Subroutine to evaluate the function values at all nodes subroutine verlet_evaluate_all ( this , lev , t , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine verlet_evaluate_all end module pf_mod_verlet","tags":"","loc":"sourcefile/pf_verlet.f90.html","title":"pf_verlet.f90 – LibPFASST"},{"text":"Old style Asynchronous MISDC sweeper This file depends on sourcefile~~pf_amisdc.f90~~EfferentGraph sourcefile~pf_amisdc.f90 pf_amisdc.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_amisdc.f90~~AfferentGraph sourcefile~pf_amisdc.f90 pf_amisdc.f90 sourcefile~pf_amisdcq.f90 pf_amisdcQ.f90 sourcefile~pf_amisdcq.f90->sourcefile~pf_amisdc.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_amisdc Source Code pf_amisdc.f90 Source Code !! Old style Asynchronous MISDC sweeper ! ! This file is part of LIBPFASST. ! !> Old style Asynchronous MISDC sweeper module pf_mod_amisdc use pf_mod_dtype use pf_mod_utils implicit none !>  Asynchronous multi-implicit sweeper type (old style) type , extends ( pf_sweeper_t ), abstract :: pf_amisdc_t real ( pfdp ), allocatable :: SdiffE (:,:) real ( pfdp ), allocatable :: SdiffI (:,:) contains procedure ( pf_f1eval_p ), deferred :: f1eval procedure ( pf_f2eval_p ), deferred :: f2eval procedure ( pf_f2comp_p ), deferred :: f2comp procedure ( pf_f3eval_p ), deferred :: f3eval procedure ( pf_f3comp_p ), deferred :: f3comp procedure :: sweep => amisdc_sweep procedure :: initialize => amisdc_initialize procedure :: evaluate => amisdc_evaluate procedure :: integrate => amisdc_integrate procedure :: residual => amisdc_residual procedure :: evaluate_all => amisdc_evaluate_all procedure :: destroy => amisdc_destroy procedure :: amisdc_destroy end type pf_amisdc_t interface subroutine pf_f1eval_p ( this , y , t , level , f1 ) import pf_amisdc_t , pf_encap_t , pfdp class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y class ( pf_encap_t ), intent ( inout ) :: f1 real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level end subroutine pf_f1eval_p subroutine pf_f2eval_p ( this , y , t , level , f2 ) import pf_amisdc_t , pf_encap_t , pfdp class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y class ( pf_encap_t ), intent ( inout ) :: f2 real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level end subroutine pf_f2eval_p subroutine pf_f2comp_p ( this , y , t , dt , rhs , level , f2 ) import pf_amisdc_t , pf_encap_t , pfdp class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: rhs class ( pf_encap_t ), intent ( inout ) :: y , f2 real ( pfdp ), intent ( in ) :: t , dt integer , intent ( in ) :: level end subroutine pf_f2comp_p subroutine pf_f3eval_p ( this , y , t , level , f3 ) import pf_amisdc_t , pf_encap_t , pfdp class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y class ( pf_encap_t ), intent ( inout ) :: f3 real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level end subroutine pf_f3eval_p subroutine pf_f3comp_p ( this , y , t , dt , rhs , level , f3 ) import pf_amisdc_t , pf_encap_t , pfdp class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: rhs class ( pf_encap_t ), intent ( inout ) :: y , f3 real ( pfdp ), intent ( in ) :: t , dt integer , intent ( in ) :: level end subroutine pf_f3comp_p end interface contains ! Perform on SDC sweep on level lev and set qend appropriately. subroutine amisdc_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: rhsA , rhsB , QA , QB call start_timer ( pf , TLEVEL + lev % index - 1 ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % SdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tau )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tau ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call this % f1eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) call this % f2eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 )) call this % f3eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 )) call lev % ulevel % factory % create_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QB , lev % index , lev % shape ) call QA % setval ( 0.0_pfdp ) call QB % setval ( 0.0_pfdp ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) ! First compute the explicit part of the right-hand side call rhsA % copy ( lev % Q ( m )) call rhsA % axpy ( dtsdc ( m ), lev % F ( m , 1 )) call rhsA % axpy ( 1.0_pfdp , lev % S ( m )) ! Save the right-hand side with only the explicit contribution call rhsB % copy ( rhsA ) ! Add the first implicit part to the right-hand side and solve for the first asynchronous update call rhsA % axpy ( - 2.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 2 )) call this % f2comp ( QA , t , 2.0_pfdp * dtsdc ( m ), rhsA , lev % index , lev % F ( m + 1 , 2 )) ! Add the second implicit part to the right-hand side and solve for the second asynchronous update call rhsB % axpy ( - 2.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 3 )) call this % f3comp ( QB , t , 2.0_pfdp * dtsdc ( m ), rhsB , lev % index , lev % F ( m + 1 , 3 )) ! Now we average the two asynchronous updates call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QA ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QB ) ! Evaluate the three right-hand sides with the updated variables call this % f1eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 )) call this % f2eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 )) call this % f3eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 3 )) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) ! Destroy the temporary variables call lev % ulevel % factory % destroy_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QB , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine amisdc_sweep ! Evaluate function values subroutine amisdc_evaluate ( this , lev , t , m ) use pf_mod_dtype class ( pf_amisdc_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev call this % f1eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) call this % f2eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 )) call this % f3eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 )) end subroutine amisdc_evaluate ! Initialize matrices subroutine amisdc_initialize ( this , lev ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % SdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % SdiffI ( nnodes - 1 , nnodes )) !  S-BE this % SdiffE = lev % s0mat this % SdiffI = lev % s0mat dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) do m = 1 , nnodes - 1 this % SdiffE ( m , m ) = this % SdiffE ( m , m ) - dsdc ( m ) this % SdiffI ( m , m + 1 ) = this % SdiffI ( m , m + 1 ) - dsdc ( m ) end do end subroutine amisdc_initialize ! Destroy the matrices subroutine amisdc_destroy ( this , lev ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % SdiffE ) deallocate ( this % SdiffI ) end subroutine amisdc_destroy ! Compute SDC integral subroutine amisdc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % s0mat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine amisdc_integrate subroutine amisdc_residual ( this , lev , dt ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt call pf_generic_residual ( this , lev , dt ) end subroutine amisdc_residual subroutine amisdc_evaluate_all ( this , lev , t ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) call pf_generic_evaluate_all ( this , lev , t ) end subroutine amisdc_evaluate_all end module pf_mod_amisdc","tags":"","loc":"sourcefile/pf_amisdc.f90.html","title":"pf_amisdc.f90 – LibPFASST"},{"text":"IMEX sweeper for optimal control problems This file depends on sourcefile~~pf_imexq_oc.f90~~EfferentGraph sourcefile~pf_imexq_oc.f90 pf_imexQ_oc.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_imexQ_oc Source Code pf_imexQ_oc.f90 Source Code !!  IMEX sweeper for optimal control problems ! ! This file is part of LIBPFASST_OC. ! !>  Module to do imex SDC sweeps in the optimal control setting module pf_mod_imexQ_oc use pf_mod_dtype use pf_mod_utils implicit none !>  IMEX SDC sweeper type for optimal control, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_imexQ_oc_t real ( pfdp ), allocatable :: QtilE (:,:) !!  Approximate explcit quadrature rule real ( pfdp ), allocatable :: QtilI (:,:) !!  Approximate implcit quadrature rule real ( pfdp ), allocatable :: dtsdc (:) !!  SDC step sizes real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ), allocatable :: QdiffI (:,:) !!  qmat-QtilI logical :: explicit = . true . !!  Is there an explicit piece logical :: implicit = . true . !!  Is there an implicit piece class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver !>  Set the generic functions procedure :: sweep => imexQ_oc_sweep procedure :: initialize => imexQ_oc_initialize procedure :: evaluate => imexQ_oc_evaluate procedure :: integrate => imexQ_oc_integrate procedure :: residual => imexQ_oc_residual procedure :: evaluate_all => imexQ_oc_evaluate_all procedure :: spreadq0 => imexQ_oc_spreadq0 procedure :: destroy => imexQ_oc_destroy procedure :: imexQ_oc_destroy end type pf_imexQ_oc_t interface !!  This is the interface for the routine to compute the RHS function values subroutine pf_f_eval_p ( this , y , t , level_index , f , piece , flags , idx , step ) !!  Evaluae f_piece(y), where piece is one or two import pf_imexQ_oc_t , pf_encap_t , pfdp class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y !!  Argument for evaluation real ( pfdp ), intent ( in ) :: t !!  Time at evaluation integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  RHS function value integer , intent ( in ) :: piece !!  Which piece to evaluate integer , intent ( in ) :: flags integer , intent ( in ), optional :: idx ! index of quadrature node integer , intent ( in ), optional :: step ! time step for sequential version end subroutine pf_f_eval_p subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece , flags ) !!  Solve the equation y - dtq*f_2(y) =rhs import pf_imexQ_oc_t , pf_encap_t , pfdp class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Solution of implicit solve real ( pfdp ), intent ( in ) :: t !!  Time of solve real ( pfdp ), intent ( in ) :: dtq !!  dt*quadrature weight class ( pf_encap_t ), intent ( in ) :: rhs !!  RHS for solve integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  f_2 of solution y integer , intent ( in ) :: piece !!  Which piece to evaluate integer , intent ( in ) :: flags end subroutine pf_f_comp_p end interface contains ! Perform on SDC sweep on level Lev and set qend appropriately. subroutine imexQ_oc_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: level_index !!  which level this is integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags class ( pf_level_t ), pointer :: lev !!  points to current level ! indicate if sweep on both (0, default; might skip y or p if tolerance satisfied), just y (1), just p (2) integer :: k , m , n , Nnodes , which real ( pfdp ) :: t , tend logical :: sweep_y , sweep_p real ( pfdp ), allocatable :: norms_y (:) !, norms_p(Lev%nnodes-1) integer :: step lev => pf % levels ( level_index ) !!  Assign level pointer step = pf % state % step + 1 !     print *, 'sweep on step', step which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SWEEPER WITHOUT FLAGS\" !     print *, \"IMEXQ_OC SWEEP\", which Nnodes = lev % nnodes tend = t0 + dt call start_timer ( pf , TLEVEL + lev % index - 1 ) if ( which . eq . 1 ) then sweep_y = . true . sweep_p = . false . else if ( which . eq . 2 ) then sweep_y = . false . sweep_p = . true . else sweep_y = . true . sweep_p = . true . allocate ( norms_y ( lev % nnodes - 1 )) do m = 1 , Nnodes - 1 norms_y ( m ) = lev % R ( m )% norm ( 1 ) end do if ( maxval ( abs ( norms_y )) < pf % abs_res_tol ) then sweep_y = . false . if ( level_index == pf % nlevels ) pf % state % skippedy = pf % state % skippedy + 1 end if deallocate ( norms_y ) !if ( maxval(abs(norms_p)) < pf%abs_res_tol ) sweep_p = .false. end if !     if( sweep_p .and. pf%rank == 0)  print *, \"sweep on p with which = \", which do k = 1 , nsweeps !!  Loop over sweeps call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals from previous iteration and add fas correction !     do m = 1, Nnodes-1 !        call Lev%encap%setval(Lev%S(m), 0.0_pfdp, 1) !        call Lev%encap%setval(Lev%S(m), 0.0_pfdp, 2) if ( sweep_y ) then do m = 1 , Nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp , 1 ) !  Forward in y if ( this % explicit ) then do n = 1 , Nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 ), 1 ) !                 call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(m,n), Lev%F(n,1),1) end do end if if ( this % implicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 ), 1 ) !                 call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(m,n), Lev%F(n,2),1) end do end if if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 1 ) !              call Lev%encap%axpy(Lev%S(m), 1.0_pfdp, Lev%tauQ(m),1) end if end do end if if ( sweep_p ) then do m = Nnodes - 1 , 1 , - 1 call lev % I ( m )% setval ( 0.0_pfdp , 2 ) !  Backward in p, note S(m) goes backward now !2          do n =  1,Nnodes !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffE(m,n), Lev%F(Nnodes+1-n,1),2) !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffI(m,n), Lev%F(Nnodes+1-n,2),2) !2          end do if ( this % explicit ) then do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffE ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 1 ), 2 ) !call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(Nnodes-m,Nnodes+1-n), Lev%F(n,1),2) end do end if if ( this % implicit ) then do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 2 ), 2 ) !               call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(Nnodes-m,Nnodes+1-n), Lev%F(n,2),2) end do end if if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 2 ) end if end do end if ! Reload the newest initial values ! Recompute first function values if ( sweep_y ) then if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 , 1 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 , 1 , 1 , step ) if ( this % implicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 , 1 , 1 , step ) end if !        call Lev%encap%copy(Lev%Q(1), Lev%q0, 1) !        call imexQ_oc%f1eval(Lev%Q(1), t0, Lev%level, Lev%ctx, Lev%F(1,1), 1, 1, step) !        call imexQ_oc%f2eval(Lev%Q(1), t0, Lev%level, Lev%ctx, Lev%F(1,2), 1) end if !else !     if( sweep_p ) then !       if (k .eq. 1) then !         call lev%Q(Nnodes)%copy(lev%qend, 2) !         if (this%explicit) & !           call this%f_eval(lev%Q(Nnodes), tend, lev%index, lev%F(Nnodes,1), 1, 2, Nnodes, step) !         if (this%implicit) & !           call this%f_eval(lev%Q(Nnodes), tend, lev%index, lev%F(Nnodes,2), 2, 2, Nnodes, step) !       end if ! !        call Lev%encap%copy(Lev%Q(Nnodes), Lev%qend, 2) ! !        call imexQ_oc%f1eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,1), 2, Nnodes, step) ! !        call imexQ_oc%f2eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,2), 2) !     end if !     if (sweep_p) then !    !  Backward  sweep on p !       t = tend !       do m =  Nnodes-1,1,-1 !          t = t - dt*this%dtsdc(m) ! !          ! Do the dirk parts !          call this%rhs%setval(0.0_pfdp, 2) !          do n = Nnodes, m+1,-1 !             if (this%explicit) & !               call this%rhs%axpy(dt*this%QtilE(Nnodes-m,Nnodes-n+1), lev%F(n,1), 2) !             if (this%implicit) & !               call this%rhs%axpy(dt*this%QtilI(Nnodes-m,Nnodes-n+1), lev%F(n,2), 2) !          end do ! !          call this%rhs%axpy(1.0_pfdp, lev%I(m), 2) !          call this%rhs%axpy(1.0_pfdp, lev%Q(Nnodes), 2) ! !          !  Do implicit solve !          if (this%implicit) then !            call this%f_comp(lev%Q(m), t, dt*this%QtilI(Nnodes-m,Nnodes-m+1), this%rhs, lev%index, lev%F(m,2), 2, 2) !          else !             call lev%Q(m)%copy(this%rhs,2) !          end if !          if (this%explicit) & !            call this%f_eval(lev%Q(m), t, lev%index, lev%F(m,1), 1, 2, m, step) !       end do !       ! reset first value !       call lev%q0%copy(lev%Q(1), 2) !       call pf_residual(pf, lev, dt, 2) ! !       call pf_residual(pf, lev, dt, which) !     end if !  Make some space !     call Lev%encap%create(rhs, Lev%level, SDC_KIND_SOL_FEVAL, Lev%nvars, Lev%shape, Lev%ctx) if ( sweep_y ) then !  Forward sweep on y t = t0 do m = 1 , Nnodes - 1 t = t + dt * this % dtsdc ( m ) !  forward running time !  Form rhs with all explicit terms call this % rhs % setval ( 0.0_pfdp , 1 ) do n = 1 , m if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 ), 1 ) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 ), 1 ) end do call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 1 ) call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) ! Do implicit solve if ( this % implicit ) then call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 ) else call lev % Q ( m + 1 )% copy ( this % rhs , 1 ) end if !  Compute explicit piece on new value if ( this % explicit ) & call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 , 1 , m + 1 , step ) end do !  Reset last values call lev % qend % copy ( lev % Q ( Nnodes ), 1 ) !       call pf_residual(pf, lev, dt, 1) !       call pf_residual(pf, lev, dt, which) end if if ( sweep_p ) then !        do m=1, Nnodes-1 !           call lev%I(m)%setval(0.0_pfdp, 2) ! !           !  Backward in p, note S(m) goes backward now ! !2          do n =  1,Nnodes ! !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffE(m,n), Lev%F(Nnodes+1-n,1),2) ! !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffI(m,n), Lev%F(Nnodes+1-n,2),2) ! !2          end do !           if (this%explicit) then !             do n =  Nnodes,1,-1 !               call lev%I(m)%axpy(dt*this%QdiffE(Nnodes-m,Nnodes+1-n), lev%F(n,1), 2) !               !call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(Nnodes-m,Nnodes+1-n), Lev%F(n,1),2) !             end do !           end if !           if (this%implicit) then !             do n =  Nnodes,1,-1 !               call lev%I(m)%axpy(dt*this%QdiffI(Nnodes-m,Nnodes+1-n), lev%F(n,2), 2) ! !               call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(Nnodes-m,Nnodes+1-n), Lev%F(n,2),2) !             end do !           end if !           if (allocated(lev%tauQ)) then !              call lev%I(m)%axpy(1.0_pfdp, lev%tauQ(m), 2) !           end if !       end do if ( k . eq . 1 ) then call lev % Q ( Nnodes )% copy ( lev % qend , 2 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 1 ), 1 , 2 , Nnodes , step ) if ( this % implicit ) & call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 2 ), 2 , 2 , Nnodes , step ) end if !        call Lev%encap%copy(Lev%Q(Nnodes), Lev%qend, 2) !        call imexQ_oc%f1eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,1), 2, Nnodes, step) !        call imexQ_oc%f2eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,2), 2) end if if ( sweep_p ) then !  Backward  sweep on p t = tend do m = Nnodes - 1 , 1 , - 1 t = t - dt * this % dtsdc ( m ) ! Do the dirk parts call this % rhs % setval ( 0.0_pfdp , 2 ) do n = Nnodes , m + 1 , - 1 if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 1 ), 2 ) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 2 ), 2 ) end do call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) call this % rhs % axpy ( 1.0_pfdp , lev % Q ( Nnodes ), 2 ) !  Do implicit solve if ( this % implicit ) then call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 2 ), 2 , 2 ) else call lev % Q ( m )% copy ( this % rhs , 2 ) end if if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , 2 , m , step ) end do ! reset first value call lev % q0 % copy ( lev % Q ( 1 ), 2 ) !       call pf_residual(pf, lev, dt, 2) end if !     if(sweep_p) & !       call this%evaluate_all(lev, t0 + dt*lev%nodes, 2, step) !     if( sweep_p .and. sweep_y ) then !       call pf_residual(pf, lev, dt, 0) !     else if( sweep_y ) then !       call pf_residual(pf, lev, dt, 1) !     else if (sweep_p ) then !       call pf_residual(pf, lev, dt, 2) !     else !       stop \"neither sweep on p nor on y : that should not happen\" !     end if call pf_residual ( pf , lev , dt , which ) ! done call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !nsweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imexQ_oc_sweep ! Evaluate function values subroutine imexQ_oc_evaluate ( this , lev , t , m , flags , step ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , intent ( in ), optional :: flags , step integer :: which , mystep which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC EVAL WITHOUT FLAGS\" mystep = 1 if ( present ( step )) then mystep = step else print * , \"step not present in evaluate\" , which stop end if !     print *, \"IMEXQ_OC EVAL \", which if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , which , m , mystep ) if ( this % implicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , which , m , mystep ) end subroutine imexQ_oc_evaluate subroutine imexQ_oc_evaluate_all ( this , lev , t , flags , step ) !! Evaluate all function values class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , intent ( in ), optional :: flags , step !     call pf_generic_evaluate_all(this, lev, t, flags, step) integer :: m if (. not . present ( flags )) stop \"IMEXQ_OC EVAL_ALL WITHOUT FLAGS\" if (. not . present ( step )) stop \"IMEXQ_OC EVAL_ALL WITHOUT step\" do m = 1 , lev % nnodes call this % evaluate ( lev , t ( m ), m , flags , step ) end do end subroutine imexQ_oc_evaluate_all ! Initialize matrices subroutine imexQ_oc_initialize ( this , lev ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev integer :: Nnodes this % npieces = 2 Nnodes = lev % nnodes allocate ( this % QdiffE ( Nnodes - 1 , Nnodes )) !  S-FE allocate ( this % QdiffI ( Nnodes - 1 , Nnodes )) !  S-BE allocate ( this % QtilE ( Nnodes - 1 , Nnodes )) !  S-FE allocate ( this % QtilI ( Nnodes - 1 , Nnodes )) !  S-BE this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp this % dtsdc = lev % nodes ( 2 : Nnodes ) - lev % nodes ( 1 : Nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !!  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine imexQ_oc_initialize ! Compute SDC integral subroutine imexQ_oc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) !qSDC unused? real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , intent ( in ), optional :: flags integer :: n , m , Nnodes , which Nnodes = lev % nnodes which = 0 if ( present ( flags )) then which = flags else print * , \"flags not present in integrate\" , which stop end if !     print *, \"IMEXQ_OC INTEGRATE \", which do n = 1 , Nnodes - 1 !  Forward in y if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call fintSDC ( n )% setval ( 0.0_pfdp , 1 ) do m = 1 , Nnodes !               do p = 1, npieces !                 call Lev%encap%axpy(fintSDC(n), dt*Lev%sdcmats%qmat(n,m), fSDC(m,p),1) !               end do if ( this % explicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 1 ), 1 ) if ( this % implicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 2 ), 1 ) end do end if !  Backward in p if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call fintSDC ( Nnodes - n )% setval ( 0.0_pfdp , 2 ) do m = 1 , Nnodes !               do p = 1, npieces !                 call Lev%encap%axpy(fintSDC(Nnodes-n), dt*Lev%sdcmats%qmat(n,m), fSDC(Nnodes+1-m,p),2) !               end do if ( this % explicit ) & call fintSDC ( Nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( Nnodes + 1 - m , 1 ), 2 ) if ( this % implicit ) & call fintSDC ( Nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( Nnodes + 1 - m , 2 ), 2 ) end do end if end do end subroutine imexQ_oc_integrate subroutine imexQ_oc_residual ( this , lev , dt , flags ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , intent ( in ), optional :: flags integer :: m , which which = 0 if ( present ( flags )) then which = flags else print * , \"flags not present in residual\" , which stop end if !     print *, \"IMEXQ_OC RESIDUAL \", which call this % integrate ( lev , lev % Q , lev % F , dt , lev % I , which ) ! add tau (which is 'node to node') if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), which ) end do end if ! subtract out Q do m = 1 , lev % nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 1 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 ), 1 ) end if if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 2 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( lev % nnodes ), 2 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m ), 2 ) end if end do end subroutine imexQ_oc_residual subroutine imexQ_oc_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer :: m , p , which , mystep which = 3 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SPREADQ0 WITHOUT FLAGS\" !     print *, \"IMEXQ_OC SPREADQ0\", which mystep = 1 if ( present ( step )) then mystep = step !needed for sequential version else print * , \"step not present in spreadq0\" , which stop end if select case ( which ) case ( 1 ) !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , 1 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , 1 , 1 , mystep ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), 1 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p ), 1 ) end do end do case ( 2 ) !  Stick terminal condition into last node slot call lev % Q ( lev % nnodes )% copy ( lev % qend , 2 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , lev % nnodes , 2 , mystep ) ! Spread F and solution to all nodes do m = lev % nnodes - 1 , 1 , - 1 call lev % Q ( m )% copy ( lev % Q ( lev % nnodes ), 2 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( lev % nnodes , p ), 2 ) end do end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine imexQ_oc_spreadq0 subroutine imexQ_oc_destroy ( this , lev ) !!  deallocate class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_single ( this % rhs , lev % index , lev % shape ) end subroutine imexQ_oc_destroy end module pf_mod_imexQ_oc","tags":"","loc":"sourcefile/pf_imexq_oc.f90.html","title":"pf_imexQ_oc.f90 – LibPFASST"},{"text":"N-dimensional array encapsulation for optimal control problems. This file depends on sourcefile~~pf_ndarray-oc.f90~~EfferentGraph sourcefile~pf_ndarray-oc.f90 pf_ndarray-oc.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_ndarray-oc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_ndarray-oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_ndarray_oc Source Code pf_ndarray-oc.f90 Source Code !! N-dimensional array encapsulation for optimal control problems. ! ! This file is part of LIBPFASST. ! !! !> When a new solution is created by a PFASST level, this encapsulation !! uses the levels 'shape' attribute to create a new array with that !! shape.  Thus, the 'shape' attributes of the PFASST levels should be !! set appropriately.  For example, before calling pf_pfasst_run we can !! set the shape of the coarsest level by doing: !! !!   allocate(pf%levels(1)%shape(2)) !!   pf%levels(1)%shape = [ 3, 10 ] !! !! The helper routines array1, array2, array3, etc can be used to !! extract pointers to the encapsulated array from a C pointer without !! performing any copies. module pf_mod_ndarray_oc use iso_c_binding use pf_mod_dtype use pf_mod_utils implicit none !>  Type to create and destroy N-dimenstional arrays for optimal control type , extends ( pf_factory_t ) :: ndarray_oc_factory contains procedure :: create_single => ndarray_oc_create_single procedure :: create_array => ndarray_oc_create_array procedure :: destroy_single => ndarray_oc_destroy_single procedure :: destroy_array => ndarray_oc_destroy_array end type ndarray_oc_factory !>  N-dimensional array type for optimal control,  extends the abstract encap type type , extends ( pf_encap_t ) :: ndarray_oc integer :: dim integer , allocatable :: shape (:) real ( pfdp ), allocatable :: yflatarray (:) real ( pfdp ), allocatable :: pflatarray (:) contains procedure :: setval => ndarray_oc_setval procedure :: copy => ndarray_oc_copy procedure :: norm => ndarray_oc_norm procedure :: pack => ndarray_oc_pack procedure :: unpack => ndarray_oc_unpack procedure :: axpy => ndarray_oc_axpy procedure :: eprint => ndarray_oc_eprint end type ndarray_oc ! interfaces to routines in pf_numpy.c interface subroutine ndarray_mkdir ( dname , dlen ) bind ( c ) use pf_mod_dtype use iso_c_binding character ( c_char ), intent ( in ) :: dname integer ( c_int ), intent ( in ), value :: dlen end subroutine ndarray_mkdir subroutine ndarray_dump_numpy ( dname , fname , endian , dim , shape , nvars , array ) bind ( c ) use iso_c_binding use pf_mod_dtype character ( c_char ), intent ( in ) :: dname , fname , endian ( 5 ) integer ( c_int ), intent ( in ), value :: dim , nvars integer ( c_int ), intent ( in ) :: shape ( dim ) real ( pfdp ), intent ( in ) :: array ( nvars ) end subroutine ndarray_dump_numpy end interface contains !>  Subroutine to allocate the array and set the size parameters subroutine ndarray_oc_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) select type ( q ) class is ( ndarray_oc ) allocate ( q % shape ( size ( shape ))) allocate ( q % yflatarray ( product ( shape ))) allocate ( q % pflatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_build !> Subroutine to  create a single array subroutine ndarray_oc_create_single ( this , x , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( ndarray_oc :: x ) call ndarray_oc_build ( x , shape ) end subroutine ndarray_oc_create_single !> Subroutine to create an array of arrays subroutine ndarray_oc_create_array ( this , x , n , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndarray_oc :: x ( n )) do i = 1 , n call ndarray_oc_build ( x ( i ), shape ) end do end subroutine ndarray_oc_create_array !>  Subroutine to destroy array subroutine ndarray_oc_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndarray_oc ), pointer :: ndarray_oc_obj ndarray_oc_obj => cast_as_ndarray_oc ( encap ) !?? deallocate ( ndarray_oc_obj % pflatarray ) deallocate ( ndarray_oc_obj % yflatarray ) deallocate ( ndarray_oc_obj % shape ) nullify ( ndarray_oc_obj ) end subroutine ndarray_oc_destroy !> Subroutine to destroy an single array subroutine ndarray_oc_destroy_single ( this , x , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) select type ( x ) class is ( ndarray_oc ) deallocate ( x % pflatarray ) deallocate ( x % yflatarray ) deallocate ( x % shape ) class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select deallocate ( x ) end subroutine ndarray_oc_destroy_single !> Subroutine to destroy an array of arrays subroutine ndarray_oc_destroy_array ( this , x , n , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i select type ( x ) class is ( ndarray_oc ) do i = 1 , n deallocate ( x ( i )% pflatarray ) deallocate ( x ( i )% yflatarray ) deallocate ( x ( i )% shape ) end do class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select deallocate ( x ) end subroutine ndarray_oc_destroy_array !> Subroutine to set array to a scalar  value. subroutine ndarray_oc_setval ( this , val , flags ) class ( ndarray_oc ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"setval without flags\" select case ( which ) case ( 0 ) this % yflatarray = val this % pflatarray = val case ( 1 ) this % yflatarray = val case ( 2 ) this % pflatarray = val case default call pf_stop ( __ FILE__ , __ LINE__ , 'Select case error' , which ) end select end subroutine ndarray_oc_setval !> Subroutine to copy an array subroutine ndarray_oc_copy ( this , src , flags ) class ( ndarray_oc ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"copy without flags\" select type ( src ) type is ( ndarray_oc ) select case ( which ) case ( 0 ) this % yflatarray = src % yflatarray this % pflatarray = src % pflatarray case ( 1 ) this % yflatarray = src % yflatarray case ( 2 ) this % pflatarray = src % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_copy !> Subroutine to pack an array into a flat array for sending subroutine ndarray_oc_pack ( this , z , flags ) class ( ndarray_oc ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags select case ( which ) case ( 0 ) !z = [sol%yflatarray, sol%pflatarray] !z has to be right size? initialized to nvars, so it can hold either y or p !is it ever needed to pack y and p simultaneously? stop \"ERROR in ndarray_oc_pack: only 1, 2 allowed as flags\" case ( 1 ) z = this % yflatarray case ( 2 ) z = this % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine ndarray_oc_pack !> Subroutine to unpack a flatarray after receiving subroutine ndarray_oc_unpack ( this , z , flags ) class ( ndarray_oc ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags select case ( which ) case ( 0 ) stop \"ERROR in ndarray_oc_unpack: only 1, 2 allowed as flags\" case ( 1 ) this % yflatarray = z case ( 2 ) this % pflatarray = z case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine ndarray_oc_unpack !> Subroutine to define the norm of the array (here the max norm) function ndarray_oc_norm ( this , flags ) result ( norm ) class ( ndarray_oc ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm integer :: which which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) print * , \"norm without flags\" select case ( which ) case ( 0 ) norm = max ( maxval ( abs ( this % yflatarray )), maxval ( abs ( this % pflatarray ))) case ( 1 ) norm = maxval ( abs ( this % yflatarray )) case ( 2 ) norm = maxval ( abs ( this % pflatarray )) case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end function ndarray_oc_norm !> Subroutine to compute y = a x + y where a is a scalar and x and y are arrays subroutine ndarray_oc_axpy ( this , a , x , flags ) class ( ndarray_oc ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if (.not.present(flags)) stop \"axpy without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 0 ) this % yflatarray = a * x % yflatarray + this % yflatarray this % pflatarray = a * x % pflatarray + this % pflatarray case ( 1 ) this % yflatarray = a * x % yflatarray + this % yflatarray case ( 2 ) this % pflatarray = a * x % pflatarray + this % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_axpy ! Helpers !   function dims(solptr) result(r) !     type(c_ptr), intent(in   ), value :: solptr !     integer :: r ! !     type(ndarray_oc), pointer :: sol !     call c_f_pointer(solptr, sol) ! !     r = sol%dim !   end function dims function cast_as_ndarray_oc ( encap_polymorph ) result ( ndarray_oc_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndarray_oc ), pointer :: ndarray_oc_obj select type ( encap_polymorph ) type is ( ndarray_oc ) ndarray_oc_obj => encap_polymorph class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function cast_as_ndarray_oc function get_array1d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"array1d_oc without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r => x % yflatarray case ( 2 ) r => x % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array1d_oc function get_array2d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"array2d_oc without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % yflatarray case ( 2 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % pflatarray case default stop \"ERROR in get_array1d_oc: only 1, 2 allowed as flags\" end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array2d_oc function get_array3d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) integer :: which which = 0 if ( present ( flags )) which = flags select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % yflatarray case ( 2 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % pflatarray case default stop \"ERROR in get_array1d_oc: only 1, 2 allowed as flags\" end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array3d_oc subroutine ndarray_oc_dump_hook ( pf , lev , state ) type ( pf_pfasst_t ), intent ( inout ) :: pf type ( pf_level_t ), intent ( inout ) :: lev type ( pf_state_t ), intent ( in ) :: state character ( len = 256 ) :: fnamey , fnamep type ( ndarray_oc ), pointer :: qend qend => cast_as_ndarray_oc ( lev % qend ) write ( fnamey , \"('y_s',i0.2,'i',i0.3,'l',i0.2,'.npy')\" ) & state % step , state % iter , lev % index call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamey ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % yflatarray ), qend % yflatarray ) write ( fnamep , \"('p_s',i0.2,'i',i0.3,'l',i0.2,'.npy')\" ) & state % step , state % iter , lev % index call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamep ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % pflatarray ), qend % pflatarray ) end subroutine ndarray_oc_dump_hook subroutine ndarray_oc_dump_all_hook ( pf , lev , state ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: lev type ( pf_state_t ), intent ( in ) :: state character ( len = 256 ) :: fnamey , fnamep integer :: m type ( ndarray_oc ), pointer :: qend do m = 1 , lev % nnodes qend => cast_as_ndarray_oc ( lev % Q ( m )) write ( fnamey , \"('y_s',i0.2,'l',i0.2,'m',i0.2,'.npy')\" ) & state % step , lev % index , m call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamey ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % yflatarray ), qend % yflatarray ) write ( fnamep , \"('p_s',i0.2,'l',i0.2,'m',i0.2,'.npy')\" ) & state % step , lev % index , m call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamep ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % pflatarray ), qend % pflatarray ) end do end subroutine ndarray_oc_dump_all_hook !>  Subroutine to print the array to the screen (mainly for debugging purposes) subroutine ndarray_oc_eprint ( this , flags ) class ( ndarray_oc ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % yflatarray ( 1 : 10 ) print * , this % pflatarray ( 1 : 10 ) end subroutine ndarray_oc_eprint !   function array2_oc(solptr, flags) result(r) !     type(c_ptr), intent(in   ), value :: solptr !     integer,     intent(in   ), optional :: flags !     real(pfdp), pointer :: r(:,:) ! !     integer                :: shp(2) !     integer                :: which !     type(ndarray_oc), pointer :: sol !     call c_f_pointer(solptr, sol) ! !     if (sol%dim == 2) then !        shp = sol%shape ! !        which = 0 !        if (present(flags)) which = flags ! !        select case (which) !        case (0) !           stop \"ERROR in array2_oc: only 1, 2 allowed as flags\" !        case (1) !           call c_f_pointer(sol%yptr, r, shp) !        case (2) !           call c_f_pointer(sol%pptr, r, shp) !        case default !           stop \"ERROR in array2_oc: only 1, 2 allowed as flags\" !        end select !     else !        stop \"ERROR: array2 dimension mismatch.\" !     end if !   end function array2_oc ! !   function array3_oc(solptr, flags) result(r) !     type(c_ptr), intent(in   ), value :: solptr !     integer,     intent(in   ), optional :: flags !     real(pfdp), pointer :: r(:,:,:) ! !     integer                :: shp(3) !     integer                :: which !     type(ndarray_oc), pointer :: sol !     call c_f_pointer(solptr, sol) ! !     if (sol%dim == 3) then !        shp = sol%shape ! !        which = 0 !        if (present(flags)) which = flags ! !        select case (which) !        case (0) !           stop \"ERROR in array3_oc: only 1, 2 allowed as flags\" !        case (1) !           call c_f_pointer(sol%yptr, r, shp) !        case (2) !           call c_f_pointer(sol%pptr, r, shp) !        case default !           stop \"ERROR in array3_oc: only 1, 2 allowed as flags\" !        end select !     else !        stop \"ERROR: array3 dimension mismatch.\" !     end if !   end function array3_oc ! !   function array4_oc(solptr, flags) result(r) !     type(c_ptr), intent(in   ), value :: solptr !     integer,     intent(in   ), optional :: flags !     real(pfdp), pointer :: r(:,:,:,:) ! !     integer                :: shp(4) !     integer                :: which !     type(ndarray_oc), pointer :: sol !     call c_f_pointer(solptr, sol) ! !     if (sol%dim == 4) then !        shp = sol%shape ! !        which = 0 !        if (present(flags)) which = flags ! !        select case (which) !        case (0) !           stop \"ERROR in array4_oc: only 1, 2 allowed as flags\" !        case (1) !           call c_f_pointer(sol%yptr, r, shp) !        case (2) !           call c_f_pointer(sol%pptr, r, shp) !        case default !           stop \"ERROR in array4_oc: only 1, 2 allowed as flags\" !        end select !     else !        stop \"ERROR: array4 dimension mismatch.\" !     end if !   end function array4_oc ! !   function array5_oc(solptr, flags) result(r) !     type(c_ptr), intent(in   ), value :: solptr !     integer,     intent(in   ), optional :: flags !     real(pfdp), pointer :: r(:,:,:,:,:) ! !     integer                :: shp(5) !     integer                :: which !     type(ndarray_oc), pointer :: sol !     call c_f_pointer(solptr, sol) ! !     if (sol%dim == 5) then !        shp = sol%shape ! !        which = 0 !        if (present(flags)) which = flags ! !        select case (which) !        case (0) !           stop \"ERROR in array5_oc: only 1, 2 allowed as flags\" !        case (1) !           call c_f_pointer(sol%yptr, r, shp) !        case (2) !           call c_f_pointer(sol%pptr, r, shp) !        case default !           stop \"ERROR in array5_oc: only 1, 2 allowed as flags\" !        end select !     else !        stop \"ERROR: array5 dimension mismatch.\" !     end if !   end function array5_oc ! !    function get_y(ptr) result(y) !      type(c_ptr), intent(in), value :: ptr !      real(pfdp),    pointer :: y(:) !      type(ndarray_oc), pointer :: sol ! !      call c_f_pointer(ptr, sol) !      y => sol%yflatarray !    end function get_y ! !    function get_p(ptr) result(p) !      type(c_ptr), intent(in), value :: ptr !      real(pfdp),    pointer :: p(:) !      type(ndarray_oc), pointer :: sol ! !      call c_f_pointer(ptr, sol) !      p => sol%pflatarray !    end function get_p ! !   subroutine ndarray_oc_encap_create(encap) !     type(pf_encap_t), intent(out) :: encap ! !     encap%create  => ndarray_oc_create !     encap%destroy => ndarray_oc_destroy !     encap%setval  => ndarray_oc_setval !     encap%copy    => ndarray_oc_copy !     encap%norm    => ndarray_oc_norm !     encap%pack    => ndarray_oc_pack !     encap%unpack  => ndarray_oc_unpack !     encap%axpy    => ndarray_oc_saxpy !   end subroutine ndarray_oc_encap_create end module pf_mod_ndarray_oc","tags":"","loc":"sourcefile/pf_ndarray-oc.f90.html","title":"pf_ndarray-oc.f90 – LibPFASST"},{"text":"MPI communicator routines This file depends on sourcefile~~pf_mpi.f90~~EfferentGraph sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_mpi.f90~~AfferentGraph sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_results.f90 pf_results.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_results.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_mpi.f90 sourcefile~pfasst.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_imexq.f90 pf_imexQ.f90 sourcefile~pfasst.f90->sourcefile~pf_imexq.f90 sourcefile~pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 sourcefile~pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_imexq.f90->sourcefile~pf_timer.f90 sourcefile~pf_imexq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imexq.f90->sourcefile~pf_utils.f90 sourcefile~pf_imexq.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_amisdcq.f90 pf_amisdcQ.f90 sourcefile~pf_amisdcq.f90->sourcefile~pf_timer.f90 sourcefile~pf_amisdc.f90 pf_amisdc.f90 sourcefile~pf_amisdcq.f90->sourcefile~pf_amisdc.f90 sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_timer.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_hooks.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_utils.f90 sourcefile~pf_restrict.f90 pf_restrict.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_restrict.f90 sourcefile~pf_parallel.f90->sourcefile~pf_timer.f90 sourcefile~pf_parallel.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel.f90->sourcefile~pf_hooks.f90 sourcefile~pf_parallel.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 sourcefile~pf_parallel.f90->sourcefile~pf_utils.f90 sourcefile~pf_parallel.f90->sourcefile~pf_restrict.f90 sourcefile~pf_parallel.f90->sourcefile~pf_results.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_timer.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_imk.f90 pf_imk.f90 sourcefile~pf_imk.f90->sourcefile~pf_timer.f90 sourcefile~pf_imk.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imk.f90->sourcefile~pf_utils.f90 sourcefile~pf_misdcq_oc.f90 pf_misdcQ_oc.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_comm.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_restrict.f90 sourcefile~pf_imex.f90 pf_imex.f90 sourcefile~pf_imex.f90->sourcefile~pf_timer.f90 sourcefile~pf_imex.f90->sourcefile~pf_utils.f90 sourcefile~pf_expq.f90 pf_expQ.f90 sourcefile~pf_expq.f90->sourcefile~pf_timer.f90 sourcefile~pf_expq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_expq.f90->sourcefile~pf_utils.f90 sourcefile~pf_exp.f90 pf_exp.f90 sourcefile~pf_exp.f90->sourcefile~pf_timer.f90 sourcefile~pf_exp.f90->sourcefile~pf_hooks.f90 sourcefile~pf_exp.f90->sourcefile~pf_utils.f90 sourcefile~pf_verlet.f90 pf_verlet.f90 sourcefile~pf_verlet.f90->sourcefile~pf_timer.f90 sourcefile~pf_verlet.f90->sourcefile~pf_hooks.f90 sourcefile~pf_verlet.f90->sourcefile~pf_utils.f90 sourcefile~pf_misdcq.f90 pf_misdcQ.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_timer.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_utils.f90 sourcefile~pf_imexq_oc.f90 pf_imexQ_oc.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_restrict.f90->sourcefile~pf_timer.f90 sourcefile~pf_restrict.f90->sourcefile~pf_hooks.f90 sourcefile~pf_misdc.f90 pf_misdc.f90 sourcefile~pf_misdc.f90->sourcefile~pf_timer.f90 sourcefile~pf_misdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_rkstepper.f90 pf_rkstepper.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_timer.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_hooks.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_utils.f90 sourcefile~pf_magnus_picard.f90 pf_magnus_picard.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_timer.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_hooks.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_utils.f90 sourcefile~pf_fftw.f90 pf_fftw.f90 sourcefile~pf_fftw.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90->sourcefile~pf_utils.f90 sourcefile~pf_fftpack.f90 pf_fftpack.f90 sourcefile~pf_fftpack.f90->sourcefile~pf_utils.f90 sourcefile~pf_zndarray.f90 pf_zndarray.f90 sourcefile~pf_zndarray.f90->sourcefile~pf_utils.f90 sourcefile~pf_ndarray.f90 pf_ndarray.f90 sourcefile~pf_ndarray.f90->sourcefile~pf_utils.f90 sourcefile~pf_ndarray-oc.f90 pf_ndarray-oc.f90 sourcefile~pf_ndarray-oc.f90->sourcefile~pf_utils.f90 var pansourcefilepf_mpif90AfferentGraph = svgPanZoom('#sourcefilepf_mpif90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_mpi pf_mod_comm_mpi Source Code pf_mpi.f90 Source Code !!  MPI communicator routines ! ! This file is part of LIBPFASST. ! module pf_mod_mpi !  include \"mpif.h\" end module pf_mod_mpi !> Module to implement communication routines in  MPI. module pf_mod_comm_mpi use pf_mod_dtype use pf_mod_mpi , only : MPI_REAL16 , MPI_REAL8 implicit none !  For normal double precision integer , parameter :: myMPI_Datatype = MPI_REAL8 !  For  quadruple precision  (see top of pf_dtype.f90) ! integer, parameter :: myMPI_Datatype=MPI_REAL16 contains !> Subroutine to create an MPI based PFASST communicator using the MPI communicator *mpi_comm*. subroutine pf_mpi_create ( pf_comm , mpi_comm ) type ( pf_comm_t ), intent ( out ) :: pf_comm integer , intent ( in ) :: mpi_comm integer :: ierror pf_comm % comm = mpi_comm !! assign communicator !> assign number of processors call mpi_comm_size ( mpi_comm , pf_comm % nproc , ierror ) !>  assign procedure pointers pf_comm % post => pf_mpi_post pf_comm % recv => pf_mpi_recv pf_comm % send => pf_mpi_send pf_comm % wait => pf_mpi_wait pf_comm % broadcast => pf_mpi_broadcast pf_comm % recv_status => pf_mpi_recv_status pf_comm % send_status => pf_mpi_send_status end subroutine pf_mpi_create !> Subroutine to set up the PFASST communicator. !! This should be called soon after adding levels to the PFASST controller subroutine pf_mpi_setup ( pf_comm , pf , ierror ) use pf_mod_mpi , only : MPI_REQUEST_NULL type ( pf_comm_t ), intent ( inout ) :: pf_comm !!  communicator type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( inout ) :: ierror !!  error flag !>  set the rank call mpi_comm_rank ( pf_comm % comm , pf % rank , ierror ) !>  allocate arrarys for and and receive requests allocate ( pf_comm % recvreq ( pf % nlevels )) allocate ( pf_comm % sendreq ( pf % nlevels )) pf_comm % sendreq = MPI_REQUEST_NULL pf_comm % statreq = - 66 !Tells the first send_status not to wait for previous one to arrive end subroutine pf_mpi_setup !> Subroutine to destroy the PFASST communicator. subroutine pf_mpi_destroy ( pf_comm ) type ( pf_comm_t ), intent ( inout ) :: pf_comm deallocate ( pf_comm % recvreq ) deallocate ( pf_comm % sendreq ) end subroutine pf_mpi_destroy !>  Subroutine to post receive requests. subroutine pf_mpi_post ( pf , level , tag , ierror , source ) type ( pf_pfasst_t ), intent ( in ) :: pf class ( pf_level_t ), intent ( inout ) :: level !!  level to send from integer , intent ( in ) :: tag !!  message tag integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source call mpi_irecv ( level % recv , level % mpibuflen , myMPI_Datatype , & source , tag , pf % comm % comm , pf % comm % recvreq ( level % index ), ierror ) end subroutine pf_mpi_post !> Subroutine to send convergence status information subroutine pf_mpi_send_status ( pf , tag , istatus , ierror , dest ) use pf_mod_mpi , only : MPI_INTEGER , MPI_STATUS_SIZE , MPI_REQUEST_NULL type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: tag !!  message tag integer , intent ( in ) :: istatus !!  status flag to send integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: dest integer :: stat ( MPI_STATUS_SIZE ) integer :: message message = istatus if ( pf % comm % statreq /= - 66 ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'waiting in send_status with statreq' , pf % comm % statreq call mpi_wait ( pf % comm % statreq , stat , ierror ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'done waiting in send_status' end if call mpi_issend ( message , 1 , MPI_INTEGER , & dest , tag , pf % comm % comm , pf % comm % statreq , ierror ) end subroutine pf_mpi_send_status !> Subroutine to receive convergence status information subroutine pf_mpi_recv_status ( pf , tag , istatus , ierror , source ) use pf_mod_mpi , only : MPI_INTEGER , MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: tag !!  message tag integer , intent ( inout ) :: istatus !!  status flag to receive integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source integer :: stat ( MPI_STATUS_SIZE ) integer :: message ! Get the message call mpi_recv ( message , 1 , MPI_INTEGER , source , tag , pf % comm % comm , stat , ierror ) istatus = message end subroutine pf_mpi_recv_status !> Subroutine to send solutions subroutine pf_mpi_send ( pf , level , tag , blocking , ierror , dest ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: level !!  level to send from integer , intent ( in ) :: tag !!  message tag logical , intent ( in ) :: blocking !!  true if send is blocking integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: dest integer :: stat ( MPI_STATUS_SIZE ) if ( blocking ) then call mpi_send ( level % send , level % mpibuflen , myMPI_Datatype , & dest , tag , pf % comm % comm , stat , ierror ) else call mpi_wait ( pf % comm % sendreq ( level % index ), stat , ierror ) call mpi_isend ( level % send , level % mpibuflen , myMPI_Datatype , & dest , tag , pf % comm % comm , pf % comm % sendreq ( level % index ), ierror ) end if end subroutine pf_mpi_send !> Subroutine to receive solutions !! Note when blocking == .false. this is actually a wait because the !! nonblocking receive  should have already been posted subroutine pf_mpi_recv ( pf , level , tag , blocking , ierror , source ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: level !!  level to recieve into integer , intent ( in ) :: tag !!  message tag logical , intent ( in ) :: blocking !!  true if receive is blocking integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source integer :: stat ( MPI_STATUS_SIZE ) if ( blocking ) then call mpi_recv ( level % recv , level % mpibuflen , myMPI_Datatype , & source , tag , pf % comm % comm , stat , ierror ) else call mpi_wait ( pf % comm % recvreq ( level % index ), stat , ierror ) end if end subroutine pf_mpi_recv ! ! Misc ! subroutine pf_mpi_wait ( pf , level , ierror ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( in ) :: pf !!  main pfasst structure integer , intent ( in ) :: level !!  level on which to wait integer , intent ( inout ) :: ierror !!  error flag integer :: stat ( MPI_STATUS_SIZE ) call mpi_wait ( pf % comm % sendreq ( level ), stat , ierror ) end subroutine pf_mpi_wait subroutine pf_mpi_broadcast ( pf , y , nvar , root , ierror ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: nvar !!  size of data to broadcast real ( pfdp ), intent ( in ) :: y ( nvar ) !!  data to broadcast integer , intent ( in ) :: root !!  rank of broadcaster integer , intent ( inout ) :: ierror !!  error flag call mpi_bcast ( y , nvar , myMPI_Datatype , root , pf % comm % comm , ierror ) end subroutine pf_mpi_broadcast end module pf_mod_comm_mpi","tags":"","loc":"sourcefile/pf_mpi.f90.html","title":"pf_mpi.f90 – LibPFASST"},{"text":"High level routines for PFASST data type This file depends on sourcefile~~pf_pfasst.f90~~EfferentGraph sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90 pf_results.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_mpi.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_results.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_pfasst.f90~~AfferentGraph sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_comm.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 sourcefile~pf_parallel.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_pfasst Source Code pf_pfasst.f90 Source Code !!  High level routines for PFASST data type ! ! This file is part of LIBPFASST. ! !>  Module containing the routines to create, setup, and destroy the main data structure in PFASST module pf_mod_pfasst use pf_mod_dtype use pf_mod_comm_mpi use pf_mod_utils use pf_mod_results implicit none contains !> Create a PFASST object subroutine pf_pfasst_create ( pf , comm , nlevels , fname , nocmd ) use pf_mod_hooks , only : PF_MAX_HOOK type ( pf_pfasst_t ), intent ( inout ) :: pf !! Main pfasst object type ( pf_comm_t ), intent ( inout ), target :: comm !! Communicator integer , intent ( in ), optional :: nlevels !! number of pfasst levels character ( len =* ), intent ( in ), optional :: fname !! Input file for pfasst parameters logical , intent ( in ), optional :: nocmd !! Determines if command line variables are to be read logical :: read_cmd !! Local version of nocmd integer :: ierr integer :: l !!  Loop variable for levels if ( present ( nlevels )) pf % nlevels = nlevels pf % outdir = \"\" !> gather some input from a file and command line read_cmd = . true . if ( present ( nocmd )) then if ( nocmd ) read_cmd = . false . end if if ( present ( fname )) then !!  fname  present,  read inputs from a file (and maybe command line) call pf_read_opts ( pf , read_cmd , fname ) else !!  fname not present, only call read_opts if we want command line read if ( read_cmd ) call pf_read_opts ( pf , read_cmd ) end if !>  set communicator pf % comm => comm !>  Set up the mpi communicator call pf_mpi_setup ( pf % comm , pf , ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"ERROR: mpi_setup failed\" ) if ( pf % rank < 0 ) then call pf_stop ( __ FILE__ , __ LINE__ ,& \"Invalid PF rank: did you call setup correctly?\" ) end if !>  allocate level pointers allocate ( pf % levels ( pf % nlevels ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error\" , pf % nlevels ) !>  loop over levels to set parameters do l = 1 , pf % nlevels pf % levels ( l )% index = l pf % levels ( l )% nsweeps = pf % nsweeps ( l ) pf % levels ( l )% nsweeps_pred = pf % nsweeps_pred ( l ) pf % levels ( l )% nnodes = pf % nnodes ( l ) pf % levels ( l )% Finterp = pf % Finterp pf % levels ( l )% nsteps_rk = pf % nsteps_rk ( l ) end do !>  allocate hooks allocate ( pf % hooks ( pf % nlevels , PF_MAX_HOOK , PF_MAX_HOOKS ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error hooks\" ) allocate ( pf % nhooks ( pf % nlevels , PF_MAX_HOOK ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error nhooks\" ) pf % nhooks = 0 !>  allocate status allocate ( pf % state , stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error state\" ) pf % state % pstatus = 0 pf % state % status = 0 end subroutine pf_pfasst_create !> Setup both the PFASST object and the comm object subroutine pf_pfasst_setup ( pf ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  Main pfasst structure class ( pf_level_t ), pointer :: lev_fine , lev_coarse !!  Pointers to level structures for brevity integer :: l !!  Level loop index integer :: ierr !!  error flag !>  loop over levels to set parameters do l = 1 , pf % nlevels call pf_level_setup ( pf , pf % levels ( l )) end do !>  Loop over levels setting interpolation and restriction matrices (in time) do l = pf % nlevels , 2 , - 1 lev_fine => pf % levels ( l ); lev_coarse => pf % levels ( l - 1 ) allocate ( lev_fine % tmat ( lev_fine % nnodes , lev_coarse % nnodes ), stat = ierr ) if ( ierr /= 0 ) & call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" , lev_fine % nnodes ) allocate ( lev_fine % rmat ( lev_coarse % nnodes , lev_fine % nnodes ), stat = ierr ) if ( ierr /= 0 ) & call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" , lev_fine % nnodes ) ! with the RK stepper, no need to interpolate and restrict in time ! we only copy the first node and last node betweem levels if ( pf % use_rk_stepper . eqv . . true .) then lev_fine % tmat = 0.0_pfdp lev_fine % rmat = 0.0_pfdp lev_fine % tmat ( 1 , 1 ) = 1.0_pfdp lev_fine % tmat ( lev_fine % nnodes , lev_coarse % nnodes ) = 1.0_pfdp lev_fine % rmat ( 1 , 1 ) = 1.0_pfdp lev_fine % rmat ( lev_coarse % nnodes , lev_fine % nnodes ) = 1.0_pfdp else ! else compute the interpolation matrix call pf_time_interpolation_matrix ( lev_fine % nodes , lev_fine % nnodes , lev_coarse % nodes , lev_coarse % nnodes , lev_fine % tmat ) call pf_time_interpolation_matrix ( lev_coarse % nodes , lev_coarse % nnodes , lev_fine % nodes , lev_fine % nnodes , lev_fine % rmat ) endif end do end subroutine pf_pfasst_setup !> Setup (allocate) PFASST level !! If the level is already setup, calling this again will allocate !! (or deallocate) tauQ appropriately. subroutine pf_level_setup ( pf , lev ) use pf_mod_quadrature type ( pf_pfasst_t ), intent ( in ) :: pf !!  Main pfasst structure class ( pf_level_t ), intent ( inout ), target :: lev !!  Level to set up integer :: mpibuflen , nnodes , npieces , nnodes0 integer :: i , ierr !> do some sanity checks mpibuflen = lev % mpibuflen if ( mpibuflen <= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , 'allocate fail' , mpibuflen ) nnodes = lev % nnodes if ( nnodes <= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , 'allocate fail' , nnodes ) lev % residual = - 1.0_pfdp !> (re)allocate tauQ (may to need create/destroy tauQ dynamically  when doing AMR) if (( lev % index < pf % nlevels ) . and . (. not . allocated ( lev % tauQ ))) then call lev % ulevel % factory % create_array ( lev % tauQ , nnodes - 1 , lev % index , lev % shape ) else if (( lev % index >= pf % nlevels ) . and . ( allocated ( lev % tauQ ))) then deallocate ( lev % tauQ ) end if !> skip the rest if we're already allocated if ( lev % allocated ) return lev % allocated = . true . !> allocate flat buffers for send, and recv allocate ( lev % send ( mpibuflen ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) allocate ( lev % recv ( mpibuflen ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) !> allocate nodes, flags, and integration matrices allocate ( lev % nodes ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) allocate ( lev % nflags ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) lev % nflags = 0 !>  Allocate and compute all the matrices allocate ( lev % sdcmats , stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error sdcmats\" ) call pf_init_sdcmats ( pf , lev % sdcmats , nnodes , lev % nflags ) lev % nodes = lev % sdcmats % qnodes !>  initialize sweeper lev % ulevel % sweeper % use_LUq = pf % use_LUq call lev % ulevel % sweeper % initialize ( lev ) if ( pf % use_rk_stepper ) call lev % ulevel % stepper % initialize ( lev ) !> allocate solution and function arrays npieces = lev % ulevel % sweeper % npieces call lev % ulevel % factory % create_array ( lev % Q , nnodes , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( lev % Fflt , nnodes * npieces , lev % index , lev % shape ) do i = 1 , nnodes * npieces call lev % Fflt ( i )% setval ( 0.0_pfdp , 0 ) end do lev % F ( 1 : nnodes , 1 : npieces ) => lev % Fflt call lev % ulevel % factory % create_array ( lev % I , nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( lev % R , nnodes - 1 , lev % index , lev % shape ) !  Need space for old function values in imexR sweepers call lev % ulevel % factory % create_array ( lev % pFflt , nnodes * npieces , lev % index , lev % shape ) lev % pF ( 1 : nnodes , 1 : npieces ) => lev % pFflt if ( lev % index < pf % nlevels ) then call lev % ulevel % factory % create_array ( lev % pQ , nnodes , lev % index , lev % shape ) end if call lev % ulevel % factory % create_single ( lev % qend , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( lev % q0 , lev % index , lev % shape ) end subroutine pf_level_setup !> Deallocate PFASST object subroutine pf_pfasst_destroy ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  Main pfasst structure integer :: l !>  destroy all levels do l = 1 , pf % nlevels call pf_level_destroy ( pf % levels ( l ), pf % nlevels ) end do !>  deallocate pfasst pointer arrays !    call pf%destroy_results() deallocate ( pf % levels ) deallocate ( pf % hooks ) deallocate ( pf % nhooks ) deallocate ( pf % state ) call pf_mpi_destroy ( pf % comm ) end subroutine pf_pfasst_destroy !> Deallocate PFASST level subroutine pf_level_destroy ( lev , nlevels ) use pf_mod_quadrature class ( pf_level_t ), intent ( inout ) :: lev !!  level to destroy integer :: nlevels !!  number of pfasst levels integer :: npieces !!  local copy of number of function pieces if (. not . lev % allocated ) return !> deallocate flat buffers for communcition deallocate ( lev % send ) deallocate ( lev % recv ) !> deallocate nodes, flags, and integration matrices deallocate ( lev % nodes ) deallocate ( lev % nflags ) call pf_destroy_sdcmats ( lev % sdcmats ) deallocate ( lev % sdcmats ) !> deallocate solution and function storage npieces = lev % ulevel % sweeper % npieces if (( lev % index < nlevels ) . and . allocated ( lev % tauQ )) then call lev % ulevel % factory % destroy_array ( lev % tauQ , lev % nnodes - 1 , lev % index , lev % shape ) end if call lev % ulevel % factory % destroy_array ( lev % Q , lev % nnodes , lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( lev % Fflt , lev % nnodes * npieces , lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( lev % I , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( lev % R , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( lev % pFflt , lev % nnodes * npieces , lev % index , lev % shape ) if ( lev % index < nlevels ) then call lev % ulevel % factory % destroy_array ( lev % pQ , lev % nnodes , lev % index , lev % shape ) end if call lev % ulevel % factory % destroy_single ( lev % qend , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( lev % q0 , lev % index , lev % shape ) !> destroy the sweeper call lev % ulevel % sweeper % destroy ( lev ) !> deallocate misc. arrays if ( allocated ( lev % shape )) then deallocate ( lev % shape ) end if if ( allocated ( lev % tmat )) then deallocate ( lev % tmat ) end if if ( allocated ( lev % rmat )) then deallocate ( lev % rmat ) end if end subroutine pf_level_destroy !>  Subroutine to read pfasst options from file and command line subroutine pf_read_opts ( pf , read_cmd , fname ) type ( pf_pfasst_t ), intent ( inout ) :: pf logical , intent ( in ) :: read_cmd character ( len =* ), intent ( in ), optional :: fname ! local versions of pfasst parameters integer :: niters , nlevels , qtype integer :: nsweeps ( PF_MAXLEVS ) integer :: nsweeps_pred ( PF_MAXLEVS ) integer :: nnodes ( PF_MAXLEVS ) integer :: nsteps_rk ( PF_MAXLEVS ) real ( pfdp ) :: abs_res_tol , rel_res_tol logical :: PFASST_pred , RK_pred , pipeline_pred integer :: nsweeps_burn , q0_style , taui0 logical :: Vcycle , Finterp , use_LUq logical :: debug , use_rk_stepper logical :: save_timings , echo_timings , save_residuals , save_errors logical :: use_no_left_q , use_composite_nodes , use_proper_nodes ! stuff for reading the command line integer , parameter :: un = 9 integer :: i , ios character ( len = 32 ) :: arg character ( len = 255 ) :: istring ! stores command line argument character ( len = 255 ) :: message ! use for i/o error messages character ( len = 512 ) :: outdir !> define the namelist for reading namelist / pf_params / niters , nlevels , qtype , nsweeps , nsweeps_pred , nnodes , nsteps_rk , abs_res_tol , rel_res_tol namelist / pf_params / PFASST_pred , RK_pred , pipeline_pred , nsweeps_burn , q0_style , taui0 namelist / pf_params / Vcycle , Finterp , use_LUq , echo_timings , debug , save_timings , save_residuals , save_errors , use_rk_stepper namelist / pf_params / use_no_left_q , use_composite_nodes , use_proper_nodes !> set local variables to pf_pfasst defaults nlevels = pf % nlevels niters = pf % niters qtype = pf % qtype nsweeps = pf % nsweeps nsweeps_pred = pf % nsweeps_pred nnodes = pf % nnodes abs_res_tol = pf % abs_res_tol rel_res_tol = pf % rel_res_tol pfasst_pred = pf % pfasst_pred pipeline_pred = pf % pipeline_pred nsweeps_burn = pf % nsweeps_burn q0_style = pf % q0_style Vcycle = pf % Vcycle Finterp = pf % Finterp use_LUq = pf % use_LUq taui0 = pf % taui0 outdir = pf % outdir debug = pf % debug save_residuals = pf % save_residuals save_errors = pf % save_errors save_timings = pf % save_timings echo_timings = pf % echo_timings nsteps_rk = pf % nsteps_rk rk_pred = pf % rk_pred use_rk_stepper = pf % use_rk_stepper use_no_left_q = pf % use_no_left_q use_composite_nodes = pf % use_composite_nodes use_proper_nodes = pf % use_proper_nodes !> open the file \"fname\" and read the pfasst namelist if ( present ( fname )) then open ( unit = un , file = fname , status = 'old' , action = 'read' ) read ( unit = un , nml = pf_params ) close ( unit = un ) end if !> overwrite parameters defined on  command line if ( read_cmd ) then i = 0 do call get_command_argument ( i , arg ) if ( len_trim ( arg ) == 0 ) exit if ( i > 0 ) then istring = \"&pf_params \" // trim ( arg ) // \" /\" read ( istring , nml = pf_params , iostat = ios , iomsg = message ) ! internal read of namelist end if i = i + 1 end do end if !> re-assign the pfasst internals pf % nlevels = nlevels pf % niters = niters pf % qtype = qtype pf % nsweeps = nsweeps pf % nsweeps_pred = nsweeps_pred pf % nnodes = nnodes pf % abs_res_tol = abs_res_tol pf % rel_res_tol = rel_res_tol pf % pfasst_pred = pfasst_pred pf % pipeline_pred = pipeline_pred pf % nsweeps_burn = nsweeps_burn pf % q0_style = q0_style pf % Vcycle = Vcycle pf % Finterp = Finterp pf % use_LUq = use_LUq pf % taui0 = taui0 pf % outdir = outdir pf % debug = debug pf % echo_timings = echo_timings pf % save_residuals = save_residuals pf % save_timings = save_timings pf % save_errors = save_errors pf % use_rk_stepper = use_rk_stepper pf % nsteps_rk = nsteps_rk pf % rk_pred = rk_pred pf % use_no_left_q = use_no_left_q pf % use_composite_nodes = use_composite_nodes pf % use_proper_nodes = use_proper_nodes !>  Sanity check if ( pf % nlevels < 1 ) then call pf_stop ( __ FILE__ , __ LINE__ , 'Bad specification for nlevels' , pf % nlevels ) endif end subroutine pf_read_opts !>  Subroutine to write out run parameters subroutine pf_print_options ( pf , un_opt , show_mats_opt ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ), optional :: un_opt logical , intent ( in ), optional :: show_mats_opt integer :: un = 6 logical :: show_mats = . FALSE . integer :: l , i character ( 8 ) :: date character ( 10 ) :: time if ( pf % rank /= 0 ) return if ( present ( un_opt )) un = un_opt write ( un , * ) '==================================================' write ( un , * ) 'PFASST Configuration' write ( un , * ) '--------------------' call date_and_time ( date = date , time = time ) write ( un , * ) 'date:        ' , date write ( un , * ) 'time:        ' , time write ( un , * ) 'double precision:   ' , pfdp , '  bytes' write ( un , * ) 'quad precision:   ' , pfqp , '  bytes' write ( un , * ) 'nlevels:     ' , pf % nlevels , '! number of pfasst levels' write ( un , * ) 'nprocs:      ' , pf % comm % nproc , '! number of pfasst \"time\" processors' if ( pf % comm % nproc == 1 ) then write ( un , * ) '            ' , '             ' , ' ! since 1 time proc is being used, this is a serial sdc run' else write ( un , * ) '            ' , '             ' , ' ! since >1 time procs are being used, this is a parallel pfasst run' end if write ( un , * ) 'niters:      ' , pf % niters , '! maximum number of sdc/pfasst iterations' select case ( pf % qtype ) case ( SDC_GAUSS_LEGENDRE ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Legendre nodes are used' case ( SDC_GAUSS_LOBATTO ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Lobatto nodes are used' case ( SDC_GAUSS_RADAU ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Radua nodes are used' case ( SDC_CLENSHAW_CURTIS ) write ( un , * ) 'qtype:' , pf % qtype , '! Clenshaw Curtis nodes are used' case ( SDC_UNIFORM ) write ( un , * ) 'qtype:' , pf % qtype , '! Uniform  nodes are used' case ( SDC_CHEBYSHEV ) write ( un , * ) 'qtype:' , pf % qtype , '! Chebyshev  nodes are used' case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , pf % qtype ) end select if ( pf % use_proper_nodes ) write ( un , * ) 'Using proper node nesting' if ( pf % use_composite_nodes ) write ( un , * ) 'Using composite node nesting' if ( pf % use_no_left_q ) write ( un , * ) ' Skipping left end point in quadruture rule ' write ( un , * ) 'nnodes:      ' , pf % levels ( 1 : pf % nlevels )% nnodes , '! number of sdc nodes per level' write ( un , * ) 'mpibuflen:   ' , pf % levels ( 1 : pf % nlevels )% mpibuflen , '! size of data send between time steps' write ( un , * ) 'nsweeps:     ' , pf % levels ( 1 : pf % nlevels )% nsweeps , '! number of sdc sweeps performed per visit to each level' write ( un , * ) 'nsweeps_pred:     ' , pf % levels ( 1 : pf % nlevels )% nsweeps_pred , '! number of sdc sweeps in predictor' write ( un , * ) 'taui0:     ' , pf % taui0 , '! cutoff for tau correction' write ( un , * ) 'abs_res_tol:' , pf % abs_res_tol , '! absolute residual tolerance: ' write ( un , * ) 'rel_res_tol:' , pf % rel_res_tol , '! relative residual tolerance: ' if ( pf % use_Luq ) then write ( un , * ) 'Implicit matrix is LU  ' else write ( un , * ) 'Implicit matrix is backward Euler  ' end if if ( pf % Vcycle ) then write ( un , * ) 'V-cycling is on' else write ( un , * ) 'V-cycling is off, fine level is pipelining' end if if ( pf % rk_pred ) then write ( un , * ) 'Runge-Kutta used for predictor' else if ( pf % pipeline_pred ) then write ( un , * ) 'Predictor pipelining is ON    ' else write ( un , * ) 'Predictor pipelining is OFF    ' end if if ( pf % PFASST_pred ) then write ( un , * ) 'PFASST Predictor style  ' else write ( un , * ) 'Serial Predictor style  ' end if endif if ( pf % debug ) write ( un , * ) 'Debug mode is on ' write ( un , * ) '' if ( present ( show_mats_opt )) show_mats = show_mats_opt if ( show_mats ) then do l = 1 , pf % nlevels print * , \"Level\" , l print * , \"-----------------\" print * , \"  nodes\" print * , pf % levels ( l )% nodes print * , \"  Q\" do i = 1 , pf % levels ( l )% nnodes - 1 print * , pf % levels ( l )% sdcmats % qmat ( i ,:) end do end do end if end subroutine pf_print_options !> Subroutine to make the matrices for interpolation  between noodes subroutine pf_time_interpolation_matrix ( f_nodes , f_nnodes , c_nodes , c_nnodes , tmat ) integer , intent ( in ) :: f_nnodes !!  number of nodes on fine level integer , intent ( in ) :: c_nnodes !!  number of nodes on coarse  level real ( pfdp ), intent ( in ) :: f_nodes ( 0 : f_nnodes - 1 ) !!  quadrature nodes on fine  level real ( pfdp ), intent ( in ) :: c_nodes ( 0 : c_nnodes - 1 ) !!  quadrature nodes on coarse  level real ( pfdp ), intent ( out ) :: tmat ( 0 : f_nnodes - 1 , 0 : c_nnodes - 1 ) !!  Interpolation matrix to compute integer :: i , j , k real ( pfdp ) :: xi , num , den do i = 0 , f_nnodes - 1 xi = f_nodes ( i ) do j = 0 , c_nnodes - 1 den = 1.0_pfdp num = 1.0_pfdp do k = 0 , c_nnodes - 1 if ( k == j ) cycle den = den * ( c_nodes ( j ) - c_nodes ( k )) num = num * ( xi - c_nodes ( k )) end do tmat ( i , j ) = num / den end do end do end subroutine pf_time_interpolation_matrix !>  Subroutine to write out run parameters subroutine pf_initialize_results ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: lev_ind ALLOCATE ( pf % results ( pf % nlevels )) do lev_ind = 1 , pf % nlevels call initialize_results ( pf % results ( lev_ind ), pf % state % nsteps , pf % niters , pf % comm % nproc , pf % nsweeps ( lev_ind ), pf % rank , lev_ind ) end do end subroutine pf_initialize_results !>  Subroutine to write out run parameters subroutine pf_dump_results ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: lev_ind if ( pf % save_residuals ) then do lev_ind = 1 , pf % nlevels call dump_results ( pf % results ( lev_ind )) end do end if if ( pf % save_errors ) then do lev_ind = 1 , pf % nlevels !          call  dump_errors(pf%results(lev_ind)) end do end if if ( pf % save_timings ) then call dump_timings ( pf ) end if end subroutine pf_dump_results end module pf_mod_pfasst","tags":"","loc":"sourcefile/pf_pfasst.f90.html","title":"pf_pfasst.f90 – LibPFASST"},{"text":"Old style IMEX sweeper This file depends on sourcefile~~pf_imex.f90~~EfferentGraph sourcefile~pf_imex.f90 pf_imex.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_imex.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_imex.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_imex.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_imex Source Code pf_imex.f90 Source Code !!  Old style IMEX sweeper ! ! This file is part of LIBPFASST. ! module pf_mod_imex use pf_mod_dtype use pf_mod_utils implicit none !>  IMEX SDC sweeper type (old style), extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_imex_t real ( pfdp ), allocatable :: SdiffE (:,:) real ( pfdp ), allocatable :: SdiffI (:,:) contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => imex_sweep procedure :: initialize => imex_initialize procedure :: evaluate => imex_evaluate procedure :: integrate => imex_integrate procedure :: residual => imex_residual procedure :: spreadq0 => imex_spreadq0 procedure :: evaluate_all => imex_evaluate_all procedure :: destroy => imex_destroy procedure :: imex_destroy end type pf_imex_t interface subroutine pf_f_eval_p ( this , y , t , level , f , piece ) import pf_imex_t , pf_encap_t , pfdp class ( pf_imex_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: f integer , intent ( in ) :: piece end subroutine pf_f_eval_p subroutine pf_f_comp_p ( this , y , t , dt , rhs , level , f , piece ) import pf_imex_t , pf_encap_t , pfdp class ( pf_imex_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( in ) :: rhs integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: f integer , intent ( in ) :: piece end subroutine pf_f_comp_p end interface contains ! Perform on SDC sweep on level lev and set qend appropriately. subroutine imex_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_imex_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: rhs call start_timer ( pf , TLEVEL + lev % index - 1 ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % SdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( dt * this % SdiffI ( m , n ), lev % F ( n , 2 )) end do if ( allocated ( lev % tau )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tau ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) call lev % ulevel % factory % create_single ( rhs , lev % index , lev % shape ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) call rhs % copy ( lev % Q ( m )) call rhs % axpy ( dtsdc ( m ), lev % F ( m , 1 )) call rhs % axpy ( 1.0_pfdp , lev % S ( m )) call this % f_comp ( lev % Q ( m + 1 ), t , dtsdc ( m ), rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) ! done call lev % ulevel % factory % destroy_single ( rhs , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imex_sweep ! Evaluate function values subroutine imex_evaluate ( this , lev , t , m ) class ( pf_imex_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) end subroutine imex_evaluate ! Initialize matrices subroutine imex_initialize ( this , lev ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , nnodes this % npieces = 2 nnodes = lev % nnodes allocate ( this % SdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % SdiffI ( nnodes - 1 , nnodes )) !  S-BE this % SdiffE = lev % s0mat this % SdiffI = lev % s0mat dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) do m = 1 , nnodes - 1 this % SdiffE ( m , m ) = this % SdiffE ( m , m ) - dsdc ( m ) this % SdiffI ( m , m + 1 ) = this % SdiffI ( m , m + 1 ) - dsdc ( m ) end do end subroutine imex_initialize ! Destroy the matrices subroutine imex_destroy ( this , lev ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % SdiffE ) deallocate ( this % SdiffI ) end subroutine imex_destroy ! Compute SDC integral subroutine imex_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % s0mat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine imex_integrate subroutine imex_residual ( this , lev , dt ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt call pf_generic_residual ( this , lev , dt ) end subroutine imex_residual subroutine imex_spreadq0 ( this , lev , t0 ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine imex_spreadq0 subroutine imex_evaluate_all ( this , lev , t ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) call pf_generic_evaluate_all ( this , lev , t ) end subroutine imex_evaluate_all end module pf_mod_imex","tags":"","loc":"sourcefile/pf_imex.f90.html","title":"pf_imex.f90 – LibPFASST"},{"text":"Calling of user defined routines from various places in the pfasst algorithm This file depends on sourcefile~~pf_hooks.f90~~EfferentGraph sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_hooks.f90~~AfferentGraph sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_imexq.f90 pf_imexQ.f90 sourcefile~pf_imexq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_restrict.f90 pf_restrict.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_restrict.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_comm.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_hooks.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_restrict.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pf_parallel.f90->sourcefile~pf_hooks.f90 sourcefile~pf_parallel.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_parallel.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel.f90->sourcefile~pf_restrict.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 sourcefile~pf_imexq_oc.f90 pf_imexQ_oc.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imk.f90 pf_imk.f90 sourcefile~pf_imk.f90->sourcefile~pf_hooks.f90 sourcefile~pf_misdcq_oc.f90 pf_misdcQ_oc.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_expq.f90 pf_expQ.f90 sourcefile~pf_expq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_misdcq.f90 pf_misdcQ.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_exp.f90 pf_exp.f90 sourcefile~pf_exp.f90->sourcefile~pf_hooks.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_verlet.f90 pf_verlet.f90 sourcefile~pf_verlet.f90->sourcefile~pf_hooks.f90 sourcefile~pf_restrict.f90->sourcefile~pf_hooks.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pfasst.f90->sourcefile~pf_imexq.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 sourcefile~pfasst.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_rkstepper.f90 pf_rkstepper.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_hooks.f90 sourcefile~pf_magnus_picard.f90 pf_magnus_picard.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_hooks.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_hooks Source Code pf_hooks.f90 Source Code !! Calling of user defined routines from various places in the pfasst algorithm ! ! This file is part of LIBPFASST. ! !>  Module for the calling of user defined routines from various places in the pfasst algorithm module pf_mod_hooks use pf_mod_dtype implicit none !>  Define hook indices integer , parameter :: & PF_PRE_PREDICTOR = 1 , & PF_POST_PREDICTOR = 2 , & PF_PRE_ITERATION = 3 , & PF_POST_ITERATION = 4 , & PF_PRE_SWEEP = 5 , & PF_POST_SWEEP = 6 , & PF_PRE_STEP = 7 , & PF_POST_STEP = 8 , & PF_PRE_INTERP_ALL = 9 , & PF_POST_INTERP_ALL = 10 , & PF_PRE_INTERP_Q0 = 11 , & PF_POST_INTERP_Q0 = 12 , & PF_PRE_RESTRICT_ALL = 13 , & PF_POST_RESTRICT_ALL = 14 , & PF_PRE_CONVERGENCE = 15 , & PF_POST_CONVERGENCE = 16 , & PF_MAX_HOOK = 16 integer , parameter :: & PF_HOOK_LOG_ONE = 1 , & PF_HOOK_LOG_ALL = 7 , & PF_HOOK_LOG_LAST = PF_MAX_HOOK !>  Define hook names character ( len = 20 ), parameter :: hook_names ( PF_HOOK_LOG_LAST ) = ( / & 'pre-predictor      ' , & 'post-predictor     ' , & 'pre-iteration      ' , & 'post-iteration     ' , & 'pre-sweep          ' , & 'post-sweep         ' , & 'pre-step           ' , & 'post-step          ' , & 'pre-interp-all     ' , & 'post-interp-all    ' , & 'pre-interp-q0      ' , & 'post-interp-q0     ' , & 'pre-restrict-all   ' , & 'post-restrict-all  ' , & 'pre-convergence    ' , & 'post-convergence   ' / ) contains !> Subroutine to add a procedure to the hook on the given level subroutine pf_add_hook ( pf , level_ind , hook , proc ) type ( pf_pfasst_t ), intent ( inout ) :: pf !! main pfasst structure integer , intent ( in ) :: level_ind !! which pfasst level to add hook integer , intent ( in ) :: hook !! which hook to add procedure ( pf_hook_p ) :: proc !! precudre to call from hook integer :: l ! if ( level_ind == - 1 ) then ! Do to all levels do l = 1 , pf % nlevels pf % nhooks ( l , hook ) = pf % nhooks ( l , hook ) + 1 pf % hooks ( l , hook , pf % nhooks ( l , hook ))% proc => proc end do else ! Do to just level level_ind pf % nhooks ( level_ind , hook ) = pf % nhooks ( level_ind , hook ) + 1 pf % hooks ( level_ind , hook , pf % nhooks ( level_ind , hook ))% proc => proc end if end subroutine pf_add_hook !> Subroutine to call hooks associated with the hook and level subroutine call_hooks ( pf , level_ind , hook ) use pf_mod_timer type ( pf_pfasst_t ), intent ( inout ), target :: pf !! main pfasst structure integer , intent ( in ) :: level_ind !! which pfasst level to call hook integer , intent ( in ) :: hook !! which hook to call integer :: i !!  hook loop index integer :: l !!  level loop index call start_timer ( pf , THOOKS ) pf % state % hook = hook if ( level_ind == - 1 ) then ! Do to all levels do l = 1 , pf % nlevels do i = 1 , pf % nhooks ( l , hook ) call pf % hooks ( l , hook , i )% proc ( pf , pf % levels ( l ), pf % state ) end do end do else ! Do to just level level_ind do i = 1 , pf % nhooks ( level_ind , hook ) call pf % hooks ( level_ind , hook , i )% proc ( pf , pf % levels ( level_ind ), pf % state ) end do end if call end_timer ( pf , THOOKS ) end subroutine call_hooks !>  Subroutine defining log hook subroutine pf_logger_hook ( pf , level , state ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level type ( pf_state_t ), intent ( in ) :: state print '(\"PF:: trank: \",i4,\", step: \",i6,\", iter: \",i3,\", level: \",i2,\" location: \",a)' , & pf % rank , state % step , state % iter , level % index , hook_names ( state % hook ) end subroutine pf_logger_hook !>  Subroutine to add log hook subroutine pf_logger_attach ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: l , h do h = PF_HOOK_LOG_ONE , PF_HOOK_LOG_ALL - 1 call pf_add_hook ( pf , 1 , h , pf_logger_hook ) end do do l = 1 , pf % nlevels do h = PF_HOOK_LOG_ALL , PF_HOOK_LOG_LAST call pf_add_hook ( pf , l , h , pf_logger_hook ) end do end do end subroutine pf_logger_attach end module pf_mod_hooks","tags":"","loc":"sourcefile/pf_hooks.f90.html","title":"pf_hooks.f90 – LibPFASST"},{"text":"Old style multi-implicit sweeper This file depends on sourcefile~~pf_misdc.f90~~EfferentGraph sourcefile~pf_misdc.f90 pf_misdc.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_misdc.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_misdc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_misdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_misdc Source Code pf_misdc.f90 Source Code !!  Old style multi-implicit sweeper ! ! This file is part of LIBPFASST. ! module pf_mod_misdc use pf_mod_dtype use pf_mod_utils implicit none !>  Multi-implicit SDC sweeper type (old style), extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_misdc_t real ( pfdp ), allocatable :: SdiffE (:,:) real ( pfdp ), allocatable :: SdiffI (:,:) contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdc_sweep procedure :: initialize => misdc_initialize procedure :: evaluate => misdc_evaluate procedure :: integrate => misdc_integrate procedure :: residual => misdc_residual procedure :: evaluate_all => misdc_evaluate_all procedure :: destroy => misdc_destroy procedure :: misdc_destroy end type pf_misdc_t interface subroutine pf_f_eval_p ( this , y , t , level , f , piece ) import pf_misdc_t , pf_encap_t , pfdp class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: f integer , intent ( in ) :: piece end subroutine pf_f_eval_p subroutine pf_f_comp_p ( this , y , t , dt , rhs , level , f , piece ) import pf_misdc_t , pf_encap_t , pfdp class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( in ) :: rhs integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: f integer , intent ( in ) :: piece end subroutine pf_f_comp_p end interface contains ! Perform on SDC sweep on level lev and set qend appropriately. subroutine misdc_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_misdc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: S3 (:) class ( pf_encap_t ), allocatable :: rhs call start_timer ( pf , TLEVEL + lev % index - 1 ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % SdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( dt * this % SdiffI ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tau )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tau ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call misdc_evaluate ( this , lev , t , 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 ) call lev % ulevel % factory % create_single ( rhs , lev % index , lev % shape ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) call rhs % copy ( lev % Q ( m )) call rhs % axpy ( dtsdc ( m ), lev % F ( m , 1 )) call rhs % axpy ( 1.0_pfdp , lev % S ( m )) call this % f_comp ( lev % Q ( m + 1 ), t , dtsdc ( m ), rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) !  Now we need to do the final subtraction for the f3 piece call rhs % copy ( Lev % Q ( m + 1 )) call rhs % axpy ( - 1.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 3 )) call this % f_comp ( lev % Q ( m + 1 ), t , dtsdc ( m ), rhs , lev % index , lev % F ( m + 1 , 3 ), 3 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 ) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) ! done call lev % ulevel % factory % destroy_single ( rhs , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine misdc_sweep ! Evaluate function values subroutine misdc_evaluate ( this , lev , t , m ) use pf_mod_dtype class ( pf_misdc_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 ) end subroutine misdc_evaluate ! Initialize matrices subroutine misdc_initialize ( this , lev ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % SdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % SdiffI ( nnodes - 1 , nnodes )) !  S-BE this % SdiffE = lev % s0mat this % SdiffI = lev % s0mat dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) do m = 1 , nnodes - 1 this % SdiffE ( m , m ) = this % SdiffE ( m , m ) - dsdc ( m ) this % SdiffI ( m , m + 1 ) = this % SdiffI ( m , m + 1 ) - dsdc ( m ) end do end subroutine misdc_initialize subroutine misdc_destroy ( this , lev ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % SdiffE ) deallocate ( this % SdiffI ) end subroutine misdc_destroy ! Compute SDC integral subroutine misdc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % s0mat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine misdc_integrate subroutine misdc_residual ( this , lev , dt ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt call pf_generic_residual ( this , lev , dt ) end subroutine misdc_residual subroutine misdc_evaluate_all ( this , lev , t ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) call pf_generic_evaluate_all ( this , lev , t ) end subroutine misdc_evaluate_all end module pf_mod_misdc","tags":"","loc":"sourcefile/pf_misdc.f90.html","title":"pf_misdc.f90 – LibPFASST"},{"text":"N-dimensional array encapsulation. This file depends on sourcefile~~pf_ndarray.f90~~EfferentGraph sourcefile~pf_ndarray.f90 pf_ndarray.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_ndarray.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_ndarray.f90->sourcefile~pf_utils.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_ndarray Source Code pf_ndarray.f90 Source Code !!  N-dimensional array encapsulation. ! ! This file is part of LIBPFASST. ! !> N-dimensional array encapsulation. !! !! When a new solution is created by a PFASST level, this encapsulation !! uses the levels 'shape' attribute to create a new array with that !! shape.  Thus, the 'shape' attributes of the PFASST levels should be !! set appropriately.  For example, before calling pf_pfasst_run we can !! set the shape of the coarsest level by doing: !! !!   allocate(pf%levels(1)%shape(2)) !!   pf%levels(1)%shape = [ 3, 10 ] !! !! The helper routines array1, array2, array3, etc can be used to !! extract pointers to the encapsulated array without !! performing any copies. !! module pf_mod_ndarray use iso_c_binding use pf_mod_dtype use pf_mod_utils implicit none !>  Type to create and destroy N-dimenstional arrays type , extends ( pf_factory_t ) :: ndarray_factory contains procedure :: create_single => ndarray_create_single procedure :: create_array => ndarray_create_array procedure :: destroy_single => ndarray_destroy_single procedure :: destroy_array => ndarray_destroy_array end type ndarray_factory !>  N-dimensional array type,  extends the abstract encap type type , extends ( pf_encap_t ) :: ndarray integer :: dim integer , allocatable :: shape (:) real ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => ndarray_setval procedure :: copy => ndarray_copy procedure :: norm => ndarray_norm procedure :: pack => ndarray_pack procedure :: unpack => ndarray_unpack procedure :: axpy => ndarray_axpy procedure :: eprint => ndarray_eprint end type ndarray !> Interfaces to output routines in pf_numpy.c interface !>  Subroutine to make a directory for output subroutine ndarray_mkdir ( dname , dlen ) bind ( c ) use iso_c_binding character ( c_char ), intent ( in ) :: dname integer , intent ( in ), value :: dlen end subroutine ndarray_mkdir !>  Subroutine to write an the array to a file subroutine ndarray_dump_numpy ( dname , fname , endian , dim , mpibuflen , shape , array ) bind ( c ) use iso_c_binding character ( c_char ), intent ( in ) :: dname , fname , endian ( 5 ) integer , intent ( in ), value :: dim , mpibuflen integer , intent ( in ) :: shape ( dim ) real ( c_double ), intent ( in ) :: array ( mpibuflen ) end subroutine ndarray_dump_numpy end interface contains function cast_as_ndarray ( encap_polymorph ) result ( ndarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndarray ), pointer :: ndarray_obj select type ( encap_polymorph ) type is ( ndarray ) ndarray_obj => encap_polymorph end select end function cast_as_ndarray !>  Subroutine to allocate the array and set the size parameters subroutine ndarray_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) select type ( q ) class is ( ndarray ) allocate ( q % shape ( size ( shape ))) allocate ( q % flatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape end select end subroutine ndarray_build !> Subroutine to  create a single array subroutine ndarray_create_single ( this , x , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) integer :: i allocate ( ndarray :: x ) call ndarray_build ( x , shape ) end subroutine ndarray_create_single !> Subroutine to create an array of arrays subroutine ndarray_create_array ( this , x , n , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndarray :: x ( n )) do i = 1 , n call ndarray_build ( x ( i ), shape ) end do end subroutine ndarray_create_array !>  Subroutine to destroy array subroutine ndarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndarray ), pointer :: ndarray_obj ndarray_obj => cast_as_ndarray ( encap ) deallocate ( ndarray_obj % shape ) deallocate ( ndarray_obj % flatarray ) nullify ( ndarray_obj ) end subroutine ndarray_destroy !> Subroutine to destroy an single array subroutine ndarray_destroy_single ( this , x , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) select type ( x ) class is ( ndarray ) deallocate ( x % shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine ndarray_destroy_single !> Subroutine to destroy an array of arrays subroutine ndarray_destroy_array ( this , x , n , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i select type ( x ) class is ( ndarray ) do i = 1 , n deallocate ( x ( i )% shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine ndarray_destroy_array !>  The following are the base subroutines that all encapsulations must provide !! !> Subroutine to set array to a scalare  value. subroutine ndarray_setval ( this , val , flags ) class ( ndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine ndarray_setval !> Subroutine to copy an array subroutine ndarray_copy ( this , src , flags ) class ( ndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( ndarray ) this % flatarray = src % flatarray class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_copy !> Subroutine to pack an array into a flat array for sending subroutine ndarray_pack ( this , z , flags ) class ( ndarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags z = this % flatarray end subroutine ndarray_pack !> Subroutine to unpack a flatarray after receiving subroutine ndarray_unpack ( this , z , flags ) class ( ndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags this % flatarray = z end subroutine ndarray_unpack !> Subroutine to define the norm of the array (here the max norm) function ndarray_norm ( this , flags ) result ( norm ) class ( ndarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function ndarray_norm !> Subroutine to compute y = a x + y where a is a scalar and x and y are arrays subroutine ndarray_axpy ( this , a , x , flags ) class ( ndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( ndarray ) this % flatarray = a * x % flatarray + this % flatarray class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_axpy !>  Subroutine to print the array to the screen (mainly for debugging purposes) subroutine ndarray_eprint ( this , flags ) class ( ndarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values if ( product ( this % shape ) < 10 ) then print * , this % flatarray else print * , this % flatarray ( 1 : 10 ) endif end subroutine ndarray_eprint !>  Helper function to return the array part function get_array1d ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) select type ( x ) type is ( ndarray ) r => x % flatarray end select end function get_array1d function get_array2d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( ndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % flatarray end select end function get_array2d function get_array3d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( ndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % flatarray end select end function get_array3d end module pf_mod_ndarray","tags":"","loc":"sourcefile/pf_ndarray.f90.html","title":"pf_ndarray.f90 – LibPFASST"},{"text":"Storing results for eventual output This file depends on sourcefile~~pf_results.f90~~EfferentGraph sourcefile~pf_results.f90 pf_results.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_results.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_results.f90->sourcefile~pf_utils.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_results.f90~~AfferentGraph sourcefile~pf_results.f90 pf_results.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_results.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_results.f90 sourcefile~pfasst.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 sourcefile~pf_parallel.f90->sourcefile~pf_results.f90 sourcefile~pf_parallel.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_comm.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_results Source Code pf_results.f90 Source Code !! Storing results for eventual output ! ! This file is part of LIBPFASST. ! !>  Module for the storing results for eventual output module pf_mod_results use pf_mod_dtype use pf_mod_utils implicit none contains subroutine initialize_results ( this , nsteps_in , niters_in , nprocs_in , nsweeps_in , rank_in , lev_ind ) class ( pf_results_t ), intent ( inout ) :: this integer , intent ( in ) :: nsteps_in , niters_in , nprocs_in , nsweeps_in , rank_in , lev_ind character ( len = 25 ) :: fname !!  output file name for residuals integer :: istat !  Set up the directory to dump results istat = system ( 'mkdir -p dat' ) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in initialize_results\" ) if ( rank_in == 0 ) then write ( fname , \"(A20,I0.1,A4)\" ) 'dat/residuals_size_L' , lev_ind , '.dat' open ( unit = 123 , file = fname , form = 'formatted' ) write ( 123 , '(I5, I5, I5, I5)' ) nsteps_in , niters_in , nprocs_in , nsweeps_in close ( unit = 123 ) end if this % dump => dump_results this % destroy => destroy_results this % nsteps = nsteps_in this % nblocks = nsteps_in / nprocs_in this % niters = niters_in this % nprocs = nprocs_in this % nsweeps = nsweeps_in this % rank = rank_in this % level = lev_ind if (. not . allocated ( this % errors )) allocate ( this % errors ( niters_in , this % nblocks , nsweeps_in )) if (. not . allocated ( this % residuals )) allocate ( this % residuals ( niters_in , this % nblocks , nsweeps_in )) this % errors = 0.0_pfdp this % residuals = 0.0_pfdp end subroutine initialize_results subroutine dump_results ( this ) type ( pf_results_t ), intent ( inout ) :: this integer :: i , j , k character ( len = 32 ) :: fname_r !!  output file name for residuals character ( len = 25 ) :: fname_t !!  output file name for runtimes character ( len = 21 ) :: fname_e !!  output file name errors integer :: istat istat = system ( 'mkdir -p dat/residuals' ) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in initialize_results\" ) write ( fname_r , \"(A19,I0.3,A5,I0.1,A4)\" ) 'dat/residuals/Proc_' , this % rank , '_Lev_' , this % level , '.dat' !    write (fname_e, \"(A10,I0.3,A1,I0.3,A4)\") 'dat/errors_',  this%rank,'_',this%level,'.dat' !  output residuals open ( 100 + this % rank , file = fname_r , form = 'formatted' ) do j = 1 , this % nblocks do i = 1 , this % niters do k = 1 , this % nsweeps write ( 100 + this % rank , '(I4, I4, I4, e21.14)' ) j , i , k , this % residuals ( i , j , k ) end do end do enddo close ( 100 + this % rank ) end subroutine dump_results subroutine dump_timings ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf character ( len = 25 ) :: fname !!  output file name for runtimes integer :: istat , j , istream istat = system ( 'mkdir -p dat/runtimes' ) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in dump_timings\" ) write ( fname , \"(A18,I0.3,A4)\" ) 'dat/runtimes/Proc_' , pf % rank , '.dat' istream = 200 + pf % rank !  Use processor dependent file number !  output timings open ( istream , file = fname , form = 'formatted' ) do j = 1 , 100 if ( pf % runtimes ( j ) > 0.0d0 ) then write ( istream , '(a16,  f23.8)' ) timer_names ( j ), pf % runtimes ( j ) end if end do close ( istream ) end subroutine dump_timings subroutine destroy_results ( this ) type ( pf_results_t ), intent ( inout ) :: this if ( allocated ( this % errors )) deallocate ( this % errors ) if ( allocated ( this % residuals )) deallocate ( this % residuals ) end subroutine destroy_results end module pf_mod_results","tags":"","loc":"sourcefile/pf_results.f90.html","title":"pf_results.f90 – LibPFASST"},{"text":"Interpolation operators This file depends on sourcefile~~pf_interpolate.f90~~EfferentGraph sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_utils.f90 sourcefile~pf_restrict.f90 pf_restrict.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_restrict.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_restrict.f90->sourcefile~pf_timer.f90 sourcefile~pf_restrict.f90->sourcefile~pf_dtype.f90 sourcefile~pf_restrict.f90->sourcefile~pf_hooks.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 var pansourcefilepf_interpolatef90EfferentGraph = svgPanZoom('#sourcefilepf_interpolatef90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_interpolate.f90~~AfferentGraph sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pf_parallel.f90->sourcefile~pf_interpolate.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_interpolate Source Code pf_interpolate.f90 Source Code !! Interpolation operators ! ! This file is part of LIBPFASST. ! !> Module to do interpolation between pfasst levels module pf_mod_interpolate use pf_mod_dtype use pf_mod_restrict use pf_mod_timer use pf_mod_hooks use pf_mod_utils implicit none contains !> Subroutine to interpolate (in time and space) level_index-1 to level_index !! Interpolation is done by interpolating increments. !! The fine function values are re-evaluated after interpolation. subroutine interpolate_time_space ( pf , t0 , dt , level_index , F_INTERP , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! main pfasst structure real ( pfdp ), intent ( in ) :: t0 !! time at beginning of time interval real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ) :: level_index !! defines which level to interpolate to logical , intent ( in ) :: F_INTERP !!  Flag, if true, then do interp on f not sol integer , optional , intent ( in ) :: flags !  Local variables class ( pf_level_t ), pointer :: c_lev_ptr !  Pointer to coarse level class ( pf_level_t ), pointer :: f_lev_ptr !  Pointer to fine level integer :: m , p , step real ( pfdp ), allocatable :: c_times (:) ! coarse level node times real ( pfdp ), allocatable :: f_times (:) ! fine level node times class ( pf_encap_t ), allocatable :: c_delta (:) !  Coarse in time and space class ( pf_encap_t ), allocatable :: cf_delta (:) !  Coarse in time but fine in space f_lev_ptr => pf % levels ( level_index ) ! fine level c_lev_ptr => pf % levels ( level_index - 1 ) ! coarse level call call_hooks ( pf , level_index , PF_PRE_INTERP_ALL ) call start_timer ( pf , TINTERPOLATE + level_index - 1 ) step = pf % state % step + 1 !> create workspaces call c_lev_ptr % ulevel % factory % create_array ( c_delta , c_lev_ptr % nnodes , c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % create_array ( cf_delta , c_lev_ptr % nnodes , f_lev_ptr % index , f_lev_ptr % shape ) !> set time at coarse and fine nodes allocate ( c_times ( c_lev_ptr % nnodes )) allocate ( f_times ( f_lev_ptr % nnodes )) c_times = t0 + dt * c_lev_ptr % nodes f_times = t0 + dt * f_lev_ptr % nodes do m = 1 , c_lev_ptr % nnodes call c_delta ( m )% setval ( 0.0_pfdp , flags ) call cf_delta ( m )% setval ( 0.0_pfdp , flags ) end do !>  interpolate coarse level correction in space only do m = 1 , c_lev_ptr % nnodes call c_delta ( m )% copy ( c_lev_ptr % Q ( m ), flags ) call c_delta ( m )% axpy ( - 1.0_pfdp , c_lev_ptr % pQ ( m ), flags ) call f_lev_ptr % ulevel % interpolate ( f_lev_ptr , c_lev_ptr , cf_delta ( m ), c_delta ( m ), c_times ( m ), flags ) end do !> interpolate corrections in time call pf_apply_mat ( f_lev_ptr % Q , 1.0_pfdp , f_lev_ptr % tmat , cf_delta , . false ., flags ) !> either interpolate function values or recompute them if ( F_INTERP ) then !  Interpolating F do p = 1 , size ( c_lev_ptr % F ( 1 ,:)) do m = 1 , c_lev_ptr % nnodes call c_delta ( m )% setval ( 0.0_pfdp , flags ) call cf_delta ( m )% setval ( 0.0_pfdp , flags ) end do ! interpolate coarse corrections  in space do m = 1 , c_lev_ptr % nnodes call c_delta ( m )% copy ( c_lev_ptr % F ( m , p ), flags ) call c_delta ( m )% axpy ( - 1.0_pfdp , c_lev_ptr % pF ( m , p ), flags ) call f_lev_ptr % ulevel % interpolate ( f_lev_ptr , c_lev_ptr , cf_delta ( m ), c_delta ( m ), c_times ( m ), flags ) end do ! interpolate corrections  in time call pf_apply_mat ( f_lev_ptr % F (:, p ), 1.0_pfdp , f_lev_ptr % tmat , cf_delta , . false ., flags ) end do !  Loop on npieces else ! recompute function values call f_lev_ptr % ulevel % sweeper % evaluate_all ( f_lev_ptr , f_times , flags = flags , step = step ) end if !  Feval !>  reset qend so that it is up to date !  This block moved to controllers !         if (present(flags)) then !           if ((flags .eq. 0) .or. (flags .eq. 1))  call f_lev_ptr%qend%copy(f_lev_ptr%Q(f_lev_ptr%nnodes), flags=1) !           if (flags .eq. 2)  call f_lev_ptr%q0%copy(f_lev_ptr%Q(1), flags=2) !         else !           call f_lev_ptr%qend%copy(f_lev_ptr%Q(f_lev_ptr%nnodes)) !         end if !> destroy local data structures call c_lev_ptr % ulevel % factory % destroy_array ( c_delta , c_lev_ptr % nnodes , & c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % destroy_array ( cf_delta , c_lev_ptr % nnodes , & f_lev_ptr % index , f_lev_ptr % shape ) call end_timer ( pf , TINTERPOLATE + f_lev_ptr % index - 1 ) call call_hooks ( pf , f_lev_ptr % index , PF_POST_INTERP_ALL ) end subroutine interpolate_time_space !>  Subroutine to update the fine initial condition from coarse increment by spatial interpolation subroutine interpolate_q0 ( pf , f_lev_ptr , c_lev_ptr , flags ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: f_lev_ptr !!  fine level class ( pf_level_t ), intent ( inout ) :: c_lev_ptr !!  coarse level integer , optional , intent ( in ) :: flags !!  optional: specify component on which to operate !   here flags more or less is logical, if it is present we operate on component 1 !   of the ndarray-type class ( pf_encap_t ), allocatable :: c_delta !!  coarse correction class ( pf_encap_t ), allocatable :: f_delta !!  fine correction call call_hooks ( pf , f_lev_ptr % index , PF_PRE_INTERP_Q0 ) call start_timer ( pf , TINTERPOLATE + f_lev_ptr % index - 1 ) !> create local workspace call c_lev_ptr % ulevel % factory % create_single ( c_delta , c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % create_single ( f_delta , f_lev_ptr % index , f_lev_ptr % shape ) call c_delta % setval ( 0.0_pfdp , flags ) call f_delta % setval ( 0.0_pfdp , flags ) !>  restrict fine initial data to coarse call f_lev_ptr % ulevel % restrict ( f_lev_ptr , c_lev_ptr , f_lev_ptr % q0 , c_delta , pf % state % t0 , flags ) !>  get coarse level correction call c_delta % axpy ( - 1.0_pfdp , c_lev_ptr % q0 , flags ) !>  interpolate correction in space call f_lev_ptr % ulevel % interpolate ( f_lev_ptr , c_lev_ptr , f_delta , c_delta , pf % state % t0 , flags ) !> update fine inital condition call f_lev_ptr % q0 % axpy ( - 1.0_pfdp , f_delta , flags ) call end_timer ( pf , TINTERPOLATE + f_lev_ptr % index - 1 ) call call_hooks ( pf , f_lev_ptr % index , PF_POST_INTERP_Q0 ) !> destroy local workspace call c_lev_ptr % ulevel % factory % destroy_single ( c_delta , c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % destroy_single ( f_delta , f_lev_ptr % index , f_lev_ptr % shape ) end subroutine interpolate_q0 !>  Subroutine to update the fine terminal condition from coarse increment by spatial interpolation !>  used for adjoint solver subroutine interpolate_qend ( pf , f_lev_ptr , c_lev_ptr ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: f_lev_ptr !!  fine level class ( pf_level_t ), intent ( inout ) :: c_lev_ptr !!  coarse level class ( pf_encap_t ), allocatable :: c_delta !!  coarse correction class ( pf_encap_t ), allocatable :: f_delta !!  fine correction call call_hooks ( pf , f_lev_ptr % index , PF_PRE_INTERP_Q0 ) call start_timer ( pf , TINTERPOLATE + f_lev_ptr % index - 1 ) !> create local workspace call c_lev_ptr % ulevel % factory % create_single ( c_delta , c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % create_single ( f_delta , f_lev_ptr % index , f_lev_ptr % shape ) call c_delta % setval ( 0.0_pfdp ) call f_delta % setval ( 0.0_pfdp ) !>  restrict fine initial data to coarse call f_lev_ptr % ulevel % restrict ( f_lev_ptr , c_lev_ptr , f_lev_ptr % qend , c_delta , pf % state % t0 , flags = 2 ) !>  get coarse level correction call c_delta % axpy ( - 1.0_pfdp , c_lev_ptr % qend , flags = 2 ) !>  interpolate correction in space call f_lev_ptr % ulevel % interpolate ( f_lev_ptr , c_lev_ptr , f_delta , c_delta , pf % state % t0 , flags = 2 ) !> update fine inital condition call f_lev_ptr % qend % axpy ( - 1.0_pfdp , f_delta , flags = 2 ) call end_timer ( pf , TINTERPOLATE + f_lev_ptr % index - 1 ) call call_hooks ( pf , f_lev_ptr % index , PF_POST_INTERP_Q0 ) !> destroy local workspace call c_lev_ptr % ulevel % factory % destroy_single ( c_delta , c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % destroy_single ( f_delta , f_lev_ptr % index , f_lev_ptr % shape ) end subroutine interpolate_qend end module pf_mod_interpolate","tags":"","loc":"sourcefile/pf_interpolate.f90.html","title":"pf_interpolate.f90 – LibPFASST"},{"text":"N-dimensional complex array encapsulation. This file depends on sourcefile~~pf_zndarray.f90~~EfferentGraph sourcefile~pf_zndarray.f90 pf_zndarray.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_zndarray.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_zndarray.f90->sourcefile~pf_utils.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_zndarray Source Code pf_zndarray.f90 Source Code !!  N-dimensional complex array encapsulation. ! ! This file is part of LIBPFASST. ! !> N-dimensional complex array encapsulation. !! !! When a new solution is created by a PFASST level, this encapsulation !! uses the levels 'shape' attribute to create a new array with that !! shape.  Thus, the 'shape' attributes of the PFASST levels should be !! set appropriately.  For example, before calling pf_pfasst_run we can !! set the shape of the coarsest level by doing: !! !!   allocate(pf%levels(1)%shape(2)) !!   pf%levels(1)%shape = [ 3, 10 ] !! !! The helper routines array1, array2, array3, etc can be used to !! extract pointers to the encapsulated array  without !! performing any copies. !! module pf_mod_zndarray use iso_c_binding use pf_mod_dtype use pf_mod_utils implicit none type , extends ( pf_factory_t ) :: zndarray_factory contains procedure :: create_single => zndarray_create_single procedure :: create_array => zndarray_create_array procedure :: destroy_single => zndarray_destroy_single procedure :: destroy_array => zndarray_destroy_array end type zndarray_factory type , extends ( pf_encap_t ) :: zndarray integer :: dim integer , allocatable :: shape (:) complex ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => zndarray_setval procedure :: copy => zndarray_copy procedure :: norm => zndarray_norm procedure :: pack => zndarray_pack procedure :: unpack => zndarray_unpack procedure :: axpy => zndarray_axpy procedure :: eprint => zndarray_eprint procedure :: write_to_disk end type zndarray contains function cast_as_zndarray ( encap_polymorph ) result ( zndarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( zndarray ), pointer :: zndarray_obj select type ( encap_polymorph ) type is ( zndarray ) zndarray_obj => encap_polymorph end select end function cast_as_zndarray !> Allocates complex ndarray subroutine zndarray_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) type ( zndarray ), pointer :: zndarray_obj select type ( q ) class is ( zndarray ) allocate ( q % shape ( size ( shape ))) allocate ( q % flatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape q % flatarray = cmplx ( 0.0 , 0.0 , pfdp ) end select nullify ( zndarray_obj ) end subroutine zndarray_build subroutine zndarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( zndarray ), pointer :: zndarray_obj zndarray_obj => cast_as_zndarray ( encap ) deallocate ( zndarray_obj % shape ) deallocate ( zndarray_obj % flatarray ) nullify ( zndarray_obj ) end subroutine zndarray_destroy !> Wrapper routine for allocation of a single zndarray type array subroutine zndarray_create_single ( this , x , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( zndarray :: x ) call zndarray_build ( x , shape ) end subroutine zndarray_create_single !> Wrapper routine for looped allocation of many zndarray type arrays subroutine zndarray_create_array ( this , x , n , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( zndarray :: x ( n )) do i = 1 , n call zndarray_build ( x ( i ), shape ) end do end subroutine zndarray_create_array subroutine zndarray_destroy_single ( this , x , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) select type ( x ) class is ( zndarray ) deallocate ( x % shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine zndarray_destroy_single !> Wrapper routine for looped allocation of many zndarray type arrays subroutine zndarray_destroy_array ( this , x , n , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i select type ( x ) class is ( zndarray ) do i = 1 , n deallocate ( x ( i )% shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine zndarray_destroy_array !> Set solution value. subroutine zndarray_setval ( this , val , flags ) class ( zndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags complex ( pfdp ) :: zval zval = cmplx ( val , 0.0 , pfdp ) this % flatarray = zval end subroutine zndarray_setval !> Copy solution value. subroutine zndarray_copy ( this , src , flags ) class ( zndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags class ( zndarray ), pointer :: zndarray_src zndarray_src => cast_as_zndarray ( src ) this % flatarray = zndarray_src % flatarray end subroutine zndarray_copy !> Pack solution q into a flat array. subroutine zndarray_pack ( this , z , flags ) class ( zndarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: i do i = 1 , product ( this % shape ) z ( 2 * i - 1 ) = real ( this % flatarray ( i )) z ( 2 * i ) = aimag ( this % flatarray ( i )) end do end subroutine zndarray_pack ! Unpack solution from a flat array. subroutine zndarray_unpack ( this , z , flags ) class ( zndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: i do i = 1 , product ( this % shape ) this % flatarray ( i ) = cmplx ( z ( 2 * i - 1 ), z ( 2 * i ), pfdp ) enddo end subroutine zndarray_unpack ! Compute norm of solution function zndarray_norm ( this , flags ) result ( norm ) class ( zndarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function zndarray_norm ! Compute y = a x + y where a is a scalar and x and y are solutions. subroutine zndarray_axpy ( this , a , x , flags ) class ( zndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags class ( zndarray ), pointer :: zndarray_obj zndarray_obj => cast_as_zndarray ( x ) this % flatarray = a * zndarray_obj % flatarray + this % flatarray end subroutine zndarray_axpy subroutine zndarray_eprint ( this , flags ) class ( zndarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags print * , this % flatarray ( 1 : 10 ) end subroutine zndarray_eprint subroutine write_to_disk ( this , filename ) class ( zndarray ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename open ( unit = 1 , file = trim ( filename ), form = 'unformatted' ) write ( 1 ) this % flatarray close ( 1 ) end subroutine write_to_disk !>  Helper function to return the array part function get_array1d ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:) select type ( x ) type is ( zndarray ) r => x % flatarray end select end function get_array1d function get_array2d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( zndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % flatarray end select end function get_array2d function get_array3d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( zndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % flatarray end select end function get_array3d end module pf_mod_zndarray","tags":"","loc":"sourcefile/pf_zndarray.f90.html","title":"pf_zndarray.f90 – LibPFASST"},{"text":"Runge-Kutta time steppers This file depends on sourcefile~~pf_rkstepper.f90~~EfferentGraph sourcefile~pf_rkstepper.f90 pf_rkstepper.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_rkstepper Source Code pf_rkstepper.f90 Source Code !!  Runge-Kutta time steppers ! ! This file is part of LIBPFASST. ! !>  Module to do Runge-Kutta stepping module pf_mod_rkstepper use pf_mod_dtype use pf_mod_utils implicit none !>  IMEX or additive or semi-implicit Runge-Kutta stepper  type type , extends ( pf_stepper_t ), abstract :: pf_ark_t real ( pfdp ), allocatable :: AmatI (:,:) real ( pfdp ), allocatable :: AmatE (:,:) real ( pfdp ), allocatable :: cvec (:) real ( pfdp ), allocatable :: bvecI (:) real ( pfdp ), allocatable :: bvecE (:) real ( pfdp ), allocatable :: QtilI (:,:) logical :: explicit = . true . logical :: implicit = . true . integer :: nstages contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: do_n_steps => ark_do_n_steps procedure :: initialize => ark_initialize procedure :: destroy => ark_destroy end type pf_ark_t interface subroutine pf_f_eval_p ( this , y , t , level_index , f , piece ) import pf_ark_t , pf_encap_t , pfdp class ( pf_ark_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( inout ) :: f integer , intent ( in ) :: piece end subroutine pf_f_eval_p subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece ) import pf_ark_t , pf_encap_t , pfdp class ( pf_ark_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: dtq class ( pf_encap_t ), intent ( in ) :: rhs integer , intent ( in ) :: level_index class ( pf_encap_t ), intent ( inout ) :: f integer , intent ( in ) :: piece end subroutine pf_f_comp_p end interface contains !> Perform N steps of ark on level level_index and set qend appropriately. subroutine ark_do_n_steps ( this , pf , level_index , t0 , big_dt , nsteps_rk ) use pf_mod_timer use pf_mod_hooks class ( pf_ark_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 !!  Time at start of time interval real ( pfdp ), intent ( in ) :: big_dt !!  Size of time interval to integrato on integer , intent ( in ) :: level_index !!  Level of the index to step on integer , intent ( in ) :: nsteps_rk !!  Number of steps to use class ( pf_level_t ), pointer :: lev !!  Pointer to level level_index class ( pf_encap_t ), allocatable :: rhs !!  Accumulated right hand side for implicit solves integer :: j , m , n !!  Loop counters real ( pfdp ) :: t !!  Time real ( pfdp ) :: dt !!  Size of each ark step lev => pf % levels ( level_index ) !! Assign pointer to appropriate level dt = big_dt / real ( nsteps_rk , pfdp ) ! Set the internal time step size based on the number of rk steps ! Allocate space for the right-hand side call lev % ulevel % factory % create_single ( rhs , lev % index , lev % shape ) do n = 1 , nsteps_rk ! Loop over time steps ! Recompute the first explicit function value if ( n == 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) else call lev % Q ( 1 )% copy ( lev % Q ( lev % nnodes )) end if ! this assumes that cvec(1) == 0 if ( this % explicit ) & call this % f_eval ( lev % Q ( 1 ), t0 + dt * ( n - 1 ) + dt * this % cvec ( 1 ), lev % index , lev % F ( 1 , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( lev % Q ( 1 ), t0 + dt * ( n - 1 ) + dt * this % cvec ( 1 ), lev % index , lev % F ( 1 , 2 ), 2 ) ! Loop over stage values do m = 1 , this % nstages - 1 ! Set current time t = t0 + dt * ( n - 1 ) + dt * this % cvec ( m + 1 ) ! Initialize the right-hand size for each stage call rhs % copy ( lev % Q ( 1 )) do j = 1 , m ! Add explicit rhs if ( this % explicit ) & call rhs % axpy ( dt * this % AmatE ( m + 1 , j ), lev % F ( j , 1 )) ! Add implicit rhs if ( this % implicit ) & call rhs % axpy ( dt * this % AmatI ( m + 1 , j ), lev % F ( j , 2 )) end do ! Solve the implicit system if ( this % implicit . and . this % AmatI ( m + 1 , m + 1 ) /= 0 ) then call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % AmatI ( m + 1 , m + 1 ), rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) else call lev % Q ( m + 1 )% copy ( rhs ) end if ! Reevaluate explicit rhs with the new solution if ( this % explicit ) & call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) end do ! End loop over stage values ! Compute final value using quadrature rule call lev % Q ( lev % nnodes )% copy ( lev % Q ( 1 )) ! Loop over stage values one more time do j = 1 , this % nstages ! Add explicit terms if ( this % explicit ) & call lev % Q ( lev % nnodes )% axpy ( dt * this % bvecE ( j ), lev % F ( j , 1 )) ! Add implicit terms if ( this % implicit ) & call lev % Q ( lev % nnodes )% axpy ( dt * this % bvecI ( j ), lev % F ( j , 2 )) end do ! End loop over stage values end do ! End Loop over time steps ! Assign final value to end of time step call lev % qend % copy ( lev % Q ( lev % nnodes )) end subroutine ark_do_n_steps subroutine ark_initialize ( this , lev ) class ( pf_ark_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev integer :: nstages real ( pfdp ) :: gamma , delta this % explicit = . true . this % implicit = . true . if ( this % order == 2 ) then !  Ascher-Ruuth-Spiteri nstages = 3 this % nstages = nstages allocate ( this % AmatE ( nstages , nstages )) !  Explicit Butcher matrix allocate ( this % AmatI ( nstages , nstages )) !  Implicit Butcher matrix allocate ( this % cvec ( nstages )) !  stage times allocate ( this % bvecE ( nstages )) !  quadrature weights on explicit allocate ( this % bvecI ( nstages )) !  quadrature weights on implicit this % AmatE = 0.0_pfdp this % AmatI = 0.0_pfdp this % bvecE = 0.0_pfdp this % bvecI = 0.0_pfdp this % cvec = 0.0_pfdp gamma = ( TWO - sqrt ( TWO )) / TWO delta = - TWO * sqrt ( TWO ) / THREE this % AmatE ( 2 , 1 ) = gamma this % AmatE ( 3 , 1 ) = delta this % AmatE ( 3 , 2 ) = ONE - delta this % AmatI ( 2 , 2 ) = gamma this % AmatI ( 3 , 2 ) = ONE - gamma this % AmatI ( 3 , 3 ) = gamma this % cvec = ( / ZERO , gamma , ONE / ) this % bvecE = ( / ZERO , ONE - gamma , gamma / ) this % bvecI = this % bvecE else if ( this % order == 3 ) then ! Third-order Kennedy-Carpenter nstages = 4 this % nstages = nstages allocate ( this % AmatE ( nstages , nstages )) !  Explicit Butcher matrix allocate ( this % AmatI ( nstages , nstages )) !  Implicit Butcher matrix allocate ( this % cvec ( nstages )) !  stage times allocate ( this % bvecE ( nstages )) !  quadrature weights on explicit allocate ( this % bvecI ( nstages )) !  quadrature weights on implicit this % AmatE = 0.0_pfdp this % AmatI = 0.0_pfdp this % bvecE = 0.0_pfdp this % bvecI = 0.0_pfdp this % cvec = 0.0_pfdp this % AmatE ( 2 , 1 ) = 176773220590 3.0_pfdp / 202783664111 8.0_pfdp this % AmatE ( 3 , 1 ) = 553582888582 5.0_pfdp / 1049269177363 7.0_pfdp this % AmatE ( 3 , 2 ) = 78802234243 7.0_pfdp / 1088263485894 0.0_pfdp this % AmatE ( 4 , 1 ) = 648598928062 9.0_pfdp / 1625170173562 2.0_pfdp this % AmatE ( 4 , 2 ) = - 424626684708 9.0_pfdp / 970447391861 9.0_pfdp this % AmatE ( 4 , 3 ) = 1075544844929 2.0_pfdp / 1035709742484 1.0_pfdp this % AmatI ( 2 , 1 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 2 , 2 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 3 , 1 ) = 274623878971 9.0_pfdp / 1065886856070 8.0_pfdp this % AmatI ( 3 , 2 ) = - 64016744523 7.0_pfdp / 684562943199 7.0_pfdp this % AmatI ( 3 , 3 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 4 , 1 ) = 147126639957 9.0_pfdp / 784085678865 4.0_pfdp this % AmatI ( 4 , 2 ) = - 448244416785 8.0_pfdp / 752975506669 7.0_pfdp this % AmatI ( 4 , 3 ) = 1126623926642 8.0_pfdp / 1159328672282 1.0_pfdp this % AmatI ( 4 , 4 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % cvec = ( / 0.0_pfdp , 176773220590 3.0_pfdp / 202783664111 8.0_pfdp , 3.0_pfdp / 5.0_pfdp , 1.0_pfdp / ) this % bvecE = ( / 147126639957 9.0_pfdp / 784085678865 4.0_pfdp , - 448244416785 8.0_pfdp / 752975506669 7.0_pfdp ,& 1126623926642 8.0_pfdp / 1159328672282 1.0_pfdp , 176773220590 3.0_pfdp / 405567328223 6.0_pfdp / ) this % bvecI = this % bvecE else if ( this % order == 4 ) then ! Fourth-order Kennedy-Carpenter nstages = 6 this % nstages = nstages allocate ( this % AmatE ( nstages , nstages )) !  Explicit Butcher matrix allocate ( this % AmatI ( nstages , nstages )) !  Implicit Butcher matrix allocate ( this % cvec ( nstages )) !  stage times allocate ( this % bvecE ( nstages )) !  quadrature weights on explicit allocate ( this % bvecI ( nstages )) !  quadrature weights on implicit this % AmatE = 0.0_pfdp this % AmatI = 0.0_pfdp this % bvecE = 0.0_pfdp this % bvecI = 0.0_pfdp this % cvec = 0.0_pfdp this % AmatE ( 2 , 1 ) = 0.5_pfdp this % AmatE ( 3 , 1 ) = 1386 1.0_pfdp / 6250 0.0_pfdp this % AmatE ( 3 , 2 ) = 688 9.0_pfdp / 6250 0.0_pfdp this % AmatE ( 4 , 1 ) = - 11692331627 5.0_pfdp / 239368406146 8.0_pfdp this % AmatE ( 4 , 2 ) = - 273121846731 7.0_pfdp / 1536804210183 1.0_pfdp this % AmatE ( 4 , 3 ) = 940804670208 9.0_pfdp / 1111317113920 9.0_pfdp this % AmatE ( 5 , 1 ) = - 45108634878 8.0_pfdp / 290242868990 9.0_pfdp this % AmatE ( 5 , 2 ) = - 268234879257 2.0_pfdp / 751979568189 7.0_pfdp this % AmatE ( 5 , 3 ) = 1266286877508 2.0_pfdp / 1196047911538 3.0_pfdp this % AmatE ( 5 , 4 ) = 335581797596 5.0_pfdp / 1106085150927 1.0_pfdp this % AmatE ( 6 , 1 ) = 64784517918 8.0_pfdp / 321632005775 1.0_pfdp this % AmatE ( 6 , 2 ) = 7328151925 0.0_pfdp / 838263948453 3.0_pfdp this % AmatE ( 6 , 3 ) = 55253951339 1.0_pfdp / 345466838623 3.0_pfdp this % AmatE ( 6 , 4 ) = 335451267163 9.0_pfdp / 830676392457 3.0_pfdp this % AmatE ( 6 , 5 ) = 404 0.0_pfdp / 1787 1.0_pfdp this % AmatI ( 2 , 1 ) = 0.25_pfdp this % AmatI ( 2 , 2 ) = 0.25_pfdp this % AmatI ( 3 , 1 ) = 861 1.0_pfdp / 6250 0.0_pfdp this % AmatI ( 3 , 2 ) = - 174 3.0_pfdp / 3125 0.0_pfdp this % AmatI ( 3 , 3 ) = 0.25_pfdp this % AmatI ( 4 , 1 ) = 501202 9.0_pfdp / 3465250 0.0_pfdp this % AmatI ( 4 , 2 ) = - 65444 1.0_pfdp / 292250 0.0_pfdp this % AmatI ( 4 , 3 ) = 17437 5.0_pfdp / 38810 8.0_pfdp this % AmatI ( 4 , 4 ) = 0.25_pfdp this % AmatI ( 5 , 1 ) = 1526708280 9.0_pfdp / 15537626560 0.0_pfdp this % AmatI ( 5 , 2 ) = - 7144340 1.0_pfdp / 12077440 0.0_pfdp this % AmatI ( 5 , 3 ) = 73087887 5.0_pfdp / 90218476 8.0_pfdp this % AmatI ( 5 , 4 ) = 228539 5.0_pfdp / 807091 2.0_pfdp this % AmatI ( 5 , 5 ) = 0.25_pfdp this % AmatI ( 6 , 1 ) = 8288 9.0_pfdp / 52489 2.0_pfdp this % AmatI ( 6 , 2 ) = 0.0_pfdp this % AmatI ( 6 , 3 ) = 1562 5.0_pfdp / 8366 4.0_pfdp this % AmatI ( 6 , 4 ) = 6987 5.0_pfdp / 10267 2.0_pfdp this % AmatI ( 6 , 5 ) = - 226 0.0_pfdp / 821 1.0_pfdp this % AmatI ( 6 , 6 ) = 0.25_pfdp this % cvec = ( / 0.0_pfdp , 0.5_pfdp , 8 3.0_pfdp / 25 0.0_pfdp , & 3 1.0_pfdp / 5 0.0_pfdp , 1 7.0_pfdp / 2 0.0_pfdp , 1.0_pfdp / ) this % bvecE = ( / 8288 9.0_pfdp / 52489 2.0_pfdp , 0.0_pfdp , 1562 5.0_pfdp / 8366 4.0_pfdp , & 6987 5.0_pfdp / 10267 2.0_pfdp , - 226 0.0_pfdp / 821 1.0_pfdp , 0.25_pfdp / ) this % bvecI = this % bvecE else stop \"ark_initialize: This RK order is not supported\" end if if ( lev % nnodes < this % nstages + 1 ) & stop \"ark_initialize: With RK, lev%nnodes should be equal to rkstepper%nstages + 1\" end subroutine ark_initialize subroutine ark_destroy ( this , lev ) class ( pf_ark_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % AmatE ) deallocate ( this % AmatI ) deallocate ( this % bvecE ) deallocate ( this % bvecI ) deallocate ( this % cvec ) end subroutine ark_destroy end module pf_mod_rkstepper","tags":"","loc":"sourcefile/pf_rkstepper.f90.html","title":"pf_rkstepper.f90 – LibPFASST"},{"text":"Timing routines This file depends on sourcefile~~pf_timer.f90~~EfferentGraph sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_timer.f90~~AfferentGraph sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_imexq.f90 pf_imexQ.f90 sourcefile~pf_imexq.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_imexq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_imexq.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_imexq.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_amisdcq.f90 pf_amisdcQ.f90 sourcefile~pf_amisdcq.f90->sourcefile~pf_timer.f90 sourcefile~pf_amisdc.f90 pf_amisdc.f90 sourcefile~pf_amisdcq.f90->sourcefile~pf_amisdc.f90 sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_timer.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_hooks.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_utils.f90 sourcefile~pf_restrict.f90 pf_restrict.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_restrict.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pf_parallel.f90->sourcefile~pf_timer.f90 sourcefile~pf_parallel.f90->sourcefile~pf_hooks.f90 sourcefile~pf_parallel.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_parallel.f90->sourcefile~pf_utils.f90 sourcefile~pf_parallel.f90->sourcefile~pf_restrict.f90 sourcefile~pf_results.f90 pf_results.f90 sourcefile~pf_parallel.f90->sourcefile~pf_results.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_parallel.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_timer.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_imk.f90 pf_imk.f90 sourcefile~pf_imk.f90->sourcefile~pf_timer.f90 sourcefile~pf_imk.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imk.f90->sourcefile~pf_utils.f90 sourcefile~pf_misdcq_oc.f90 pf_misdcQ_oc.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_restrict.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_comm.f90 sourcefile~pf_imex.f90 pf_imex.f90 sourcefile~pf_imex.f90->sourcefile~pf_timer.f90 sourcefile~pf_imex.f90->sourcefile~pf_utils.f90 sourcefile~pf_expq.f90 pf_expQ.f90 sourcefile~pf_expq.f90->sourcefile~pf_timer.f90 sourcefile~pf_expq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_expq.f90->sourcefile~pf_utils.f90 sourcefile~pf_exp.f90 pf_exp.f90 sourcefile~pf_exp.f90->sourcefile~pf_timer.f90 sourcefile~pf_exp.f90->sourcefile~pf_hooks.f90 sourcefile~pf_exp.f90->sourcefile~pf_utils.f90 sourcefile~pf_verlet.f90 pf_verlet.f90 sourcefile~pf_verlet.f90->sourcefile~pf_timer.f90 sourcefile~pf_verlet.f90->sourcefile~pf_hooks.f90 sourcefile~pf_verlet.f90->sourcefile~pf_utils.f90 sourcefile~pf_misdcq.f90 pf_misdcQ.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_timer.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_utils.f90 sourcefile~pf_imexq_oc.f90 pf_imexQ_oc.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_restrict.f90->sourcefile~pf_timer.f90 sourcefile~pf_restrict.f90->sourcefile~pf_hooks.f90 sourcefile~pf_misdc.f90 pf_misdc.f90 sourcefile~pf_misdc.f90->sourcefile~pf_timer.f90 sourcefile~pf_misdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_rkstepper.f90 pf_rkstepper.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_timer.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_hooks.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_utils.f90 sourcefile~pf_magnus_picard.f90 pf_magnus_picard.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_timer.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_hooks.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_utils.f90 sourcefile~pf_fftw.f90 pf_fftw.f90 sourcefile~pf_fftw.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90->sourcefile~pf_utils.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_utils.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_fftpack.f90 pf_fftpack.f90 sourcefile~pf_fftpack.f90->sourcefile~pf_utils.f90 sourcefile~pf_zndarray.f90 pf_zndarray.f90 sourcefile~pf_zndarray.f90->sourcefile~pf_utils.f90 sourcefile~pf_ndarray.f90 pf_ndarray.f90 sourcefile~pf_ndarray.f90->sourcefile~pf_utils.f90 sourcefile~pf_ndarray-oc.f90 pf_ndarray-oc.f90 sourcefile~pf_ndarray-oc.f90->sourcefile~pf_utils.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_imexq.f90 sourcefile~pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 sourcefile~pfasst.f90->sourcefile~pf_results.f90 sourcefile~pfasst.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 var pansourcefilepf_timerf90AfferentGraph = svgPanZoom('#sourcefilepf_timerf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_timer Source Code pf_timer.f90 Source Code !!  Timing routines ! ! This file is part of LIBPFASST. ! !> Module for setting timers module pf_mod_timer use pf_mod_dtype use pf_mod_mpi implicit none !  List of timers integer , parameter :: & TTOTAL = 1 , & TPREDICTOR = 2 , & TITERATION = 3 , & THOOKS = 4 , & TSTEP = 5 , & TRESIDUAL = 6 , & TBROADCAST = 7 , & TINTERPOLATE = 10 , & TRESTRICT = 20 , & TRECEIVE = 30 , & TSEND = 40 , & TLEVEL = 50 , & TAUX = 60 ! if you add more timers here, make sure to update the timer arrays in pf_dtype.f90 character ( len = 14 ), parameter :: timer_names ( 62 ) = ( / & 'total       ' , & ! 1 'predictor   ' , & 'iteration   ' , & 'hooks       ' , & 'step        ' , & ! 5 'residual    ' , & 'broadcast   ' , & '8           ' , & '9           ' , & 'interpL1    ' , & ! 10 'interpL2    ' , & 'interpL3    ' , & 'interpL4    ' , & 'interpL5    ' , & 'interpL6    ' , & 'interpL7    ' , & 'interpL8    ' , & 'interpL9    ' , & 'interpL10   ' , & 'restrictL1  ' , & ! 20 'restrictL2  ' , & 'restrictL3  ' , & 'restrictL4  ' , & 'restrictL5  ' , & 'restrictL6  ' , & 'restrictL7  ' , & 'restrictL8  ' , & 'restrictL9  ' , & 'restrictL10 ' , & 'recvL1      ' , & ! 30 'recvL2      ' , & 'recvL3      ' , & 'recvL4      ' , & 'recvL5      ' , & 'recvL6      ' , & 'recvL7      ' , & 'recvL8      ' , & 'recvL9      ' , & 'recvL10     ' , & 'sendL1      ' , & ! 40 'sendL2      ' , & 'sendL3      ' , & 'sendL4      ' , & 'sendL5      ' , & 'sendL6      ' , & 'sendL7      ' , & 'sendL8      ' , & 'sendL9      ' , & 'sendL10     ' , & 'sweepL1     ' , & ! 50 'sweepL2     ' , & 'sweepL3     ' , & 'sweepL4     ' , & 'sweepL5     ' , & 'sweepL6     ' , & 'sweepL7     ' , & 'sweepL8     ' , & 'sweepL9     ' , & 'sweepL10    ' , & 'exp         ' , & ! 60 'omega       ' , & 'feval       ' / ) contains !>  Subroutine to start a timer subroutine start_timer ( pf , timer ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: timer pf % timers ( timer ) = MPI_Wtime () end subroutine start_timer !>  Subroutine to stop a timer subroutine end_timer ( pf , timer ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: timer double precision :: t t = MPI_Wtime () pf % runtimes ( timer ) = pf % runtimes ( timer ) + t - pf % timers ( timer ) if ( pf % echo_timings ) then write ( * , '(\"timer:\",a16,\", rank: \",i3,\", step: \",i4, \", level: \", i3,' & // '\", iter: \",i3, f23.8,f23.8,f23.8)' ) & timer_names ( timer ), pf % rank , & pf % state % step , pf % state % level , pf % state % iter , & t - pf % timers ( timer ), pf % runtimes ( timer ), t - pf % timers ( TTOTAL ) end if end subroutine end_timer end module pf_mod_timer","tags":"","loc":"sourcefile/pf_timer.f90.html","title":"pf_timer.f90 – LibPFASST"},{"text":"Data types and interfaces Files dependent on this one sourcefile~~pf_dtype.f90~~AfferentGraph sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_restrict.f90 pf_restrict.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_restrict.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_comm.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_dtype.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_timer.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_hooks.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_utils.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_restrict.f90 sourcefile~pf_misdc.f90 pf_misdc.f90 sourcefile~pf_misdc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_misdc.f90->sourcefile~pf_timer.f90 sourcefile~pf_misdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_imk.f90 pf_imk.f90 sourcefile~pf_imk.f90->sourcefile~pf_dtype.f90 sourcefile~pf_imk.f90->sourcefile~pf_timer.f90 sourcefile~pf_imk.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imk.f90->sourcefile~pf_utils.f90 sourcefile~pf_imex.f90 pf_imex.f90 sourcefile~pf_imex.f90->sourcefile~pf_dtype.f90 sourcefile~pf_imex.f90->sourcefile~pf_timer.f90 sourcefile~pf_imex.f90->sourcefile~pf_utils.f90 sourcefile~pf_ndsysarray.f90 pf_ndsysarray.f90 sourcefile~pf_ndsysarray.f90->sourcefile~pf_dtype.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_dtype.f90 sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90 pf_results.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_mpi.f90 sourcefile~pf_fftpack.f90 pf_fftpack.f90 sourcefile~pf_fftpack.f90->sourcefile~pf_dtype.f90 sourcefile~pf_fftpack.f90->sourcefile~pf_utils.f90 sourcefile~pf_ndarray.f90 pf_ndarray.f90 sourcefile~pf_ndarray.f90->sourcefile~pf_dtype.f90 sourcefile~pf_ndarray.f90->sourcefile~pf_utils.f90 sourcefile~pf_zndsysarray.f90 pf_zndsysarray.f90 sourcefile~pf_zndsysarray.f90->sourcefile~pf_dtype.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_dtype.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_magnus_picard.f90 pf_magnus_picard.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_dtype.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_timer.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_hooks.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_misdcq_oc.f90 pf_misdcQ_oc.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_exp.f90 pf_exp.f90 sourcefile~pf_exp.f90->sourcefile~pf_dtype.f90 sourcefile~pf_exp.f90->sourcefile~pf_timer.f90 sourcefile~pf_exp.f90->sourcefile~pf_hooks.f90 sourcefile~pf_exp.f90->sourcefile~pf_utils.f90 sourcefile~pf_verlet.f90 pf_verlet.f90 sourcefile~pf_verlet.f90->sourcefile~pf_dtype.f90 sourcefile~pf_verlet.f90->sourcefile~pf_timer.f90 sourcefile~pf_verlet.f90->sourcefile~pf_hooks.f90 sourcefile~pf_verlet.f90->sourcefile~pf_utils.f90 sourcefile~pf_zndarray.f90 pf_zndarray.f90 sourcefile~pf_zndarray.f90->sourcefile~pf_dtype.f90 sourcefile~pf_zndarray.f90->sourcefile~pf_utils.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_dtype.f90 sourcefile~pfasst.f90->sourcefile~pf_pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 sourcefile~pf_imexq.f90 pf_imexQ.f90 sourcefile~pfasst.f90->sourcefile~pf_imexq.f90 sourcefile~pfasst.f90->sourcefile~pf_results.f90 sourcefile~pfasst.f90->sourcefile~pf_mpi.f90 sourcefile~pf_rkstepper.f90 pf_rkstepper.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_dtype.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_timer.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_hooks.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_utils.f90 sourcefile~pf_fftw.f90 pf_fftw.f90 sourcefile~pf_fftw.f90->sourcefile~pf_dtype.f90 sourcefile~pf_fftw.f90->sourcefile~pf_utils.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_parallel.f90->sourcefile~pf_dtype.f90 sourcefile~pf_parallel.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_parallel.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel.f90->sourcefile~pf_timer.f90 sourcefile~pf_parallel.f90->sourcefile~pf_hooks.f90 sourcefile~pf_parallel.f90->sourcefile~pf_utils.f90 sourcefile~pf_parallel.f90->sourcefile~pf_restrict.f90 sourcefile~pf_parallel.f90->sourcefile~pf_results.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 sourcefile~pf_expq.f90 pf_expQ.f90 sourcefile~pf_expq.f90->sourcefile~pf_dtype.f90 sourcefile~pf_expq.f90->sourcefile~pf_timer.f90 sourcefile~pf_expq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_expq.f90->sourcefile~pf_utils.f90 sourcefile~pf_misdcq.f90 pf_misdcQ.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_dtype.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_timer.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_utils.f90 sourcefile~pf_restrict.f90->sourcefile~pf_dtype.f90 sourcefile~pf_restrict.f90->sourcefile~pf_timer.f90 sourcefile~pf_restrict.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imexq.f90->sourcefile~pf_dtype.f90 sourcefile~pf_imexq.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_imexq.f90->sourcefile~pf_timer.f90 sourcefile~pf_imexq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imexq.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90->sourcefile~pf_dtype.f90 sourcefile~pf_results.f90->sourcefile~pf_utils.f90 sourcefile~pf_amisdc.f90 pf_amisdc.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_timer.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 sourcefile~pf_imexq_oc.f90 pf_imexQ_oc.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_ndarray-oc.f90 pf_ndarray-oc.f90 sourcefile~pf_ndarray-oc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_ndarray-oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_amisdcq.f90 pf_amisdcQ.f90 sourcefile~pf_amisdcq.f90->sourcefile~pf_timer.f90 sourcefile~pf_amisdcq.f90->sourcefile~pf_amisdc.f90 var pansourcefilepf_dtypef90AfferentGraph = svgPanZoom('#sourcefilepf_dtypef90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_dtype Source Code pf_dtype.f90 Source Code !!  Data types and interfaces ! ! This file is part of LIBPFASST. ! !>  Module to define the main parameters, data types, and interfaces in pfasst module pf_mod_dtype use iso_c_binding implicit none !>  static pfasst paramters integer , parameter :: pfdp = selected_real_kind ( 15 , 307 ) !!  Defines double precision type for all real and complex variables !  integer, parameter :: pfdp = selected_real_kind(33, 4931)  !! For quad precision everywhere (use at your risk and see top of pf_mpi.f90) integer , parameter :: pfqp = selected_real_kind ( 33 , 4931 ) !!  Defines quad precision type for all real and complex variables real ( pfdp ), parameter :: ZERO = 0.0_pfdp real ( pfdp ), parameter :: ONE = 1.0_pfdp real ( pfdp ), parameter :: TWO = 2.0_pfdp real ( pfdp ), parameter :: THREE = 3.0_pfdp real ( pfdp ), parameter :: HALF = 0.5_pfdp integer , parameter :: PF_MAXLEVS = 4 integer , parameter :: PF_MAX_HOOKS = 32 !> Quadrature node varieties integer , parameter :: SDC_GAUSS_LOBATTO = 1 integer , parameter :: SDC_GAUSS_RADAU = 2 integer , parameter :: SDC_CLENSHAW_CURTIS = 3 integer , parameter :: SDC_UNIFORM = 4 integer , parameter :: SDC_GAUSS_LEGENDRE = 5 integer , parameter :: SDC_CHEBYSHEV = 6 !> States of operation integer , parameter :: PF_STATUS_ITERATING = 1 integer , parameter :: PF_STATUS_CONVERGED = 2 integer , parameter :: PF_STATUS_PREDICTOR = 3 !>  The type that holds the state of the system type , bind ( c ) :: pf_state_t real ( pfdp ) :: t0 !!  Time at beginning of this time step real ( pfdp ) :: dt !!  Time step size integer :: nsteps !! total number of time steps integer :: pfblock !! pfasst block being worked on integer :: iter !! current iteration number integer :: step !! current time step number assigned to processor integer :: level !! which level is currently being operated on integer :: hook !! which hook integer :: proc !! which processor integer :: sweep !! sweep number integer :: status !! status (iterating, converged etc) integer :: pstatus !! previous rank's status integer :: itcnt !! total iterations by this processor integer :: skippedy !! skipped sweeps for state (for mixed integration) integer :: mysteps !! steps I did end type pf_state_t !>  Abstract hook type: hooks call diagnostic routines from various places in code type :: pf_hook_t procedure ( pf_hook_p ), pointer , nopass :: proc end type pf_hook_t !>  The abstract SDC sweeper type (must be extended) type , abstract :: pf_sweeper_t integer :: npieces logical :: use_LUq contains procedure ( pf_sweep_p ), deferred :: sweep procedure ( pf_initialize_p ), deferred :: initialize procedure ( pf_evaluate_p ), deferred :: evaluate procedure ( pf_integrate_p ), deferred :: integrate procedure ( pf_evaluate_all_p ), deferred :: evaluate_all procedure ( pf_residual_p ), deferred :: residual procedure ( pf_spreadq0_p ), deferred :: spreadq0 procedure ( pf_destroy_p ), deferred :: destroy end type pf_sweeper_t !>  The abstract time stepper type (must be extended) type , abstract :: pf_stepper_t integer :: npieces integer :: order contains procedure ( pf_do_n_steps_p ), deferred :: do_n_steps procedure ( pf_initialize_stepper_p ), deferred :: initialize procedure ( pf_destroy_stepper_p ), deferred :: destroy end type pf_stepper_t !>  The abstract data type of the solution (must be extended) type , abstract :: pf_encap_t contains procedure ( pf_encap_setval_p ), deferred :: setval procedure ( pf_encap_copy_p ), deferred :: copy procedure ( pf_encap_norm_p ), deferred :: norm procedure ( pf_encap_pack_p ), deferred :: pack procedure ( pf_encap_unpack_p ), deferred :: unpack procedure ( pf_encap_axpy_p ), deferred :: axpy procedure ( pf_encap_eprint_p ), deferred :: eprint end type pf_encap_t !>  Abstract type for creation and destruction of objects type , abstract :: pf_factory_t contains procedure ( pf_encap_create_single_p ), deferred :: create_single procedure ( pf_encap_create_array_p ), deferred :: create_array procedure ( pf_encap_destroy_single_p ), deferred :: destroy_single procedure ( pf_encap_destroy_array_p ), deferred :: destroy_array end type pf_factory_t !>  The absract definition of level which is inherited  to include problem dependent stuff type , abstract :: pf_user_level_t class ( pf_factory_t ), allocatable :: factory class ( pf_sweeper_t ), allocatable :: sweeper class ( pf_stepper_t ), allocatable :: stepper contains procedure ( pf_transfer_p ), deferred :: restrict procedure ( pf_transfer_p ), deferred :: interpolate end type pf_user_level_t !>  The type to store quadrature matrices type :: pf_sdcmats_t integer :: nnodes !  Number of nodes integer :: qtype !  Type of nodes real ( pfdp ), allocatable :: qnodes (:) !  The quadrature nodes real ( pfdp ), allocatable :: Qmat (:,:) !  Collocation matrix real ( pfdp ), allocatable :: QmatFE (:,:) !  Forward Euler matrix real ( pfdp ), allocatable :: QmatBE (:,:) !  Backward Euler matrix real ( pfdp ), allocatable :: QmatTrap (:,:) ! Trapezoid rule matrix real ( pfdp ), allocatable :: QmatVer (:,:) ! Verlet Matrix real ( pfdp ), allocatable :: QmatLU (:,:) !  LU of Wmat real ( pfdp ), allocatable :: s0mat (:,:) !  deprecated logical :: use_proper_nodes = . false . !  If true use gauss nodes in coarsening logical :: use_composite_nodes = . false . ! If true, finer nodes are composite logical :: use_no_left_q = . false . ! If true don't use left endpoint in rule end type pf_sdcmats_t !>  Data type of a PFASST level type :: pf_level_t !  level parameters set by the pfasst_t values integer :: index = - 1 !! level number (1 is the coarsest) integer :: nnodes = - 1 !! number of sdc nodes integer :: nsteps_rk = - 1 !! number of rk steps to perform integer :: nsweeps = - 1 !! number of sdc sweeps to perform integer :: nsweeps_pred = - 1 !! number of coarse sdc sweeps to perform predictor in predictor logical :: Finterp = . false . !! interpolate functions instead of solutions !  Mandatory level parameter integer :: mpibuflen = - 1 !! size of solution in pfdp units !  Diagnostics real ( pfdp ) :: error !! holds the user defined error real ( pfdp ) :: residual !! holds the user defined residual real ( pfdp ) :: residual_rel !! holds the user defined relative residual (scaled by solution magnitude) class ( pf_user_level_t ), allocatable :: ulevel !!  user customized level info !>  Simple data storage at each level real ( pfdp ), allocatable :: & send (:), & !! send buffer recv (:), & !! recv buffer nodes (:), & !! list of SDC nodes rmat (:,:), & !! time restriction matrix tmat (:,:) !! time interpolation matrix integer , allocatable :: & nflags (:) !! sdc node flags !>  Solution variable storage class ( pf_encap_t ), allocatable :: & Q (:), & !! solution at sdc nodes pQ (:), & !! unknowns at sdc nodes, previous sweep R (:), & !! full residuals I (:), & !! 0 to node integrals Fflt (:), & !! functions values at sdc nodes (flat) tauQ (:), & !! fas correction in Q form pFflt (:), & !! functions at sdc nodes, previous sweep (flat) q0 , & !! initial condition qend !! solution at end time !>  Function  storage class ( pf_encap_t ), pointer :: & F (:,:), & !! functions values at sdc nodes pF (:,:) !! functions at sdc nodes, previous sweep integer , allocatable :: shape (:) !! user defined shape array type ( pf_sdcmats_t ), allocatable :: sdcmats logical :: allocated = . false . end type pf_level_t !>  Data type to define the communicator type :: pf_comm_t integer :: nproc = - 1 ! total number of processors integer :: comm = - 1 ! communicator integer , pointer :: & recvreq (:), & ! receive requests (indexed by level) sendreq (:) ! send requests (indexed by level) integer :: statreq ! status send request ! fakie, needs modernization type ( c_ptr ), pointer :: pfs (:) ! pfasst objects (indexed by rank) type ( c_ptr ), pointer :: pfpth (:,:) !> Procedure interfaces procedure ( pf_post_p ), pointer , nopass :: post procedure ( pf_recv_p ), pointer , nopass :: recv procedure ( pf_recv_status_p ), pointer , nopass :: recv_status procedure ( pf_send_p ), pointer , nopass :: send procedure ( pf_send_status_p ), pointer , nopass :: send_status procedure ( pf_wait_p ), pointer , nopass :: wait procedure ( pf_broadcast_p ), pointer , nopass :: broadcast end type pf_comm_t !>  Type for storing results for later output type :: pf_results_t real ( pfdp ), allocatable :: errors (:,:,:) real ( pfdp ), allocatable :: residuals (:,:,:) integer :: nsteps integer :: niters integer :: nprocs integer :: p_index integer :: nblocks integer :: nsweeps integer :: rank integer :: level procedure ( pf_results_p ), pointer , nopass :: dump procedure ( pf_results_p ), pointer , nopass :: destroy end type pf_results_t !>  The main PFASST data type which includes pretty much everythingl type :: pf_pfasst_t !>  Mandatory parameters (must be set on command line or input file) integer :: nlevels = - 1 !! number of pfasst levels !>  Optional parameters integer :: niters = 5 !! number of PFASST iterations to do integer :: qtype = SDC_GAUSS_LOBATTO !! type of nodes logical :: use_proper_nodes = . false . logical :: use_composite_nodes = . false . logical :: use_no_left_q = . false . ! --  level dependent parameters integer :: nsweeps ( PF_MAXLEVS ) = 1 !!  number of sweeps at each levels integer :: nsweeps_pred ( PF_MAXLEVS ) = 1 !!  number of sweeps during predictor integer :: nnodes ( PF_MAXLEVS ) = 3 !! number of nodes ! --  tolerances real ( pfdp ) :: abs_res_tol = 0.d0 !!  absolute convergence tolerance real ( pfdp ) :: rel_res_tol = 0.d0 !!  relative convergence tolerance ! --  predictor options  (should be set before pfasst_run is called) logical :: PFASST_pred = . true . !!  true if the PFASST type predictor is used logical :: pipeline_pred = . false . !!  true if coarse sweeps after burn in are pipelined  (if nsweeps_pred>1 on coarse level) integer :: nsweeps_burn = 1 !!  number of sdc sweeps to perform during coarse level burn in integer :: q0_style = 0 !!  q0 can take 3 values !!  0:  Only the q0 at t=0 is valid  (default) !!  1:  The q0 at each processor is valid !!  2:  q0 and all nodes at each processor is valid ! --  run options  (should be set before pfasst_run is called) logical :: Vcycle = . true . !!  decides if Vcycles are done logical :: Finterp = . false . !!  True if transfer functions operate on rhs logical :: use_LUq = . true . !!  True if LU type implicit matrix is used integer :: taui0 = - 999999 !! iteration cutoff for tau inclusion !> RK and Parareal options logical :: use_rk_stepper = . false . !! decides if RK steps are used instead of the sweeps integer :: nsteps_rk ( PF_MAXLEVS ) = 3 !! number of runge-kutta nodes logical :: RK_pred = . false . !!  true if the coarse level is initialized with Runge-Kutta instead of PFASST ! -- misc logical :: debug = . false . !!  If true, debug diagnostics are printed logical :: save_residuals = . false . !!  If true, residuals are saved and output logical :: save_timings = . false . !!  If true, timings are saved and  output logical :: echo_timings = . false . !!  If true, timings are  output to screen logical :: save_errors = . false . !!  If true, errors  are saved and output integer :: rank = - 1 !! rank of current processor !> pf objects type ( pf_state_t ), allocatable :: state !!  Describes where in the algorithm proc is type ( pf_level_t ), allocatable :: levels (:) !! Holds the levels type ( pf_comm_t ), pointer :: comm !! Points to communicator type ( pf_results_t ), allocatable :: results (:) !!  Hold results for each level !> hooks variables type ( pf_hook_t ), allocatable :: hooks (:,:,:) !!  Holds the hooks integer , allocatable :: nhooks (:,:) !!  Holds the number hooks !> timing variables double precision :: timers ( 100 ) = 0.0d0 double precision :: runtimes ( 100 ) = 0.0d0 !> output directory character ( 512 ) :: outdir end type pf_pfasst_t !> Interfaces for subroutines interface !> hooks subroutines subroutine pf_hook_p ( pf , level , state ) use iso_c_binding import pf_pfasst_t , pf_level_t , pf_state_t type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level type ( pf_state_t ), intent ( in ) :: state end subroutine pf_hook_p !> SDC sweeper subroutines subroutine pf_sweep_p ( this , pf , level_index , t0 , dt , nsweeps , flags ) import pf_pfasst_t , pf_sweeper_t , pf_level_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: dt real ( pfdp ), intent ( in ) :: t0 integer , intent ( in ) :: level_index integer , intent ( in ) :: nsweeps integer , optional , intent ( in ) :: flags end subroutine pf_sweep_p subroutine pf_evaluate_p ( this , lev , t , m , flags , step ) import pf_sweeper_t , pf_level_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , optional , intent ( in ) :: flags , step end subroutine pf_evaluate_p subroutine pf_evaluate_all_p ( this , lev , t , flags , step ) import pf_sweeper_t , pf_level_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step end subroutine pf_evaluate_all_p subroutine pf_initialize_p ( this , lev ) import pf_sweeper_t , pf_level_t class ( pf_sweeper_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev end subroutine pf_initialize_p subroutine pf_destroy_sweeper_p ( this ) import pf_sweeper_t class ( pf_sweeper_t ), intent ( inout ) :: this end subroutine pf_destroy_sweeper_p subroutine pf_integrate_p ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) import pf_sweeper_t , pf_level_t , pf_encap_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt !!  Time step size class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags end subroutine pf_integrate_p subroutine pf_residual_p ( this , lev , dt , flags ) import pf_sweeper_t , pf_level_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: Lev real ( pfdp ), intent ( in ) :: dt !!  Time step size integer , optional , intent ( in ) :: flags end subroutine pf_residual_p subroutine pf_spreadq0_p ( this , lev , t0 , flags , step ) import pf_sweeper_t , pf_level_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: Lev real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of step; if flags == 2, time at end of step integer , optional , intent ( in ) :: flags , step end subroutine pf_spreadq0_p subroutine pf_destroy_p ( this , lev ) import pf_sweeper_t , pf_level_t , pfdp class ( pf_sweeper_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: Lev end subroutine pf_destroy_p !>  time stepper interfaces subroutine pf_do_n_steps_p ( this , pf , level_index , t0 , big_dt , nsteps_rk ) import pf_pfasst_t , pf_stepper_t , pf_level_t , pfdp class ( pf_stepper_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: big_dt !!  Time step size real ( pfdp ), intent ( in ) :: t0 integer , intent ( in ) :: level_index integer , intent ( in ) :: nsteps_rk end subroutine pf_do_n_steps_p subroutine pf_initialize_stepper_p ( this , lev ) import pf_stepper_t , pf_level_t class ( pf_stepper_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev end subroutine pf_initialize_stepper_p subroutine pf_destroy_stepper_p ( this , lev ) import pf_stepper_t , pf_level_t , pfdp class ( pf_stepper_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: Lev end subroutine pf_destroy_stepper_p !> transfer interfaces used for restriction and interpolation subroutine pf_transfer_p ( this , levelF , levelG , qF , qG , t , flags ) import pf_user_level_t , pf_level_t , pf_encap_t , pfdp class ( pf_user_level_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: levelF , levelG class ( pf_encap_t ), intent ( inout ) :: qF , qG real ( pfdp ), intent ( in ) :: t integer , optional , intent ( in ) :: flags end subroutine pf_transfer_p !> encapsulation interfaces subroutine pf_encap_create_single_p ( this , x , level , shape ) import pf_factory_t , pf_encap_t class ( pf_factory_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) end subroutine pf_encap_create_single_p subroutine pf_encap_create_array_p ( this , x , n , level , shape ) import pf_factory_t , pf_encap_t class ( pf_factory_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) end subroutine pf_encap_create_array_p subroutine pf_encap_destroy_single_p ( this , x , level , shape ) import pf_factory_t , pf_encap_t class ( pf_factory_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) end subroutine pf_encap_destroy_single_p subroutine pf_encap_destroy_array_p ( this , x , n , level , shape ) import pf_factory_t , pf_encap_t class ( pf_factory_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) end subroutine pf_encap_destroy_array_p subroutine pf_encap_setval_p ( this , val , flags ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags end subroutine pf_encap_setval_p subroutine pf_encap_copy_p ( this , src , flags ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags end subroutine pf_encap_copy_p function pf_encap_norm_p ( this , flags ) result ( norm ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm end function pf_encap_norm_p subroutine pf_encap_pack_p ( this , z , flags ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , optional , intent ( in ) :: flags end subroutine pf_encap_pack_p subroutine pf_encap_unpack_p ( this , z , flags ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , optional , intent ( in ) :: flags end subroutine pf_encap_unpack_p subroutine pf_encap_axpy_p ( this , a , x , flags ) import pf_encap_t , pfdp class ( pf_encap_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags end subroutine pf_encap_axpy_p subroutine pf_encap_eprint_p ( this , flags ) import pf_encap_t class ( pf_encap_t ), intent ( inout ) :: this integer , intent ( in ), optional :: flags end subroutine pf_encap_eprint_p !> communicator interfaces subroutine pf_post_p ( pf , level , tag , ierror , source ) import pf_pfasst_t , pf_level_t type ( pf_pfasst_t ), intent ( in ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag integer , intent ( inout ) :: ierror integer , intent ( in ) :: source end subroutine pf_post_p subroutine pf_recv_p ( pf , level , tag , blocking , ierror , source ) import pf_pfasst_t , pf_level_t type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , intent ( inout ) :: ierror integer , intent ( in ) :: source end subroutine pf_recv_p subroutine pf_recv_status_p ( pf , tag , istatus , ierror , source ) import pf_pfasst_t , pf_level_t type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , intent ( inout ) :: istatus integer , intent ( inout ) :: ierror integer , intent ( in ) :: source end subroutine pf_recv_status_p subroutine pf_send_p ( pf , level , tag , blocking , ierror , dest ) import pf_pfasst_t , pf_level_t type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , intent ( inout ) :: ierror integer , intent ( in ) :: dest end subroutine pf_send_p subroutine pf_send_status_p ( pf , tag , istatus , ierror , dest ) import pf_pfasst_t , pf_level_t type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , intent ( in ) :: istatus integer , intent ( inout ) :: ierror integer , intent ( in ) :: dest end subroutine pf_send_status_p subroutine pf_wait_p ( pf , level , ierror ) import pf_pfasst_t type ( pf_pfasst_t ), intent ( in ) :: pf integer , intent ( in ) :: level integer , intent ( inout ) :: ierror end subroutine pf_wait_p subroutine pf_broadcast_p ( pf , y , nvar , root , ierror ) import pf_pfasst_t , pfdp type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: nvar , root real ( pfdp ) , intent ( in ) :: y ( nvar ) integer , intent ( inout ) :: ierror end subroutine pf_broadcast_p subroutine pf_results_p ( this ) import pf_results_t type ( pf_results_t ), intent ( inout ) :: this end subroutine pf_results_p end interface end module pf_mod_dtype","tags":"","loc":"sourcefile/pf_dtype.f90.html","title":"pf_dtype.f90 – LibPFASST"},{"text":"Multi-implicit sweeper module This file depends on sourcefile~~pf_misdcq.f90~~EfferentGraph sourcefile~pf_misdcq.f90 pf_misdcQ.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_misdcQ Source Code pf_misdcQ.f90 Source Code !! Multi-implicit sweeper module ! ! This file is part of LIBPFASST. ! !>  Module of the  the derived sweeper class for doing MISDC sweeps for an equation of the form !!            y' = f_1(y) + f_2(y) + f_3(y)  !!  The f_1 piece is treated explicitly and f_2 and f_3 implicitly !!  Afer this sweeper is initialized (usually in main), the locgical flags can be changed if desired module pf_mod_misdcQ use pf_mod_dtype use pf_mod_utils implicit none !>  Multi-implicit SDC sweeper type, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_misdcQ_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) real ( pfdp ), allocatable :: dtsdc (:) class ( pf_encap_t ), allocatable :: I3 (:) class ( pf_encap_t ), allocatable :: rhs contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdcQ_sweep procedure :: initialize => misdcQ_initialize procedure :: integrate => misdcQ_integrate procedure :: residual => misdcQ_residual procedure :: spreadq0 => misdcQ_spreadq0 procedure :: evaluate_all => misdcQ_evaluate_all procedure :: evaluate => misdcQ_evaluate procedure :: destroy => misdcQ_destroy procedure :: misdcQ_destroy end type pf_misdcQ_t interface !>  This is the interface for the routine to compute the RHS function values !>  Evaluate f_piece(y), where piece is one or two subroutine pf_f_eval_p ( this , y , t , level_index , f , piece ) !>  Evaluate f_piece(y), where piece is one or two import pf_misdcQ_t , pf_encap_t , pfdp class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y !!  Argument for evaluation real ( pfdp ), intent ( in ) :: t !!  Time at evaluation integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  RHS function value integer , intent ( in ) :: piece !!  Which piece to evaluate end subroutine pf_f_eval_p !>  Solve the equation y - dtq*f_n(y) =rhs  where n is given by the argument piece subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece ) import pf_misdcQ_t , pf_encap_t , pfdp class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Solution of implicit solve real ( pfdp ), intent ( in ) :: t !!  Time of solve real ( pfdp ), intent ( in ) :: dtq !!  dt*quadrature weight class ( pf_encap_t ), intent ( in ) :: rhs !!  RHS for solve integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  f_n of solution y integer , intent ( in ) :: piece !!  Which piece to evaluate end subroutine pf_f_comp_p end interface contains ! Perform on SDC sweep on level lev and set qend appropriately. subroutine misdcQ_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev integer :: m , n , k real ( pfdp ) :: t call start_timer ( pf , TLEVEL + lev % index - 1 ) lev => pf % levels ( level_index ) !!  Assign level pointer do k = 1 , nsweeps !!  Loop over sweeps call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) call this % I3 ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 )) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( m , n ), lev % F ( n , 3 )) call this % I3 ( m )% axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 )) !  Note we have to leave off the -dt*Qtil here and put it in after f2comp end do if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do ! do the time-stepping if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 ) endif t = t0 do m = 1 , lev % nnodes - 1 t = t + dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m )) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 )) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( Lev % Q ( m + 1 )) do n = 1 , m call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m )) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 3 ), 3 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 ) end do call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine misdcQ_sweep ! Initialize matrices subroutine misdcQ_initialize ( this , lev ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , n , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) ! S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) ! S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) ! S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) ! S-BE allocate ( this % dtsdc ( nnodes - 1 )) this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp !>  Array of substep sizes this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) !>  Make space for extra integration piece call lev % ulevel % factory % create_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) end subroutine misdcQ_initialize subroutine misdcQ_destroy ( this , lev ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( this % rhs , lev % index , lev % shape ) end subroutine misdcQ_destroy ! Compute SDC integral subroutine misdcQ_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine misdcQ_integrate !> Subroutine to evaluate function value at node m subroutine misdcQ_evaluate ( this , lev , t , m , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 ) end subroutine misdcQ_evaluate !> Subroutine to evaluate the function values at all nodes subroutine misdcQ_evaluate_all ( this , lev , t , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine misdcQ_evaluate_all !> Subroutine to compute  Residual subroutine misdcQ_residual ( this , lev , dt , flags ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags call pf_generic_residual ( this , lev , dt ) end subroutine misdcQ_residual subroutine misdcQ_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine misdcQ_spreadq0 end module pf_mod_misdcQ","tags":"","loc":"sourcefile/pf_misdcq.f90.html","title":"pf_misdcQ.f90 – LibPFASST"},{"text":"Main controllers for optimal control problems This file depends on sourcefile~~pf_parallel_oc.f90~~EfferentGraph sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_comm.f90 sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_restrict.f90 pf_restrict.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_restrict.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_hooks.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_utils.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_timer.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_dtype.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_restrict.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_utils.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_dtype.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_mpi.f90 sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_results.f90 pf_results.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_restrict.f90->sourcefile~pf_hooks.f90 sourcefile~pf_restrict.f90->sourcefile~pf_timer.f90 sourcefile~pf_restrict.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_dtype.f90 sourcefile~pf_results.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90->sourcefile~pf_dtype.f90 var pansourcefilepf_parallel_ocf90EfferentGraph = svgPanZoom('#sourcefilepf_parallel_ocf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_parallel_oc Source Code pf_parallel_oc.f90 Source Code !!  Main controllers for optimal control problems ! ! This file is part of LIBPFASST. ! !> Module of parallel PFASST routines for optimal control problems. module pf_mod_parallel_oc use pf_mod_pfasst use pf_mod_interpolate use pf_mod_restrict use pf_mod_utils use pf_mod_timer use pf_mod_dtype use pf_mod_hooks use pf_mod_comm implicit none contains subroutine pf_predictor_oc ( pf , t0 , dt , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! PFASST main data structure real ( pfdp ), intent ( in ) :: t0 !! Initial time of this processor real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ), optional :: flags (:) !!  User defined flags class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p integer :: k !!  Loop indices integer :: level_index !!  Local variable for looping over levels real ( pfdp ) :: t0k !!  Initial time at time step k integer :: which , dir , send_tag , burnin_sweeps , my_coarse_sweeps which = 1 ! standard: predict and sweep forward-in-time dir = 1 ! for MPI communication, standard is forward-in-time if ( present ( flags )) then if ( flags ( 1 ) == 2 ) then which = 2 ! if we are computing an adjoint, predict and sweep backward-in-time dir = 2 ! communication has to be backwards as well end if if ( flags ( 1 ) == 0 ) which = 0 ! sweep forward and backward simultaneously on two components, communication only forwards end if call call_hooks ( pf , 1 , PF_PRE_PREDICTOR ) call start_timer ( pf , TPREDICTOR ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'beginning predictor' !! Step 1. Getting the  initial condition on the finest level at each processor !!         If we are doing multiple levels, then we need to coarsen to fine level f_lev_p => pf % levels ( pf % nlevels ) if ( pf % q0_style < 2 ) then !  Spread q0 to all the nodes if ( ( which == 0 ) . or . ( which == 1 )) call f_lev_p % ulevel % sweeper % spreadq0 ( f_lev_p , t0 , 1 , pf % state % step + 1 ) if ( ( which == 0 ) . or . ( which == 2 )) call f_lev_p % ulevel % sweeper % spreadq0 ( f_lev_p , t0 + dt , 2 , pf % state % step + 1 ) endif !!  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do coarsen  in predictor' if ( pf % nlevels > 1 ) then do level_index = pf % nlevels , 2 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call pf_residual ( pf , f_lev_p , dt , which ) if ( ( which == 0 ) . or . ( which == 1 )) & call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % q0 , c_lev_p % q0 , t0 , flags = 1 ) if ( ( which == 0 ) . or . ( which == 2 )) & call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % qend , c_lev_p % qend , t0 + dt , flags = 2 ) call restrict_time_space_fas ( pf , t0 , dt , level_index , flags = which ) !  Restrict call save ( c_lev_p , which ) end do !  level_index = pf%nlevels, 2, -1 end if level_index = 1 c_lev_p => pf % levels ( 1 ) if ( pf % q0_style < 3 ) then ! Step 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent !         (this is skipped if the fine initial conditions are already consistent) ! The first processor does nothing, the second does one set of sweeps, the 2nd two, etc ! Hence, this is skipped completely if nprocs=1 if ( pf % q0_style . eq . 0 ) then !  The coarse level needs burn in if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do burnin in pred' , ' RK_pred' , pf % RK_pred , ' PFASST_pred' , pf % PFASST_pred !! If RK_pred is true, just do some RK_steps if ( pf % RK_pred . or . which == 2 ) then !  Use Runge-Kutta to get the coarse initial data !  Get new initial conditions call pf_recv ( pf , c_lev_p , 100000 + pf % rank , . true ., dir ) !  Do a RK_step call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 , which ) !  Send forward/backward if ( dir == 1 ) send_tag = 100000 + pf % rank + 1 if ( dir == 2 ) send_tag = 100000 + pf % rank - 1 call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) else !  Normal PFASST burn in burnin_sweeps = pf % rank + 1 if ( which == 2 ) then if ( pf % rank == 0 ) & print * , 'WARNING --- normal PFASST burn in is not suitable for adjoint as rhs cannot be evaluated for [t0k, t0k+dt]' burnin_sweeps = pf % comm % nproc - pf % rank end if if ( pf % debug ) print * , 'DEBUG ---' , pf % rank , 'which = ' , which , 'burnin_sweeps = ' , burnin_sweeps do k = 1 , burnin_sweeps !pf%rank + 1 pf % state % iter = - k t0k = t0 - ( pf % rank ) * dt + ( k - 1 ) * dt ! Remember t0=pf%rank*dt is the beginning of this time slice so t0-(pf%rank)*dt is 0 ! and we iterate up to the correct time step. ! for optimal control problem t, t0k has no influence on f_eval, so there this does something else if ( which == 2 ) t0k = t0 + ( burnin_sweeps - 1 ) * dt - ( k - 1 ) * dt if ( pf % debug ) print * , 'DEBUG ----' , pf % rank , 't0k = ' , t0k ! Get new initial value (skip on first iteration) if ( k > 1 ) then if (( which == 0 ) . or . ( which == 1 )) call c_lev_p % q0 % copy ( c_lev_p % qend , 1 ) !                 if ((which == 0) .or. (which == 2)) call c_lev_p%qend%copy(c_lev_p%q0, 2) ! for which==0, we solve with zero terminal conditions, ! but q0,2 is not zero (source term due to state sweeps) if ( which == 2 ) call c_lev_p % qend % copy ( c_lev_p % q0 , 2 ) ! If we are doing PFASST_pred, we use the old values at nodes, otherwise spread q0 if (. not . pf % PFASST_pred ) then if ( ( which == 0 ) . or . ( which == 1 )) call c_lev_p % ulevel % sweeper % spreadq0 ( c_lev_p , t0k , 1 , pf % state % step + 1 ) !                    if( (which == 0) .or. (which == 2)) call c_lev_p%ulevel%sweeper%spreadq0(c_lev_p, t0k+dt, 2, pf%state%step+1) if ( which == 2 ) call c_lev_p % ulevel % sweeper % spreadq0 ( c_lev_p , t0k + dt , 2 , pf % state % step + 1 ) end if end if !  Do some sweeps if ( which == 0 . or . which == 1 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn , 1 ) ! was: 1 not which if ( which == 2 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn , 2 ) end do endif !  RK_pred end if ! (q0_style .eq. 0) if ( pf % q0_style > 0 ) then my_coarse_sweeps = pf % rank + 1 ! for warm start do pipelining if ( which == 2 ) my_coarse_sweeps = pf % comm % nproc - pf % rank else my_coarse_sweeps = c_lev_p % nsweeps_pred end if ! Step 4: Now we have everyone burned in, so do some coarse sweeps ! Modification: each processor does sweeps according to its rank if ( pf % nlevels > 1 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do sweeps  in predictor' , ' Pipeline_pred' , pf % Pipeline_pred level_index = 1 c_lev_p => pf % levels ( level_index ) if ( pf % Pipeline_pred ) then do k = 1 , my_coarse_sweeps !c_lev_p%nsweeps_pred pf % state % iter =- ( pf % rank + 1 ) - k !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + k , . true ., dir ) !  Do a sweep call c_lev_p % ulevel % sweeper % sweep ( pf , c_lev_p % index , t0 , dt , 1 , which ) !  Send forward/backward if ( dir == 1 ) send_tag = c_lev_p % index * 1110000 + pf % rank + 1 + k if ( dir == 2 ) send_tag = c_lev_p % index * 1110000 + pf % rank - 1 + k call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) end do ! k = 1, c_lev_p%nsweeps_pred-1 else !  Don't pipeline !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 100000 + pf % rank , . true ., dir ) !  Do sweeps !         if(which == 0 .or. which == 1) call c_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, c_lev_p%nsweeps_pred, 1) !1 ! why only state? if ( which == 0 . or . which == 1 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , my_coarse_sweeps , which ) !1 ! why only state? !         if(which == 2)                 call c_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, c_lev_p%nsweeps_pred, 2) !which if ( which == 2 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , my_coarse_sweeps , 2 ) !which !  Send forward/backward if ( dir == 1 ) send_tag = c_lev_p % index * 100000 + pf % rank + 1 if ( dir == 2 ) send_tag = c_lev_p % index * 100000 + pf % rank - 1 call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) endif ! (Pipeline_pred .eq. .true) then end if ! pf%nlevels > 1 !  Step 5:  Return to fine level sweeping on any level in between coarsest and finest if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'returning to fine level in predictor' do level_index = 2 , pf % nlevels !  Will do nothing with one level f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp , flags = which ) if (( which == 0 ) . or . ( which == 1 )) then call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 1 ) if ( pf % rank /= 0 ) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 1 ) end if if ( which == 2 ) then ! for which==0, qend never changes, so don't need to interpolate call f_lev_p % q0 % copy ( f_lev_p % Q ( 1 ), flags = 2 ) if ( pf % rank /= pf % comm % nproc - 1 ) call interpolate_qend ( pf , f_lev_p , c_lev_p ) end if !  Do sweeps on level unless we are at the finest level if ( level_index < pf % nlevels ) then if (( which == 0 ) . or . ( which == 1 )) & call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred , which ) !which was 1 if ( which == 2 ) & call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred , 2 ) end if end do end if call end_timer ( pf , TPREDICTOR ) call call_hooks ( pf , - 1 , PF_POST_PREDICTOR ) pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ending predictor' end subroutine pf_predictor_oc !> Subroutine to test residuals to determine if the current processor has converged. subroutine pf_check_residual_oc ( pf , residual_converged ) type ( pf_pfasst_t ), intent ( inout ) :: pf logical , intent ( out ) :: residual_converged !! Return true if residual is below tolerances residual_converged = . false . ! Check to see if relative tolerance is met if ( pf % levels ( pf % nlevels )% residual_rel < pf % rel_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , ' residual relative tol met' , pf % levels ( pf % nlevels )% residual_rel residual_converged = . true . end if ! Check to see if relative tolerance is met if ( pf % levels ( pf % nlevels )% residual < pf % abs_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( pf % nlevels )% residual residual_converged = . true . end if end subroutine pf_check_residual_oc !> !> Test residuals to determine if the current processor has converged, !> adapted to optimal control. Can probably be removed, when pf_pfasst_block_oc !> is changed to use pf_check_convergence of pf_check_convergence_old. !> !> Note that if the previous processor hasn't converged yet !> (pstatus), the current processor hasn't converged yet either, !> regardless of the residual. !> !   subroutine pf_check_convergence_oc(pf, k, residual,converged, flags) subroutine pf_check_convergence_oc ( pf , send_tag , flags ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: send_tag !     real(pfdp),        intent(inout) :: residual !     integer,           intent(in)    :: k !     logical,           intent(out)   :: converged   !!  True if this processor is done integer , optional , intent ( in ) :: flags !     real(pfdp)     :: residual1 integer :: dir , which logical :: residual_converged , converged converged = . false . ! shortcut for fixed block mode if ( pf % abs_res_tol == 0 . and . pf % rel_res_tol == 0 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if ! in first sweep: always continue if ( pf % state % iter == 1 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 call call_hooks ( pf , 1 , PF_PRE_CONVERGENCE ) !> Check to see if tolerances are met call pf_check_residual_oc ( pf , residual_converged ) !>  Until I hear the previous processor is done, recieve it's status if ( pf % state % pstatus /= PF_STATUS_CONVERGED ) call pf_recv_status ( pf , send_tag , dir ) !>  Check to see if I am converged converged = . false . if ( residual_converged ) then if ( pf % rank == 0 . and . dir == 1 ) then converged = . true . elseif ( pf % rank == pf % comm % nproc - 1 . and . dir == 2 ) then converged = . true . else !  I am not the first/last processor, so I need to check the previous one if ( pf % state % pstatus == PF_STATUS_CONVERGED ) converged = . true . end if end if ! (residual_converged) !> Assign status and send it forward if ( converged ) then if ( pf % state % status == PF_STATUS_ITERATING ) then !  If I am converged for the first time !  then flip my flag and send the last status update pf % state % status = PF_STATUS_CONVERGED call pf_send_status ( pf , send_tag , dir ) end if else !  I am not converged, send the news pf % state % status = PF_STATUS_ITERATING call pf_send_status ( pf , send_tag , dir ) end if call call_hooks ( pf , 1 , PF_POST_CONVERGENCE ) !!! old code below ! Check to see if tolerances are met !     residual1 = pf%levels(pf%nlevels)%residual !     if (pf%state%status == PF_STATUS_ITERATING .and. residual > 0.0d0) then !        if ( (abs(1.0_pfdp - abs(residual1/residual)) < pf%rel_res_tol) .or. & !             (abs(residual1)                          < pf%abs_res_tol) ) then !           pf%state%status = PF_STATUS_CONVERGED !        end if !     end if ! !     !->why? how to do that more cleanly? !     if (pf%state%status == PF_STATUS_ITERATING .and. residual >= 0.0d0) then !                 ! if do_mixed, adjoint on last time step will be constant zero, so residual will be zero !                 ! need to stop in that case as well, but not in the very first iteration !       if( abs(residual1) < pf%abs_res_tol ) then !           pf%state%status = PF_STATUS_CONVERGED !       end if !     end if !     !!- ! !     residual = residual1 ! !     call call_hooks(pf, 1, PF_PRE_CONVERGENCE) !     if (pf%state%pstatus /= PF_STATUS_CONVERGED) call pf_recv_status(pf, 1+k, dir) ! !     if (pf%rank /= 0 .and. pf%state%pstatus == PF_STATUS_ITERATING .and. dir == 1) & !          pf%state%status = PF_STATUS_ITERATING !     if (pf%rank /= pf%comm%nproc-1 .and. pf%state%pstatus == PF_STATUS_ITERATING .and. dir == 2) & !          pf%state%status = PF_STATUS_ITERATING ! ! !     if (pf%state%status .ne. PF_STATUS_CONVERGED) !     call pf_send_status(pf, 1+k, dir) !     call call_hooks(pf, 1, PF_POST_CONVERGENCE) ! !     ! XXX: this ain't so pretty, perhaps we should use the !     ! 'nmoved' thinger to break this cycle if everyone is !     ! done... ! !     if (pf%state%status == PF_STATUS_CONVERGED) then !        converged = .true. !        return !     end if ! !     if (0 == pf%comm%nproc) then !        pf%state%status = PF_STATUS_PREDICTOR !        converged = .true. !        return !     end if end subroutine pf_check_convergence_oc !>  Routine to do the pfasst iterations for optimal control problems on one block of processors until completion. !>  Each processor will do either a fixed number of iterations, or iterate until a tolerance is met !>  On calling, it is assumed that the levels are already loaded with the initial guesses !> subroutine pf_pfasst_block_oc ( pf , dt , nsteps , predict , flags , step ) type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsteps logical , intent ( in ) :: predict integer , optional , intent ( in ) :: flags !0 (default): sweep on y and p, 1: just y, 2: just p integer , optional , intent ( in ) :: step ! not yet clear how to handle send and receive for forward and backward combined type ( pf_level_t ), pointer :: fine_lev_p , coarse_lev_p integer :: k , j , l , which , pred_flags ( 1 ), dir , ierror !dir to choose forward or backward send real ( pfdp ) :: residual logical :: converged , qbroadcast logical :: did_post_step_hook call start_timer ( pf , TTOTAL ) which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 pred_flags ( 1 ) = which if ( present ( step ) ) then pf % state % step = step else pf % state % step = pf % rank end if !     print *, pf%state%step pf % state % dt = dt pf % state % proc = pf % rank + 1 pf % state % t0 = pf % state % step * dt pf % state % iter = - 1 !     pf%state%itcnt   = 0 pf % state % mysteps = 0 pf % state % status = PF_STATUS_PREDICTOR pf % state % pstatus = PF_STATUS_PREDICTOR pf % comm % statreq = - 66 pf % state % nsteps = nsteps !     pf%state%component = which residual = - 1 did_post_step_hook = . false . !    call pf%results%initialize(nsteps, pf%niters, pf%comm%nproc, pf%nlevels) !    call pf_initialize_results(pf)   !  This one is the correct way !     do k = 1, 666666666 ! !        qbroadcast = .false. ! !        if (pf%state%status == PF_STATUS_CONVERGED .and. .not. did_post_step_hook) then !          call call_hooks(pf, -1, PF_POST_STEP) !          did_post_step_hook = .true. !          pf%state%itcnt = pf%state%itcnt + pf%state%iter !          pf%state%mysteps = pf%state%mysteps + 1 !          exit !        end if ! !        ! jump to next block if we've reached the max iteration count !        if (pf%state%iter >= pf%niters) then ! !           print *, pf%rank, 'pf%state%iter >= pf%niters' !           if (.not. did_post_step_hook) then !             call call_hooks(pf, -1, PF_POST_STEP) !             pf%state%itcnt = pf%state%itcnt + pf%state%iter !             pf%state%mysteps = pf%state%mysteps + 1 !           end if !           did_post_step_hook = .false. ! !           pf%state%step = pf%state%step + pf%comm%nproc !           pf%state%t0   = pf%state%step * dt ! !           if (pf%state%step >= pf%state%nsteps) exit  ! for optimal control this exit should always happen ! !           pf%state%status = PF_STATUS_PREDICTOR !           !pf%state%block  = pf%state%block + 1 !           residual = -1 !           qbroadcast = .true. !        end if ! !        if (k > 1 .and. qbroadcast) then !           if (pf%comm%nproc > 1) then !              stop \"broadcast not supported\" !              !fine_lev_p => pf%levels(pf%nlevels) !              !call pf%comm%wait(pf, pf%nlevels) !              !call fine_lev_p%encap%pack(fine_lev_p%send, fine_lev_p%qend) !              !call pf_broadcast(pf, fine_lev_p%send, fine_lev_p%nvars, pf%comm%nproc-1) !              !call fine_lev_p%encap%unpack(fine_lev_p%q0,fine_lev_p%send) !           else !              stop \"we should not be here I guess\" !              ! for sequential optimal control, we need to save the Q(m) values for state solution !              ! and load them when solving the adjoint !              ! additionally, state solution is needed for objective, adjoint for gradient ! !              !print *, 'copying initial/terminal value' !              fine_lev_p => pf%levels(pf%nlevels) !              if ((which .eq. 0) .or. (which .eq. 1)) call fine_lev_p%q0%copy(fine_lev_p%qend, 1) !              if (which .eq. 2) call fine_lev_p%qend%copy(fine_lev_p%q0, 2) !           end if !        end if !       if (pf%state%status == PF_STATUS_PREDICTOR) then !         !print *, 'pf%state%status == PF_STATUS_PREDICTOR', pf%state%t0, dt, which if ( predict ) then !print *, 'calling predictor' call pf_predictor_oc ( pf , pf % state % t0 , dt , pred_flags ) else pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING end if !       end if call call_hooks ( pf , - 1 , PF_POST_ITERATION ) !       pf%state%iter  = pf%state%iter + 1 ! ! !       exit! just do predictor ! !       call start_timer(pf, TITERATION) !       call call_hooks(pf, -1, PF_PRE_ITERATION) ! !       if (pf%state%status /= PF_STATUS_CONVERGED) then !           fine_lev_p => pf%levels(pf%nlevels) !           call fine_lev_p%ulevel%sweeper%sweep(pf, pf%nlevels, pf%state%t0, dt, fine_lev_p%nsweeps, which) !        end if ! !       ! check convergence  (should always be not converged) !       call pf_check_convergence_oc(pf, k,  residual, converged, dir) ! !       if (pf%state%step >= pf%state%nsteps) exit ! !       if (.not. converged) then !         !   non-blocking receive at all but the coarsest level !         do l = 2, pf%nlevels !           fine_lev_p => pf%levels(l) !           call pf_post(pf, fine_lev_p, fine_lev_p%index*10000+k, dir) !         end do ! !         if (pf%state%status /= PF_STATUS_CONVERGED) then !           fine_lev_p => pf%levels(pf%nlevels) !           call pf_send(pf, fine_lev_p, fine_lev_p%index*10000+k, .false., dir) !           if (pf%nlevels > 1) then !             coarse_lev_p => pf%levels(pf%nlevels-1) !             call restrict_time_space_fas(pf, pf%state%t0, dt, pf%nlevels, flags=which) !             call save(coarse_lev_p, which) !           end if !         end if ! !         call pf_v_cycle_oc(pf, k, pf%state%t0, dt, which) !         call call_hooks(pf, -1, PF_POST_ITERATION) !         call end_timer(pf, TITERATION) !       end if !     end do  !  Niter loop ! !     pf%state%iter = -1 !     call end_timer(pf, TTOTAL) k = 1 ! always one block  TO DO:  fix this pf % state % pfblock = k do j = 1 , pf % niters call start_timer ( pf , TITERATION ) call call_hooks ( pf , - 1 , PF_PRE_ITERATION ) pf % state % iter = j !  Do a v_cycle !       call pf_v_cycle(pf, k, pf%state%t0, dt, 1 ,pf%nlevels) call pf_v_cycle_oc ( pf , j , pf % state % t0 , dt , 1 , pf % nlevels , which ) !  Check for convergence call pf_check_convergence_oc ( pf , send_tag = 1111 * k + j , flags = dir ) call call_hooks ( pf , - 1 , PF_POST_ITERATION ) call end_timer ( pf , TITERATION ) !  If we are converged, exit block if ( pf % state % status == PF_STATUS_CONVERGED ) exit end do !  Loop over the iteration in this block call call_hooks ( pf , - 1 , PF_POST_CONVERGENCE ) pf % state % itcnt = pf % state % itcnt + pf % state % iter call call_hooks ( pf , - 1 , PF_POST_STEP ) call pf_dump_results ( pf ) call end_timer ( pf , TTOTAL ) end subroutine pf_pfasst_block_oc subroutine pf_v_cycle_oc ( pf , iteration , t0 , dt , level_index_c , level_index_f , flags ) ! Execute a V-cycle between levels nfine and ncoarse type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 , dt integer , intent ( in ) :: iteration integer , intent ( in ) :: level_index_c !! Coarsest level of V-cycle integer , intent ( in ) :: level_index_f !! Finest level of V-cycle integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: f_lev_p , c_lev_p integer :: level_index , j , which , dir which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 ! !     !  For a single level, just get new initial conditions and return !     if (pf%nlevels == 1) then !        f_lev_p => pf%levels(1) !        call pf_recv(pf, f_lev_p, f_lev_p%index*10000+iteration, .true., dir) !        return !     end if !>  Post the nonblocking receives on the all the levels that will be recieving later !>    (for single level this will be skipped) do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ) call pf_post ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , dir ) end do !     ! !     ! down (fine to coarse) !     ! !     do level_index = pf%nlevels-1, 2, -1 !       f_lev_p => pf%levels(level_index); !       c_lev_p => pf%levels(level_index-1) !       call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, f_lev_p%nsweeps, which) !       call pf_send(pf, f_lev_p, level_index*10000+iteration, .false., dir) !       call restrict_time_space_fas(pf, t0, dt, level_index, flags=which) !       call save(c_lev_p, which) !     end do !> move from fine to coarse doing sweeps do level_index = level_index_f , level_index_c + 1 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false ., dir ) call restrict_time_space_fas ( pf , t0 , dt , level_index , flags = which ) call save ( c_lev_p , which ) end do !     ! !     ! bottom  (coarsest level) !     ! !     level_index=1 !     f_lev_p => pf%levels(level_index) !     if (pf%pipeline_pred) then !        do j = 1, f_lev_p%nsweeps !           call pf_recv(pf, f_lev_p, f_lev_p%index*10000+iteration+j, .true., dir) !           call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, 1, which) !           call pf_send(pf, f_lev_p, f_lev_p%index*10000+iteration+j, .false., dir) !        end do !     else ! !       if (which == 0) then ! !         call pf_recv(pf, f_lev_p, f_lev_p%index*10000+iteration, .true., dir) ! !         call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, f_lev_p%nsweeps, 1) ! !         call pf_send(pf, f_lev_p, level_index*10000+iteration, .false., dir) ! !         call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, f_lev_p%nsweeps, 2) ! this interferes with skipping y sweeps: have to check ! !                                                                                        ! state residual in case of which==1 in sweeper as well ! !       else !         call pf_recv(pf, f_lev_p, f_lev_p%index*10000+iteration, .true., dir) !         call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, f_lev_p%nsweeps, which) !         call pf_send(pf, f_lev_p, level_index*10000+iteration, .false., dir) ! !       endif !     endif ! Do the coarsest level level_index = level_index_c f_lev_p => pf % levels ( level_index ) if ( pf % pipeline_pred ) then do j = 1 , f_lev_p % nsweeps call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . true ., dir ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 , which ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . false ., dir ) end do else call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . true ., dir ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false ., dir ) endif !     ! !     ! up  (coarse to fine) !     ! !     do level_index = 2, pf%nlevels !       f_lev_p => pf%levels(level_index); !       c_lev_p => pf%levels(level_index-1) !       call interpolate_time_space(pf, t0, dt, level_index, c_lev_p%Finterp, flags=which) !       call pf_recv(pf, f_lev_p, level_index*10000+iteration, .false., dir) ! !        if (pf%rank /= 0) then !           ! interpolate increment to q0 -- the fine initial condition !           ! needs the same increment that Q(1) got, but applied to the !           ! new fine initial condition !           if ((which .eq. 0) .or. (which .eq. 1)) call interpolate_q0(pf, f_lev_p, c_lev_p, flags=1) !        end if !        if (pf%rank /= pf%comm%nproc-1) then !           if (which .eq. 2) call interpolate_qend(pf, f_lev_p, c_lev_p) !        end if ! !        if (level_index < pf%nlevels) then !           call call_hooks(pf, level_index, PF_PRE_SWEEP) !           ! compute residual !           ! do while residual > tol and j < nswps !           ! assuming residual computed at end of sweep !           call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, f_lev_p%nsweeps, which) !        end if !     end do ! Now move coarse to fine interpolating and sweeping do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp , flags = which ) if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 1 ) if ( flags . eq . 2 ) call f_lev_p % q0 % copy ( f_lev_p % Q ( 1 ), flags = 2 ) call pf_recv ( pf , f_lev_p , level_index * 10000 + iteration , . false ., dir ) if ( pf % rank /= 0 ) then ! interpolate increment to q0 -- the fine initial condition ! needs the same increment that Q(1) got, but applied to the ! new fine initial condition if (( which . eq . 0 ) . or . ( which . eq . 1 )) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 1 ) end if if ( pf % rank /= pf % comm % nproc - 1 ) then if ( which . eq . 2 ) call interpolate_qend ( pf , f_lev_p , c_lev_p ) end if ! don't sweep on the finest level since that is only done at beginning if ( level_index < level_index_f ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) else !  compute residual for diagnostics since we didn't sweep call pf_residual ( pf , f_lev_p , dt , which ) end if end do end subroutine pf_v_cycle_oc end module pf_mod_parallel_oc","tags":"","loc":"sourcefile/pf_parallel_oc.f90.html","title":"pf_parallel_oc.f90 – LibPFASST"},{"text":"Useful subroutines that don't  fit in other modules This file depends on sourcefile~~pf_utils.f90~~EfferentGraph sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_utils.f90~~AfferentGraph sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_comm.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_utils.f90 sourcefile~pf_misdc.f90 pf_misdc.f90 sourcefile~pf_misdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_imk.f90 pf_imk.f90 sourcefile~pf_imk.f90->sourcefile~pf_utils.f90 sourcefile~pf_imex.f90 pf_imex.f90 sourcefile~pf_imex.f90->sourcefile~pf_utils.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_results.f90 pf_results.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_fftpack.f90 pf_fftpack.f90 sourcefile~pf_fftpack.f90->sourcefile~pf_utils.f90 sourcefile~pf_ndarray.f90 pf_ndarray.f90 sourcefile~pf_ndarray.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_magnus_picard.f90 pf_magnus_picard.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_utils.f90 sourcefile~pf_misdcq_oc.f90 pf_misdcQ_oc.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_exp.f90 pf_exp.f90 sourcefile~pf_exp.f90->sourcefile~pf_utils.f90 sourcefile~pf_verlet.f90 pf_verlet.f90 sourcefile~pf_verlet.f90->sourcefile~pf_utils.f90 sourcefile~pf_zndarray.f90 pf_zndarray.f90 sourcefile~pf_zndarray.f90->sourcefile~pf_utils.f90 sourcefile~pf_rkstepper.f90 pf_rkstepper.f90 sourcefile~pf_rkstepper.f90->sourcefile~pf_utils.f90 sourcefile~pf_fftw.f90 pf_fftw.f90 sourcefile~pf_fftw.f90->sourcefile~pf_utils.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pf_parallel.f90->sourcefile~pf_utils.f90 sourcefile~pf_parallel.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_parallel.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_parallel.f90->sourcefile~pf_results.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 sourcefile~pf_expq.f90 pf_expQ.f90 sourcefile~pf_expq.f90->sourcefile~pf_utils.f90 sourcefile~pf_misdcq.f90 pf_misdcQ.f90 sourcefile~pf_misdcq.f90->sourcefile~pf_utils.f90 sourcefile~pf_imexq.f90 pf_imexQ.f90 sourcefile~pf_imexq.f90->sourcefile~pf_utils.f90 sourcefile~pf_imexq.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_results.f90->sourcefile~pf_utils.f90 sourcefile~pf_amisdc.f90 pf_amisdc.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_imexq_oc.f90 pf_imexQ_oc.f90 sourcefile~pf_imexq_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_ndarray-oc.f90 pf_ndarray-oc.f90 sourcefile~pf_ndarray-oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 sourcefile~pfasst.f90->sourcefile~pf_imexq.f90 sourcefile~pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_amisdcq.f90 pf_amisdcQ.f90 sourcefile~pf_amisdcq.f90->sourcefile~pf_amisdc.f90 var pansourcefilepf_utilsf90AfferentGraph = svgPanZoom('#sourcefilepf_utilsf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_utils Source Code pf_utils.f90 Source Code !! Useful subroutines that don't  fit in other modules ! ! This file is part of LIBPFASST. ! !> Module with useful subroutines that don't  fit in other modules module pf_mod_utils use pf_mod_dtype use pf_mod_timer implicit none contains ! !> Compute full residual at each node and measure its size subroutine pf_residual ( pf , lev , dt , flag ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flag real ( pfdp ) :: res_norms ( lev % nnodes - 1 ) !!  Holds norms of residual real ( pfdp ) :: sol_norms ( lev % nnodes ) !!  Holds norms of solution ! for adjoint: need sol at t0 as well, not only t0+dt integer :: m call start_timer ( pf , TRESIDUAL ) call lev % ulevel % sweeper % residual ( lev , dt , flag ) ! compute max residual norm sol_norms ( 1 ) = lev % Q ( 1 )% norm ( flag ) ! for adjoint do m = 1 , lev % nnodes - 1 res_norms ( m ) = lev % R ( m )% norm ( flag ) sol_norms ( m + 1 ) = lev % Q ( m + 1 )% norm ( flag ) ! only the value at lev%nnodes is needed for forward integration, right? end do !    lev%residual = res_norms(lev%nnodes-1) m = lev % nnodes ! for usual forward integration if ( present ( flag )) then if ( flag == 2 ) m = 1 end if lev % residual = maxval ( res_norms ) if ( sol_norms ( m ) > 0.0d0 ) then lev % residual_rel = lev % residual / sol_norms ( m ) else lev % residual_rel = 0.0d0 end if if ( pf % save_residuals . and . pf % state % iter > 0 ) then pf % results ( lev % index )% residuals ( pf % state % iter , pf % state % pfblock , pf % state % sweep ) = lev % residual end if call end_timer ( pf , TRESIDUAL ) end subroutine pf_residual ! !> Generic residual !! Each sweeper can define its own residual, or use this generic one !! This routine is in the \"Q\" form, so the residual approximates !! R(m)=y(t_n) + \\int_{t_n}&#94;t_m f(y,s) ds - y(t_m) subroutine pf_generic_residual ( this , lev , dt , flags ) class ( pf_sweeper_t ), intent ( in ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , intent ( in ), optional :: flags integer :: m !>  Compute the integral of F from t_n to t_m at each node call lev % ulevel % sweeper % integrate ( lev , lev % Q , lev % F , dt , lev % I , flags ) !> add tau if it exists if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if !> subtract out the solution value if ( present ( flags )) then do m = 1 , lev % nnodes - 1 if ( ( flags . eq . 0 ) . or . ( flags . eq . 1 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 1 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 ), 1 ) end if if ( ( flags . eq . 0 ) . or . ( flags . eq . 2 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 2 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( lev % nnodes ), 2 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m ), 2 ) end if end do else do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end if end subroutine pf_generic_residual ! !> Generic evaluate all !! Each sweeper can define its own evaluate_all or use this generic one subroutine pf_generic_evaluate_all ( this , lev , t , flags , step ) class ( pf_sweeper_t ), intent ( in ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step integer :: m !     which = 1 !     if(present(flags)) which = flags !     mystep = 1 !     if(present(step)) mystep = step do m = 1 , lev % nnodes call lev % ulevel % sweeper % evaluate ( lev , t ( m ), m , flags = flags , step = step ) end do end subroutine pf_generic_evaluate_all !> Generic routine to spread initial conditions !! Each sweeper can define its own spreadq0 or use this generic one subroutine pf_generic_spreadq0 ( this , lev , t0 ) class ( pf_sweeper_t ), intent ( in ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Level on which to spread real ( pfdp ), intent ( in ) :: t0 !!  time at beginning of interval integer :: m , p !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , 1 ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 )) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p )) end do end do end subroutine pf_generic_spreadq0 subroutine pf_stop ( pf_file , Nline , msg , N ) character ( len =* ), intent ( in ) :: pf_file integer , intent ( in ) :: Nline character ( len =* ), intent ( in ) :: msg integer , intent ( in ), optional :: N print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * , 'Stopping in File: ' , pf_file print * , 'Line number: ' , Nline print * , msg if ( present ( N )) print * , 'value=' , N print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' stop end subroutine pf_stop end module pf_mod_utils","tags":"","loc":"sourcefile/pf_utils.f90.html","title":"pf_utils.f90 – LibPFASST"},{"text":"IMEX Sweeper Module This file depends on sourcefile~~pf_imexq.f90~~EfferentGraph sourcefile~pf_imexq.f90 pf_imexQ.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_imexq.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_imexq.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_imexq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_imexq.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_imexq.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_dtype.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 var pansourcefilepf_imexqf90EfferentGraph = svgPanZoom('#sourcefilepf_imexqf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_imexq.f90~~AfferentGraph sourcefile~pf_imexq.f90 pf_imexQ.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_imexq.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_imexQ Source Code pf_imexQ.f90 Source Code !!  IMEX Sweeper Module ! ! This file is part of LIBPFASST. ! !>  IMEX Sweeper Module !!  Module of the  the derived sweeper class for doing IMEX sweeps for an equation of the form !!            y' = f_1(y) + f_2(y)   !!  The f_1 piece is treated explicitly and f_2 implicitl !!  Afer this sweeper is initialized (usually in main), the logical flags can be changed if desired !! !!     explicit:  Make false if there is no explicit piece !! !!     implicit:  Make false if there is no implicit piece !! !! !!  The user needs to supply the feval and fcomp routines for a given example module pf_mod_imexQ use pf_mod_dtype use pf_mod_utils implicit none !>  IMEX SDC sweeper type, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_imexQ_t real ( pfdp ), allocatable :: QtilE (:,:) !!  Approximate explicit quadrature rule real ( pfdp ), allocatable :: QtilI (:,:) !!  Approximate implicit quadrature rule real ( pfdp ), allocatable :: dtsdc (:) !!  SDC step sizes real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ), allocatable :: QdiffI (:,:) !!  qmat-QtilI logical :: explicit = . true . !!  True if there is an explicit piece logical :: implicit = . true . !!  True if there an implicit piece class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver !>  Set the generic functions procedure :: sweep => imexQ_sweep procedure :: initialize => imexQ_initialize procedure :: evaluate => imexQ_evaluate procedure :: integrate => imexQ_integrate procedure :: residual => imexQ_residual procedure :: spreadq0 => imexQ_spreadq0 procedure :: evaluate_all => imexQ_evaluate_all procedure :: destroy => imexQ_destroy procedure :: imexQ_destroy end type pf_imexQ_t interface !>  This is the interface for the routine to compute the RHS function values !>  Evaluate f_piece(y), where piece is one or two subroutine pf_f_eval_p ( this , y , t , level_index , f , piece ) !>  Evaluate f_piece(y), where piece is one or two import pf_imexQ_t , pf_encap_t , pfdp class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y !!  Argument for evaluation real ( pfdp ), intent ( in ) :: t !!  Time at evaluation integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  RHS function value integer , intent ( in ) :: piece !!  Which piece to evaluate end subroutine pf_f_eval_p !>  Solve the equation y - dtq*f_2(y) =rhs subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece ) import pf_imexQ_t , pf_encap_t , pfdp class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Solution of implicit solve real ( pfdp ), intent ( in ) :: t !!  Time of solve real ( pfdp ), intent ( in ) :: dtq !!  dt*quadrature weight class ( pf_encap_t ), intent ( in ) :: rhs !!  RHS for solve integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  f_2 of solution y integer , intent ( in ) :: piece !!  Which piece to evaluate end subroutine pf_f_comp_p end interface contains !> Perform nsweep SDC sweeps on level level_index and set qend appropriately. subroutine imexQ_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imexQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: m , n , k !!  Loop variables real ( pfdp ) :: t !!  Time at nodes lev => pf % levels ( level_index ) !!  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps !!  Loop over sweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) if ( this % explicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) end do end if if ( this % implicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 )) end do end if if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) end if t = t0 ! do the sub-stepping in sweep do m = 1 , lev % nnodes - 1 !!  Loop over substeps t = t + dt * this % dtsdc ( m ) !>  Accumulate rhs call this % rhs % setval ( 0.0_pfdp ) do n = 1 , m if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do !>  Add the integral term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m )) !>  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 )) !>  Solve for the implicit piece if ( this % implicit ) then call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) else call lev % Q ( m + 1 )% copy ( this % rhs ) end if !>  Compute explicit function on new value if ( this % explicit ) & call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) end do !!  End substep loop call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imexQ_sweep !> Subroutine to initialize matrices and space for sweeper subroutine imexQ_initialize ( this , lev ) use pf_mod_quadrature class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level integer :: nnodes , ierr this % npieces = 2 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imexQ_initialize for QdiffE\" allocate ( this % QdiffI ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imexQ_initialize for QdiffI\" allocate ( this % QtilE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imexQ_initialize for QtilE\" allocate ( this % QtilI ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imexQ_initialize for QtilI\" allocate ( this % dtsdc ( nnodes - 1 ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imexQ_initialize for dtsdc\" this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp !>  Array of substep sizes this % dtsdc = lev % sdcmats % qnodes ( 2 : nnodes ) - lev % sdcmats % qnodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine imexQ_initialize !>  Subroutine to deallocate sweeper subroutine imexQ_destroy ( this , lev ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_single ( this % rhs , lev % index , lev % shape ) end subroutine imexQ_destroy !> Subroutine to compute  Picard integral of function values subroutine imexQ_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev !!  Current level class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags integer :: n , m do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes if ( this % explicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 1 )) if ( this % implicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 2 )) end do end do end subroutine imexQ_integrate !> Subroutine to compute  Residual subroutine imexQ_residual ( this , lev , dt , flags ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags call pf_generic_residual ( this , lev , dt ) end subroutine imexQ_residual subroutine imexQ_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine imexQ_spreadq0 !> Subroutine to evaluate function value at node m subroutine imexQ_evaluate ( this , lev , t , m , flags , step ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) end subroutine imexQ_evaluate !> Subroutine to evaluate the function values at all nodes subroutine imexQ_evaluate_all ( this , lev , t , flags , step ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine imexQ_evaluate_all end module pf_mod_imexQ","tags":"","loc":"sourcefile/pf_imexq.f90.html","title":"pf_imexQ.f90 – LibPFASST"},{"text":"This file depends on sourcefile~~pf_expq.f90~~EfferentGraph sourcefile~pf_expq.f90 pf_expQ.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_expq.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_expq.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_expq.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_expq.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_exp Source Code pf_expQ.f90 Source Code ! ===================================================================================== ! MODULE: pf_mod_exp ! !> @author !> Tommaso Buvoli ! ! Last Modified: Dec 28, 2018 ! ! Description ! !!  this module extends pf_sweeper_t and is used for creating an exponential sweeper !!  that solves equations of the form !!            y' = L y + N(t,y)   !!  When extending this class, you must supply the functions phib, swpPhib, and resPhib !!  that each compute matrix-vector products of the form !!          \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i  !!  in addition to the function f_eval for compluting the nonlinear term N(t,y). !!  The complete description of these three functions is contained below. ! ===================================================================================== module pf_mod_exp use pf_mod_dtype use pf_mod_utils implicit none ! Exponential SDC sweeper type, extends abstract pf_sweeper_t type , extends ( pf_sweeper_t ), abstract :: pf_exp_t real ( pfdp ), allocatable :: w (:,:,:) ! weights real ( pfdp ), allocatable :: nodes (:) ! nodes real ( pfdp ), allocatable :: eta (:) ! normalized substeps (on interval [0, 1]) class ( pf_encap_t ), allocatable :: b (:) ! scratch space for computing nonlinear derivatives class ( pf_encap_t ), allocatable :: f_old (:) ! scratch space for storing nonlinear terms class ( pf_encap_t ), allocatable :: newF ! scratch space for storing new function evaluations LOGICAL :: use_phib = . TRUE . ! if TRUE calls phib otherwise calls swpPhib and resPhib contains ! specialized procedures for exponential integrator procedure ( pf_f_eval_p ), deferred :: f_eval ! computes nonlinear term in equation procedure ( pf_phib ), deferred :: phib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i procedure ( pf_swpPhib ), deferred :: swpPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n,j} for j = 1, ... q - 1 procedure ( pf_resPhib ), deferred :: resPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n} for j = 1, ... q - 1 procedure , private :: weights procedure , private :: LocalDerivsAtNode ! generic functions procedure :: initialize => exp_initialize procedure :: sweep => exp_sweep procedure :: evaluate => exp_evaluate procedure :: integrate => exp_integrate procedure :: residual => exp_residual procedure :: spreadq0 => exp_spreadq0 procedure :: evaluate_all => exp_evaluate_all procedure :: destroy => exp_destroy ! functions that can be accessed directly by types that inherit pf_exp_t procedure :: exp_destroy procedure :: exp_initialize end type pf_exp_t interface ! DESCRIPTION OF REQUIRED FUNCTIONS ! =================================================================================             REMARK: ADDING ax operation would simplify dealing with h for b(2:end) ! PHIB: Computes the product of vectors and phi functions ! !       y(t) = exp(t h L) b_1 + h \\sum_{i=1}&#94;n t&#94;i \\varphi_i(t h L)b_{i+1} ! !       for a user specified t, and h. ! !       NOTE: The operator L is not passed in as a parameter, and must be !       implemented appropriately within the function. ! ! Arguments ! !   t   (input) DOUBLE !       evaluation time for expression ! !   h   (input) DOUBLE !       scaling factor for the linear opeartor AND the vectors b_i for i = 2 ... n ! !   b   (input) pf_encap_t(:) !       array that stores the vectors b_i ! !   y   (output) pf_encap_t !       once subroutine terminate this stores the result y(t) ! ================================================================================= subroutine pf_phib ( this , t , h , b , y ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t real ( pfdp ), intent ( in ) :: h class ( pf_encap_t ), intent ( in ) :: b (:) class ( pf_encap_t ), intent ( inout ) :: y end subroutine pf_phib ! ================================================================================= ! SWPPHIB: Computes the product of vectors and phi functions ! !           y(t) = \\varphi_0(h L) b_1 + h \\sum_{i=1}&#94;n t&#94;i \\varphi_i(t h L)b_{i+1} ! !       where the time t is ! !           t_{n,j+1} - t_{n,j}         j = 1, ... q - 1 ! !       and h is a user specified. This procedure is used when computing !       exponential correction sweeps. ! !       NOTE: The operator L is not passed in as a parameter, and must be !       implemented appropriately within the function. ! ! Arguments ! !   j   (input) Integer !       substep index for determining t: t = t_{n,j+1} - t_{n,j} ! !   h   (input) DOUBLE !       scaling factor for the linear opeartor AND the vectors b_i for i = 2 ... n ! !   b   (input) pf_encap_t(:) !       array that stores the vectors b_i ! !   y   (output) pf_encap_t !       once subroutine terminate this stores the result y(t) ! ================================================================================= subroutine pf_swpPhib ( this , j , h , b , y ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this integer , intent ( in ) :: j real ( pfdp ), intent ( in ) :: h class ( pf_encap_t ), intent ( in ) :: b (:) class ( pf_encap_t ), intent ( inout ) :: y end subroutine pf_swpPhib ! ================================================================================= ! RESPHIB: Computes the product of vectors and phi functions ! !           y(t) = \\varphi_0(h L) b_1 + h \\sum_{i=1}&#94;n t&#94;i \\varphi_i(t h L)b_{i+1} ! !       where the time t is ! !           t_{n,j} - t_{n} ! !       and h is a user specified. This procedure is used when computing !       exponential correction sweeps. ! !       NOTE: The operator L is not passed in as a parameter, and must be !       implemented appropriately within the function. ! ! Arguments ! !   j   (input) Integer !       substep index for determining t: t = t_{n,j+1} - t_{n} ! !   h   (input) DOUBLE !       scaling factor for the linear opeartor AND the vectors b_i for i = 2 ... n ! !   b   (input) pf_encap_t(:) !       array that stores the vectors b_i ! !   y   (output) pf_encap_t !       once subroutine terminate this stores the result y(t) ! ================================================================================= subroutine pf_resPhib ( this , j , h , b , y ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this integer , intent ( in ) :: j real ( pfdp ), intent ( in ) :: h class ( pf_encap_t ), intent ( in ) :: b (:) class ( pf_encap_t ), intent ( inout ) :: y end subroutine pf_resPhib ! ================================================================================= ! f_eval: computes the equations nonlinear term N(t,y) ! ! Arguments ! !   y     (input) pf_encap_t !         solution y(t) ! !   t     (input) DOUBLE !         time t ! !   level (input) INTEGER !         current level index ! !   f     (output) pf_encap_t !         N(t,y) ! ================================================================================= subroutine pf_f_eval_p ( this , y , t , level , n ) import pf_exp_t , pf_encap_t , pfdp class ( pf_exp_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: n end subroutine pf_f_eval_p end interface contains ! ================================================================================= ! INITIALIZE: initializes the following internal parameters !      w        DOUBLE(:,:,:)     contains FD weights for computing local derivatives at t_{n,j} !      nodes    DOUBLE(:)         sdc nodes !      eta      DOUBLE(:)         normalized substeps (t_{n,j+1} - t_{n,j})/h !      npieces  INTEGER           number of RHS peices (always will be one) !      newF     pf_encap_t        stores new function evaluations !      b        pf_encap_t(:)     stores vectors b for computing phi products ! ================================================================================= subroutine exp_initialize ( this , lev ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev ! local variables integer :: i , nnodes real ( pfdp ), allocatable :: q (:) nnodes = lev % nnodes allocate ( this % eta ( nnodes - 1 )) allocate ( this % nodes ( nnodes )) allocate ( q ( nnodes )) ! set nodes and substeps this % nodes = lev % sdcmats % qnodes this % eta = this % nodes ( 2 : nnodes ) - this % nodes ( 1 : nnodes - 1 ) ! substeps ! compute weights allocate ( this % w ( nnodes - 1 , nnodes , nnodes )) do i = 1 , nnodes - 1 q = this % nodes - this % nodes ( i ); call weights ( this , real ( 0.0 , pfdp ), q , nnodes - 1 , this % W ( i , :, :)); end do ! set number of rhs components this % npieces = 1 ! initialize temporary storage objects call lev % ulevel % factory % create_single ( this % newF , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % b , nnodes + 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % f_old , nnodes , lev % index , lev % shape ) end subroutine exp_initialize ! SWEEP: exponential sweep subroutine =============================================== subroutine exp_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags ! local variables class ( pf_level_t ), pointer :: lev integer :: m , nnodes , j , k , i real ( pfdp ) :: t lev => pf % levels ( level_index ) nnodes = lev % nnodes call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) ! compute F_j&#94;{[k+1]} ! error sweeps do k = 1 , nsweeps call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! NOTE: ensure that lev%F has been properly initialized here t = t0 do j = 1 , nnodes call this % f_old ( j )% copy ( lev % F ( j , 1 )) ! Save old f end do do j = 1 , nnodes - 1 t = t0 + dt * this % eta ( j ) ! form b vectors call LocalDerivsAtNode ( this , 1 , nnodes , this % f_old (:), this % b ( 2 : nnodes + 1 )) ! phi expansion for exponential picard integral !              call LocalDerivsAtNode(this, 1, nnodes, lev%F(:,1), this%b(2:nnodes+1))  ! phi expansion for exponential picard integral call this % b ( 1 )% copy ( lev % Q ( 1 )) ! add term \\phi_0(tL) y_n do i = 1 , j !                 call this%b(2)%axpy(-this%eta(i), this%f_old(i))         ! add -\\phi_1(tL) F_j&#94;{[k]} !                 call this%b(2)%axpy(this%eta(i), lev%F(i,1))          ! add \\phi_1(tL) F_j&#94;{[k+1]} end do ! compute phi products if ( this % use_phib ) then call this % phib ( this % nodes ( j + 1 ), dt , this % b , lev % Q ( j + 1 )) else call this % swpPhib ( j + 1 , dt , this % b , lev % Q ( j + 1 )) end if !              !  Now we have to add in the tauQ if ( allocated ( lev % tauQ )) then call lev % Q ( j + 1 )% axpy ( 1.0_pfdp , lev % tauQ ( j )) end if call this % f_eval ( lev % Q ( j + 1 ), t , lev % index , lev % F ( j + 1 , 1 )) ! eval last nonlinear term ! end do call lev % qend % copy ( lev % Q ( lev % nnodes )) call pf_residual ( pf , lev , dt ) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do end subroutine exp_sweep ! ================================================================================= ! INTEGRATE: computes the integrals for the exponential Picard residual ! !         r_j = A_j - B_j ! !     where ! !         A_j = \\left[ \\exp(t h L) y(t_n) - \\int_{t_n}&#94;{t_{n,j}} \\exp(L(t - t_n)) P(t) dt \\right] !         B_j = y(t_{n,j}) ! !     NOTE: This procedure computes the expression \\hat{r}_j = A_j - y(t_n). The !     term y(t_n) is subtracted from result since the generic calling function !     compute the residual as ! !        r_j = y(t_n) + exp_integrate() - y(t_{n,j}) ! !     thus incorrectly adding the term y_n ! ================================================================================= subroutine exp_integrate ( this , lev , qSDC , fSDC , dt , fintsdc , flags ) ! parameters class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev !!  Current level class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintsdc (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags ! local variables integer :: i , nnodes nnodes = lev % nnodes call LocalDerivsAtNode ( this , 1 , nnodes , fSDC (:, 1 ), this % b ( 2 : nnodes + 1 )) ! compute derivatives call this % b ( 1 )% setval ( real ( 0.0 , pfdp )) call this % b ( 1 )% axpy ( real ( 1.0 , pfdp ), qSDC ( 1 )) do i = 1 , nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}} if ( this % use_phib ) then call this % phib ( this % nodes ( i + 1 ), dt , this % b , fintsdc ( i )) else call this % resPhib ( i , dt , this % b , fintsdc ( i )) end if end do end subroutine exp_integrate ! RESIDUAL: compute  residual (generic) ==================================== subroutine exp_residual ( this , lev , dt , flags ) class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags integer :: m !>  Compute the integral of F from t_n to t_m at each node call lev % ulevel % sweeper % integrate ( lev , lev % Q , lev % F , dt , lev % I , flags ) !> add tau if it exists if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if !> subtract out the solution value do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end subroutine exp_residual ! SPREADQ: spread solution (generic) ====================================== subroutine exp_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine exp_spreadq0 ! EVALUATE: evaluate the nonlinear term at node m ======================== subroutine exp_evaluate ( this , lev , t , m , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine exp_evaluate ! EVALUATE_ALL: evaluate the nonlinear term at all nodes ================= subroutine exp_evaluate_all ( this , lev , t , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine exp_evaluate_all ! DEALLOCATE: deallocate sweeper variables subroutine exp_destroy ( this , lev ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level deallocate ( this % w ) deallocate ( this % eta ) deallocate ( this % newF ) call lev % ulevel % factory % destroy_array ( this % b , lev % index , lev % nnodes , lev % shape ) call lev % ulevel % factory % destroy_array ( this % f_old , lev % index , lev % nnodes , lev % shape ) end subroutine exp_destroy ! ======================================================================= ! LocalDerivsAtNode: approximate the local derivative vector !           at the substep t_{n,i} for the nonlinear function N(y(t)) !           using the terms N(y{n,i}). Local coordinates coorespond to !           s = h t. ! Arguments ! !   i       (input) INTEGER !           index of the substep for which we want to approximate derivatives ! !   nnodes  (input) INTEGER !           number of nodes ! !   N_eval  (input) pf_encap_t(:) !           Nonlinear function evaluations; N_eval(i) contains N(y_{n,i}) ! !   N_deriv (output) pf_encap_t(:) !           N_deriv(i) approximates \\frac{d&#94;{i-1}}{dt&#94;{i-1}} N(y(t)) ! ======================================================================= subroutine LocalDerivsAtNode ( this , i , nnodes , N_eval , N_deriv ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this integer , intent ( in ) :: i integer , intent ( in ) :: nnodes class ( pf_encap_t ), intent ( in ) :: N_eval (:) class ( pf_encap_t ), intent ( inout ) :: N_deriv (:) ! local variables integer :: j , k ! form nonlinear derivative vectors b do j = 1 , nnodes ! loop over derivatives j = 1 ... n call N_deriv ( j )% setval ( real ( 0.0 , pfdp )) do k = 1 , nnodes ! look over nodes k = 1 ... n call N_deriv ( j )% axpy ( this % w ( i , k , j ), N_eval ( k )) end do end do end ! ======================================================================= ! WEIGHTS   Compute coefficients for finite difference approximation for !           the derivatives 1 to m at point z assuming data is known at !           points in array x. Based on the program \"weights\" in !           B. Fornberg, \"Calculation of weights in finite difference !           formulas\", SIAM Review 40 (1998), pp. 685-691. ! Arguments ! !   z   (input) DOUBLE !       location where approximations are to be accurate ! !   x   (input) DOUBLE Array !       array containing interpolation points ! !   m   (input) INTEGER !       highest derivative for which weights are sought ! !   W   (output) DOUBLE array, dimension(size(x),m+1) !       matrix that gives weights at grid locations x for !       derivative of order j<=m are found in c(:,j) ! ======================================================================= subroutine weights ( this , z , x , m , W ) ! Arguments class ( pf_exp_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z real ( pfdp ), intent ( in ) :: x (:) integer , intent ( in ) :: m real ( pfdp ), intent ( out ) :: W ( size ( x ), m + 1 ) ! Variable Declarations real ( pfdp ) :: c1 , c2 , c3 , c4 , c5 integer :: i , j , k , n , mn c1 = 1.0_pfdp c4 = x ( 1 ) - z W = 0.0_pfdp W ( 1 , 1 ) = 1.0_pfdp n = size ( x ) do i = 2 , n mn = min ( i , m + 1 ) c2 = 1.0_pfdp c5 = c4 c4 = x ( i ) - z do j = 1 , i - 1 c3 = x ( i ) - x ( j ) c2 = c2 * c3 ; if ( j == i - 1 ) then do k = mn , 2 , - 1 W ( i , k ) = c1 * ( real ( k - 1 , pfdp ) * W ( i - 1 , k - 1 ) - c5 * W ( i - 1 , k )) / c2 ; enddo W ( i , 1 ) = - c1 * c5 * W ( i - 1 , 1 ) / c2 ; endif do k = mn , 2 , - 1 W ( j , k ) = ( c4 * W ( j , k ) - real ( k - 1 , pfdp ) * W ( j , k - 1 )) / c3 ; enddo W ( j , 1 ) = c4 * W ( j , 1 ) / c3 ; enddo c1 = c2 ; enddo end subroutine weights end module pf_mod_exp","tags":"","loc":"sourcefile/pf_expq.f90.html","title":"pf_expQ.f90 – LibPFASST"},{"text":"Asynchronous MISDC sweeper This file depends on sourcefile~~pf_amisdcq.f90~~EfferentGraph sourcefile~pf_amisdcq.f90 pf_amisdcQ.f90 sourcefile~pf_amisdc.f90 pf_amisdc.f90 sourcefile~pf_amisdcq.f90->sourcefile~pf_amisdc.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_amisdcq.f90->sourcefile~pf_timer.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_amisdc.f90->sourcefile~pf_utils.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_amisdcQ Source Code pf_amisdcQ.f90 Source Code !!  Asynchronous MISDC sweeper ! ! This file is part of LIBPFASST. ! !> Asynchronous multi-implicit sweeper module pf_mod_amisdcQ use pf_mod_amisdc implicit none !>  Asynchronous multi-implicit sweeper type type , extends ( pf_amisdc_t ), abstract :: pf_amisdcQ_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) logical :: use_LUq_ = . true . contains procedure :: sweep => amisdcQ_sweep procedure :: initialize => amisdcQ_initialize procedure :: integrate => amisdcQ_integrate procedure :: destroy => amisdcQ_destroy procedure :: sweep_coupled_implicit_terms procedure :: sweep_decoupled_implicit_terms procedure :: amisdcQ_destroy end type pf_amisdcQ_t contains ! Perform an SDC sweep on level lev and set qend appropriately. ! In the asynchronous updates, the two implicit parts are coupled subroutine sweep_coupled_implicit_terms ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: rhsA , rhsB , QA , QB class ( pf_encap_t ), allocatable :: S2 (:), S3 (:) call start_timer ( pf , TLEVEL + lev % index - 1 ) call lev % ulevel % factory % create_array ( S2 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( S3 , lev % nnodes - 1 , lev % index , lev % shape ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) call S2 ( m )% setval ( 0.0d0 ) call S3 ( m )% setval ( 0.0d0 ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( 1.0_pfdp * dt * lev % qmat ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( 1.0_pfdp * dt * lev % qmat ( m , n ), lev % F ( n , 3 )) call S2 ( m )% axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 2 )) call S3 ( m )% axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tauQ )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call this % f1eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) call this % f2eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 )) call this % f3eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 )) call lev % ulevel % factory % create_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QB , lev % index , lev % shape ) call QA % setval ( 0.0_pfdp ) call QB % setval ( 0.0_pfdp ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) call rhsA % copy ( lev % Q ( 1 )) ! First compute the explicit part of the right-hand side do n = 1 , m call rhsA % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) end do call rhsA % axpy ( 1.0_pfdp , lev % S ( m )) ! Save the right-hand side with only the explicit contribution call rhsB % copy ( rhsA ) ! Add the first implicit part to the right-hand side and solve for the first asynchronous update do n = 1 , m call rhsA % axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do call rhsA % axpy ( - 1.0_pfdp , S2 ( m )) call this % f2comp ( QA , t , 2.0_pfdp * dt * this % QtilI ( m , m + 1 ), rhsA , lev % index , lev % F ( m + 1 , 2 )) ! Add the second implicit part to the right-hand side and solve for the second asynchronous update do n = 1 , m call rhsB % axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do call rhsB % axpy ( - 1.0_pfdp , S3 ( m )) call this % f3comp ( QB , t , 2.0_pfdp * dt * this % QtilI ( m , m + 1 ), rhsB , lev % index , lev % F ( m + 1 , 3 )) ! Now we average the two asynchronous updates call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QA ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QB ) ! Evaluate the three right-hand sides with the updated variables call this % f1eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 )) call this % f2eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 )) call this % f3eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 3 )) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) call lev % ulevel % factory % destroy_array ( S2 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( S3 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QB , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine sweep_coupled_implicit_terms ! Perform an SDC sweep on level lev and set qend appropriately. ! In the asynchronous updates, the two implicit parts are decoupled ! (in progress) subroutine sweep_decoupled_implicit_terms ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev ! integer                        :: m, n ! real(pfdp)                     :: t ! real(pfdp)                     :: dtsdc(1:lev%nnodes-1) ! class(pf_encap_t), allocatable :: rhsA, rhsB, QA, QB ! class(pf_encap_t), allocatable :: S2(:), S3(:) ! call start_timer(pf, TLEVEL+lev%index-1) ! call lev%ulevel%factory%create_array(S2,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%create_array(S3,lev%nnodes-1,lev%index,lev%shape) ! ! compute integrals and add fas correction ! do m = 1, lev%nnodes-1 !    call lev%S(m)%setval(0.0_pfdp) !    call S2(m)%setval(0.0d0) !    call S3(m)%setval(0.0d0) !    do n = 1, lev%nnodes !       call lev%S(m)%axpy(dt*this%QdiffE(m,n),       lev%F(n,1)) !       call S2(m)%axpy( 2.0_pfdp*dt*lev%qmat(m,n),   lev%F(n,2)) !       call S3(m)%axpy( 2.0_pfdp*dt*lev%qmat(m,n),   lev%F(n,3)) !       call S2(m)%axpy(-2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,2)) !       call S3(m)%axpy(-2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,3)) !    end do !    if (allocated(lev%tauQ)) then !       call lev%S(m)%axpy(1.0_pfdp, lev%tauQ(m)) !    end if ! end do ! ! do the time-stepping ! call lev%Q(1)%unpack(lev%q0) ! call this%f1eval(lev%Q(1), t0, lev%index, lev%F(1,1)) ! call this%f2eval(lev%Q(1), t0, lev%index, lev%F(1,2)) ! call this%f3eval(lev%Q(1), t0, lev%index, lev%F(1,3)) ! call lev%ulevel%factory%create_single(rhsA, lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(rhsB, lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(QA,   lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(QB,   lev%index,  lev%shape) ! call QA%setval(0.0_pfdp) ! call QB%setval(0.0_pfdp) ! t = t0 ! dtsdc = dt * (lev%nodes(2:lev%nnodes) - lev%nodes(1:lev%nnodes-1)) ! do m = 1, lev%nnodes-1 !    t = t + dtsdc(m) !    call rhsA%copy(lev%Q(1)) !    ! First compute the explicit part of the right-hand side !    do n = 1, m !       call rhsA%axpy(dt*this%QtilE(m,n), lev%F(n,1)) !    end do !    call rhsA%axpy(1.0_pfdp, lev%S(m)) !    ! Save the right-hand side with only the explicit contribution !    call rhsB%copy(rhsA) !    ! Add the first implicit part to the right-hand side and solve for the first asynchronous update !    do n = 1, m !       call rhsA%axpy(2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,2)) !    end do !    call rhsA%axpy(1.0_pfdp, S2(m)) !    call this%f2comp(QA, t, 2.0_pfdp*dt*this%QtilI(m,m+1), rhsA, lev%index, lev%F(m+1,2)) !    ! Add the second implicit part to the right-hand side and solve for the second asynchronous update !    do n = 1, m !       call rhsB%axpy(2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,3)) !    end do !    call rhsB%axpy(1.0_pfdp, S3(m)) !    call this%f3comp(QB, t, 2.0_pfdp*dt*this%QtilI(m,m+1), rhsB, lev%index, lev%F(m+1,3)) !    ! Now we average the two asynchronous updates !    call lev%Q(m+1)%setval(0.0_pfdp) !    call lev%Q(m+1)%axpy(0.5_pfdp, QA) !    call lev%Q(m+1)%axpy(0.5_pfdp, QB) !    ! Evaluate the three right-hand sides with the updated variables !    call this%f1eval(lev%Q(m+1), t, lev%index, lev%F(m+1,1)) !    call this%f2eval(lev%Q(m+1), t, lev%index, lev%F(m+1,2)) !    call this%f3eval(lev%Q(m+1), t, lev%index, lev%F(m+1,3)) ! end do ! call lev%qend%copy(lev%Q(lev%nnodes)) ! call lev%ulevel%factory%destroy_array(S2,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%destroy_array(S3,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%destroy_single(rhsA, lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(rhsB, lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(QA,   lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(QB,   lev%index,   lev%shape) ! call end_timer(pf, TLEVEL+lev%index-1) end subroutine sweep_decoupled_implicit_terms ! Perform an SDC sweep on level lev and set qend appropriately. subroutine amisdcQ_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev call sweep_coupled_implicit_terms ( this , pf , lev , t0 , dt ) end subroutine amisdcQ_sweep ! Initialize matrices subroutine amisdcQ_initialize ( this , lev ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , n , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) !  S-BE this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq_ ) then ! Get the LU call myLUq ( lev % qmat , lev % LUmat , lev % nnodes , 1 ) this % QtilI = lev % LUmat else do m = 1 , nnodes - 1 do n = 1 , m this % QtilI ( m , n + 1 ) = dsdc ( n ) end do end do end if ! Explicit matrix do m = 1 , nnodes - 1 do n = 1 , m this % QtilE ( m , n ) = dsdc ( n ) end do end do this % QdiffE = lev % qmat - this % QtilE this % QdiffI = lev % qmat - this % QtilI end subroutine amisdcQ_initialize ! Destroy the matrices subroutine amisdcQ_destroy ( this , lev ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) end subroutine amisdcQ_destroy ! Compute SDC integral subroutine amisdcQ_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % qmat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine amisdcQ_integrate end module pf_mod_amisdcQ","tags":"","loc":"sourcefile/pf_amisdcq.f90.html","title":"pf_amisdcQ.f90 – LibPFASST"},{"text":"Implicit Munthe-Kass Runge-Kutta sweeper This file depends on sourcefile~~pf_imk.f90~~EfferentGraph sourcefile~pf_imk.f90 pf_imk.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_imk.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_imk.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_imk.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_imk.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_imk Source Code pf_imk.f90 Source Code !!  Implicit Munthe-Kass Runge-Kutta sweeper ! ! This file is part of LIBPFASST. ! !>  This module implements fully implicit Munthe-Kaas Runge Kutta methods using explicit SDC sweeping !! !!  The equation to be solved is !! !!  y'=A(y,t)y   !! !! where A is a matrix and y)\\ is  a vector or matrix or if Lax_pair = true !! !! Y'=[A(Y,t),Y] where both A and Y are matrices !! !!  We solve this by finding the solution to !! !!  Q' = dexpinv_Q(A) !! !!  Using PFASST module pf_mod_imk use pf_mod_dtype use pf_mod_utils implicit none !>  Implicit Munthe-Kaas Runge-Kutta sweeper type, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_imk_t class ( pf_encap_t ), allocatable :: A (:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: dtsdc (:) real ( pfdp ), allocatable :: tsdc (:) real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ) :: bernoullis ( 20 ), t0 , dt integer :: qtype , nterms logical :: Lax_pair , use_SDC , debug , mkrk , rk contains procedure :: sweep => imk_sweep procedure :: initialize => imk_initialize procedure :: evaluate => imk_evaluate procedure :: integrate => imk_integrate procedure :: residual => imk_residual procedure :: spreadq0 => imk_spreadq0 procedure :: evaluate_all => imk_evaluate_all procedure :: imk_destroy procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_dexpinv_p ), deferred :: dexpinv procedure ( pf_propagate_p ), deferred :: propagate procedure ( pf_commutator_p ), deferred :: commutator_p end type pf_imk_t interface !>  Subroutine f_eval computes A(y,t) subroutine pf_f_eval_p ( this , y , t , level , f ) import pf_imk_t , pf_encap_t , c_int , pfdp class ( pf_imk_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y , f real ( pfdp ), intent ( in ) :: t integer ( c_int ), intent ( in ) :: level end subroutine pf_f_eval_p !>  Subroutine dexpinv computes Om'=F=dexpinv_Om(A) subroutine pf_dexpinv_p ( this , a , omega , f ) import pf_imk_t , pf_encap_t , c_int , pfdp class ( pf_imk_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: a class ( pf_encap_t ), intent ( inout ) :: omega class ( pf_encap_t ), intent ( inout ) :: f !!  The resultign-level end subroutine pf_dexpinv_p !>  Subroutine propagate   computes y_m=expm(Om_m)y_0(expm(Om_m))-1 or (expm(Om_m))y_0 or subroutine pf_propagate_p ( this , q0 , q ) import pf_imk_t , pf_encap_t , c_int , pfdp class ( pf_imk_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: q , q0 end subroutine pf_propagate_p subroutine pf_commutator_p ( this , a , b , out , flags ) import pf_imk_t , pf_encap_t , c_int , pfdp class ( pf_imk_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: a , b , out integer , intent ( in ), optional :: flags end subroutine pf_commutator_p end interface contains !> Perform nsweep  sweeps on level  and set qend appropriately. ! with the two-array encap, things are a little tricky ! copy default behavior : copy the solution only ! copy flagged behavior : copy the name of the encap ! setval default behavior : set the value of the name of the encap ! setval flagged behavior : set the value of the solution subroutine imk_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level this % t0 = t0 this % dt = dt if ( this % rk ) then call rk_step ( this , pf , t0 , dt ) else if ( this % mkrk ) then call mkrk_step ( this , pf , t0 , dt ) else call imk_actually_sweep ( this , pf , level_index , t0 , dt , nsweeps ) end if end subroutine imk_sweep subroutine rk_step ( this , pf , t0 , dt ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: m !!  Loop variables real ( pfdp ) :: t !!  Time at nodes t = t0 + dt lev => pf % levels ( 1 ) do m = 1 , 5 call lev % Q ( m )% setval ( 0.0_pfdp ) end do call call_hooks ( pf , 1 , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) ! commutator_p flags=1 hack copies Q(1)%y -> Q(1)%array ! all subsequent RK stages are done on Q(m)%array call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 1 ) call lev % Q ( 2 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) ! commutator_p flags=2 hack copies Q(m)%array -> Q(m)%y ! only the Q argument in this case matters ! in order to get solution back to qend call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 5 ), lev % Q ( 5 ), lev % F ( 1 , 1 ), flags = 2 ) call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) call call_hooks ( pf , 1 , PF_POST_SWEEP ) end subroutine rk_step subroutine mkrk_step ( this , pf , t0 , dt ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: m !!  Loop variables real ( pfdp ) :: t !!  Time at nodes lev => pf % levels ( 1 ) t = t0 + dt do m = 1 , 5 call lev % Q ( m )% setval ( 0.0_pfdp ) end do call call_hooks ( pf , 1 , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) call this % dexpinv ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 2 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % dexpinv ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 3 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % dexpinv ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 4 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % dexpinv ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 5 )) call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) call call_hooks ( pf , 1 , PF_POST_SWEEP ) end subroutine mkrk_step subroutine imk_actually_sweep ( this , pf , level_index , t0 , dt , nsweeps ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: m , n , k !!  Loop variables real ( pfdp ) :: t !!  Time at nodes lev => pf % levels ( level_index ) !!  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps !!  Loop over sweeps ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) end do if ( level_index < pf % nlevels ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% setval ( 0.0_pfdp ) ! likely an unnecessary setting of Omega=0 call this % evaluate ( lev , t0 , 1 ) end if t = t0 ! do the sub-stepping in sweep do m = 1 , lev % nnodes - 1 !!  Loop over substeps t = t + dt * this % dtsdc ( m ) !>  Accumulate rhs call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) do n = 1 , m call lev % Q ( m + 1 )% axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) end do !>  Add the tau term call lev % Q ( m + 1 )% axpy ( 1.0_pfdp , lev % I ( m )) !>  Compute explicit function on new value call this % evaluate ( lev , t , m + 1 ) end do !!  End substep loop call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imk_actually_sweep subroutine imk_initialize ( this , lev ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev integer :: m , nnodes this % npieces = 1 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes ), this % QtilE ( nnodes - 1 , nnodes )) allocate ( this % dtsdc ( nnodes - 1 )) allocate ( this % tsdc ( nnodes )) this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) this % bernoullis = 0.0_pfdp this % bernoullis ( 1 ) = - 1.0_pfdp / 2.0_pfdp this % bernoullis ( 2 ) = 1.0_pfdp / 6.0_pfdp this % bernoullis ( 4 ) = - 1.0_pfdp / 3.0e1_pfdp this % bernoullis ( 6 ) = 1.0_pfdp / 4.2e1_pfdp this % bernoullis ( 8 ) = - 1.0_pfdp / 3.0e1_pfdp this % bernoullis ( 10 ) = 5.0_pfdp / 6.6e1_pfdp this % bernoullis ( 12 ) = - 69 1.0_pfdp / 2.73e3_pfdp this % bernoullis ( 14 ) = 7.0_pfdp / 6.0_pfdp this % bernoullis ( 16 ) = - 361 7.0_pfdp / 5.10e2_pfdp this % bernoullis ( 18 ) = 4386 7.0_pfdp / 7.98e2_pfdp this % bernoullis ( 20 ) = - 17461 1.0_pfdp / 33 0.0_pfdp !>  Assign explicit approximate quadrature rule this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE !>  Make space for temporary variables call lev % ulevel % factory % create_array ( this % A , nnodes , & lev % index , lev % shape ) do m = 1 , nnodes call this % A ( m )% setval ( 0.0_pfdp ) end do end subroutine imk_initialize subroutine imk_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: j , m do m = 1 , lev % nnodes - 1 call fintSDC ( m )% setval ( 0.0_pfdp ) do j = 1 , lev % nnodes call fintSDC ( m )% axpy ( dt * lev % sdcmats % qmat ( m , j ), fSDC ( j , 1 )) end do end do end subroutine imk_integrate subroutine imk_evaluate ( this , lev , t , m , flags , step ) use pf_mod_dtype class ( pf_imk_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev integer , optional , intent ( in ) :: flags , step integer :: i real ( pfdp ) :: dt !  Propagate to get y=exp(Om) !prop needs e&#94;{Q (omega)} and apply to Y if ( this % debug ) & print * , 'level' , lev % index , 'in evaluate ' , m , '------------------' if ( this % rk ) then ! 't' in f_evals are meaningless since i have a time-independent matrix, A dt = this % dt do i = 1 , 5 call lev % Q ( i )% setval ( 0.0_pfdp ) end do call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) ! commutator_p flags=1 hack copies Q(1)%y -> Q(1)%array ! all subsequent RK stages are done on Q(m)%array call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 1 ) call lev % Q ( 2 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) ! commutator_p flags=2 hack copies Q(m)%array -> Q(m)%y ! only the Q argument in this case matters ! in order to get solution back to qend call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 5 ), lev % Q ( 5 ), lev % F ( 1 , 1 ), flags = 2 ) else if ( this % debug ) then endif if ( m > 1 ) then if ( this % debug ) print * , 'propagating' call this % propagate ( lev % q0 , lev % Q ( m )) else if ( this % debug ) print * , 'copying' call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) end if if ( this % debug ) print * , 'Q' if ( this % debug ) call lev % Q ( m )% eprint () !  Compute A(y,t) call this % f_eval ( lev % Q ( m ), t , lev % index , this % A ( m )) if ( this % debug ) print * , 'A' if ( this % debug ) call this % A ( m )% eprint () !  Compute the series expansion for dexpinv if ( m > 1 ) then call this % dexpinv ( this % A ( m ), lev % Q ( m ), lev % F ( m , 1 )) else call lev % F ( 1 , 1 )% copy ( this % A ( 1 )) endif if ( this % debug ) print * , 'depxinv' if ( this % debug ) call lev % F ( m , 1 )% eprint () endif if ( this % debug ) print * , 'end evaluate ------------' end subroutine imk_evaluate subroutine imk_evaluate_all ( this , lev , t , flags , step ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step integer :: m if ( this % rk ) then call lev % ulevel % sweeper % evaluate ( lev , t ( 1 ), 1 ) else do m = 1 , lev % nnodes call lev % ulevel % sweeper % evaluate ( lev , t ( m ), m ) end do end if end subroutine imk_evaluate_all subroutine imk_residual ( this , lev , dt , flags ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m call lev % ulevel % sweeper % integrate ( lev , lev % Q , lev % F , dt , lev % I ) ! add tau (which is 'node to node') if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end do end if ! subtract out Q  (not initial condition is zero do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end subroutine imk_residual subroutine imk_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer m , p !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) ! set initial omega to 0 call lev % Q ( 1 )% setval ( 0.0_pfdp ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , 1 ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), flags = 1 ) call lev % Q ( m )% copy ( lev % Q ( 1 )) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p )) end do end do end subroutine imk_spreadq0 !>  Save function values so that difference can be computed subroutine imk_save ( lev ) class ( pf_level_t ), intent ( inout ) :: lev !!  Level to save on integer :: m do m = 1 , lev % nnodes call lev % pF ( m , 1 )% copy ( lev % F ( m , 1 )) end do end subroutine imk_save subroutine imk_destroy ( this , lev ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QtilE , this % QdiffE ) deallocate ( this % dtsdc ) deallocate ( this % tsdc ) call lev % ulevel % factory % destroy_array ( this % A , lev % nnodes , & lev % index , lev % shape ) end subroutine imk_destroy end module pf_mod_imk","tags":"","loc":"sourcefile/pf_imk.f90.html","title":"pf_imk.f90 – LibPFASST"},{"text":"Contents Subroutines CFFTB1 CFFTF1 CFFTI1 PASSB2 PASSB3 PASSB4 PASSB5 PASSB PASSF2 PASSF3 PASSF4 PASSF5 PASSF RADB2 RADB3 RADB4 RADB5 RADBG RADF2 RADF3 RADF4 RADF5 RADFG RFFTB1 RFFTF1 RFFTI1 ZFFTB ZFFTF ZFFTI Source Code dfftpack.f Source Code C     Files taken from http://www.netlib.org/fftpack/ C     file\tdp.tgz C     for\tdouble precision clone of fftpack C     by\tHugh C. Pumphrey <hcp@met.ed.ac.uk> C     prec\tdouble C     lang\tFortran C     gams\tJ1a SUBROUTINE CFFTB1 ( N , C , CH , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( * ) , C ( * ) , WA ( * ) , IFAC ( * ) NF = IFAC ( 2 ) NA = 0 L1 = 1 IW = 1 DO 116 K1 = 1 , NF IP = IFAC ( K1 + 2 ) L2 = IP * L1 IDO = N / L2 IDOT = IDO + IDO IDL1 = IDOT * L1 IF ( IP . NE . 4 ) GO TO 103 IX2 = IW + IDOT IX3 = IX2 + IDOT IF ( NA . NE . 0 ) GO TO 101 CALL PASSB4 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 )) GO TO 102 101 CALL PASSB4 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 )) 102 NA = 1 - NA GO TO 115 103 IF ( IP . NE . 2 ) GO TO 106 IF ( NA . NE . 0 ) GO TO 104 CALL PASSB2 ( IDOT , L1 , C , CH , WA ( IW )) GO TO 105 104 CALL PASSB2 ( IDOT , L1 , CH , C , WA ( IW )) 105 NA = 1 - NA GO TO 115 106 IF ( IP . NE . 3 ) GO TO 109 IX2 = IW + IDOT IF ( NA . NE . 0 ) GO TO 107 CALL PASSB3 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 )) GO TO 108 107 CALL PASSB3 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 )) 108 NA = 1 - NA GO TO 115 109 IF ( IP . NE . 5 ) GO TO 112 IX2 = IW + IDOT IX3 = IX2 + IDOT IX4 = IX3 + IDOT IF ( NA . NE . 0 ) GO TO 110 CALL PASSB5 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) GO TO 111 110 CALL PASSB5 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) 111 NA = 1 - NA GO TO 115 112 IF ( NA . NE . 0 ) GO TO 113 CALL PASSB ( NAC , IDOT , IP , L1 , IDL1 , C , C , C , CH , CH , WA ( IW )) GO TO 114 113 CALL PASSB ( NAC , IDOT , IP , L1 , IDL1 , CH , CH , CH , C , C , WA ( IW )) 114 IF ( NAC . NE . 0 ) NA = 1 - NA 115 L1 = L2 IW = IW + ( IP - 1 ) * IDOT 116 CONTINUE IF ( NA . EQ . 0 ) RETURN N2 = N + N DO 117 I = 1 , N2 C ( I ) = CH ( I ) 117 CONTINUE RETURN END SUBROUTINE CFFTF1 ( N , C , CH , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( * ) , C ( * ) , WA ( * ) , IFAC ( * ) NF = IFAC ( 2 ) NA = 0 L1 = 1 IW = 1 DO 116 K1 = 1 , NF IP = IFAC ( K1 + 2 ) L2 = IP * L1 IDO = N / L2 IDOT = IDO + IDO IDL1 = IDOT * L1 IF ( IP . NE . 4 ) GO TO 103 IX2 = IW + IDOT IX3 = IX2 + IDOT IF ( NA . NE . 0 ) GO TO 101 CALL PASSF4 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 )) GO TO 102 101 CALL PASSF4 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 )) 102 NA = 1 - NA GO TO 115 103 IF ( IP . NE . 2 ) GO TO 106 IF ( NA . NE . 0 ) GO TO 104 CALL PASSF2 ( IDOT , L1 , C , CH , WA ( IW )) GO TO 105 104 CALL PASSF2 ( IDOT , L1 , CH , C , WA ( IW )) 105 NA = 1 - NA GO TO 115 106 IF ( IP . NE . 3 ) GO TO 109 IX2 = IW + IDOT IF ( NA . NE . 0 ) GO TO 107 CALL PASSF3 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 )) GO TO 108 107 CALL PASSF3 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 )) 108 NA = 1 - NA GO TO 115 109 IF ( IP . NE . 5 ) GO TO 112 IX2 = IW + IDOT IX3 = IX2 + IDOT IX4 = IX3 + IDOT IF ( NA . NE . 0 ) GO TO 110 CALL PASSF5 ( IDOT , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) GO TO 111 110 CALL PASSF5 ( IDOT , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) 111 NA = 1 - NA GO TO 115 112 IF ( NA . NE . 0 ) GO TO 113 CALL PASSF ( NAC , IDOT , IP , L1 , IDL1 , C , C , C , CH , CH , WA ( IW )) GO TO 114 113 CALL PASSF ( NAC , IDOT , IP , L1 , IDL1 , CH , CH , CH , C , C , WA ( IW )) 114 IF ( NAC . NE . 0 ) NA = 1 - NA 115 L1 = L2 IW = IW + ( IP - 1 ) * IDOT 116 CONTINUE IF ( NA . EQ . 0 ) RETURN N2 = N + N DO 117 I = 1 , N2 C ( I ) = CH ( I ) 117 CONTINUE RETURN END SUBROUTINE CFFTI1 ( N , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION WA ( * ) , IFAC ( * ) , NTRYH ( 4 ) DATA NTRYH ( 1 ), NTRYH ( 2 ), NTRYH ( 3 ), NTRYH ( 4 ) / 3 , 4 , 2 , 5 / NL = N NF = 0 J = 0 101 J = J + 1 IF ( J - 4 ) 102 , 102 , 103 102 NTRY = NTRYH ( J ) GO TO 104 103 NTRY = NTRY + 2 104 NQ = NL / NTRY NR = NL - NTRY * NQ IF ( NR ) 101 , 105 , 101 105 NF = NF + 1 IFAC ( NF + 2 ) = NTRY NL = NQ IF ( NTRY . NE . 2 ) GO TO 107 IF ( NF . EQ . 1 ) GO TO 107 DO 106 I = 2 , NF IB = NF - I + 2 IFAC ( IB + 2 ) = IFAC ( IB + 1 ) 106 CONTINUE IFAC ( 3 ) = 2 107 IF ( NL . NE . 1 ) GO TO 104 IFAC ( 1 ) = N IFAC ( 2 ) = NF TPI = 6.28318530717958647692D0 ARGH = TPI / FLOAT ( N ) I = 2 L1 = 1 DO 110 K1 = 1 , NF IP = IFAC ( K1 + 2 ) LD = 0 L2 = L1 * IP IDO = N / L2 IDOT = IDO + IDO + 2 IPM = IP - 1 DO 109 J = 1 , IPM I1 = I WA ( I - 1 ) = 1.0D0 WA ( I ) = 0.0D0 LD = LD + L1 FI = 0.0D0 ARGLD = FLOAT ( LD ) * ARGH DO 108 II = 4 , IDOT , 2 I = I + 2 FI = FI + 1.D0 ARG = FI * ARGLD WA ( I - 1 ) = COS ( ARG ) WA ( I ) = SIN ( ARG ) 108 CONTINUE IF ( IP . LE . 5 ) GO TO 109 WA ( I1 - 1 ) = WA ( I - 1 ) WA ( I1 ) = WA ( I ) 109 CONTINUE L1 = L2 110 CONTINUE RETURN END SUBROUTINE PASSB2 ( IDO , L1 , CC , CH , WA1 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 2 , L1 ) , CH ( IDO , L1 , 2 ) , 1 WA1 ( 1 ) IF ( IDO . GT . 2 ) GO TO 102 DO 101 K = 1 , L1 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + CC ( 1 , 2 , K ) CH ( 1 , K , 2 ) = CC ( 1 , 1 , K ) - CC ( 1 , 2 , K ) CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + CC ( 2 , 2 , K ) CH ( 2 , K , 2 ) = CC ( 2 , 1 , K ) - CC ( 2 , 2 , K ) 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + CC ( I - 1 , 2 , K ) TR2 = CC ( I - 1 , 1 , K ) - CC ( I - 1 , 2 , K ) CH ( I , K , 1 ) = CC ( I , 1 , K ) + CC ( I , 2 , K ) TI2 = CC ( I , 1 , K ) - CC ( I , 2 , K ) CH ( I , K , 2 ) = WA1 ( I - 1 ) * TI2 + WA1 ( I ) * TR2 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * TR2 - WA1 ( I ) * TI2 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSB3 ( IDO , L1 , CC , CH , WA1 , WA2 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 3 , L1 ) , CH ( IDO , L1 , 3 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) C     *** TAUI IS SQRT(3)/2 *** DATA TAUR , TAUI /- 0.5D0 , 0.86602540378443864676D0 / IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TR2 = CC ( 1 , 2 , K ) + CC ( 1 , 3 , K ) CR2 = CC ( 1 , 1 , K ) + TAUR * TR2 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 TI2 = CC ( 2 , 2 , K ) + CC ( 2 , 3 , K ) CI2 = CC ( 2 , 1 , K ) + TAUR * TI2 CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + TI2 CR3 = TAUI * ( CC ( 1 , 2 , K ) - CC ( 1 , 3 , K )) CI3 = TAUI * ( CC ( 2 , 2 , K ) - CC ( 2 , 3 , K )) CH ( 1 , K , 2 ) = CR2 - CI3 CH ( 1 , K , 3 ) = CR2 + CI3 CH ( 2 , K , 2 ) = CI2 + CR3 CH ( 2 , K , 3 ) = CI2 - CR3 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TR2 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 3 , K ) CR2 = CC ( I - 1 , 1 , K ) + TAUR * TR2 CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 TI2 = CC ( I , 2 , K ) + CC ( I , 3 , K ) CI2 = CC ( I , 1 , K ) + TAUR * TI2 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 CR3 = TAUI * ( CC ( I - 1 , 2 , K ) - CC ( I - 1 , 3 , K )) CI3 = TAUI * ( CC ( I , 2 , K ) - CC ( I , 3 , K )) DR2 = CR2 - CI3 DR3 = CR2 + CI3 DI2 = CI2 + CR3 DI3 = CI2 - CR3 CH ( I , K , 2 ) = WA1 ( I - 1 ) * DI2 + WA1 ( I ) * DR2 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * DR2 - WA1 ( I ) * DI2 CH ( I , K , 3 ) = WA2 ( I - 1 ) * DI3 + WA2 ( I ) * DR3 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * DR3 - WA2 ( I ) * DI3 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSB4 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 4 , L1 ) , CH ( IDO , L1 , 4 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TI1 = CC ( 2 , 1 , K ) - CC ( 2 , 3 , K ) TI2 = CC ( 2 , 1 , K ) + CC ( 2 , 3 , K ) TR4 = CC ( 2 , 4 , K ) - CC ( 2 , 2 , K ) TI3 = CC ( 2 , 2 , K ) + CC ( 2 , 4 , K ) TR1 = CC ( 1 , 1 , K ) - CC ( 1 , 3 , K ) TR2 = CC ( 1 , 1 , K ) + CC ( 1 , 3 , K ) TI4 = CC ( 1 , 2 , K ) - CC ( 1 , 4 , K ) TR3 = CC ( 1 , 2 , K ) + CC ( 1 , 4 , K ) CH ( 1 , K , 1 ) = TR2 + TR3 CH ( 1 , K , 3 ) = TR2 - TR3 CH ( 2 , K , 1 ) = TI2 + TI3 CH ( 2 , K , 3 ) = TI2 - TI3 CH ( 1 , K , 2 ) = TR1 + TR4 CH ( 1 , K , 4 ) = TR1 - TR4 CH ( 2 , K , 2 ) = TI1 + TI4 CH ( 2 , K , 4 ) = TI1 - TI4 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TI1 = CC ( I , 1 , K ) - CC ( I , 3 , K ) TI2 = CC ( I , 1 , K ) + CC ( I , 3 , K ) TI3 = CC ( I , 2 , K ) + CC ( I , 4 , K ) TR4 = CC ( I , 4 , K ) - CC ( I , 2 , K ) TR1 = CC ( I - 1 , 1 , K ) - CC ( I - 1 , 3 , K ) TR2 = CC ( I - 1 , 1 , K ) + CC ( I - 1 , 3 , K ) TI4 = CC ( I - 1 , 2 , K ) - CC ( I - 1 , 4 , K ) TR3 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 4 , K ) CH ( I - 1 , K , 1 ) = TR2 + TR3 CR3 = TR2 - TR3 CH ( I , K , 1 ) = TI2 + TI3 CI3 = TI2 - TI3 CR2 = TR1 + TR4 CR4 = TR1 - TR4 CI2 = TI1 + TI4 CI4 = TI1 - TI4 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * CR2 - WA1 ( I ) * CI2 CH ( I , K , 2 ) = WA1 ( I - 1 ) * CI2 + WA1 ( I ) * CR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * CR3 - WA2 ( I ) * CI3 CH ( I , K , 3 ) = WA2 ( I - 1 ) * CI3 + WA2 ( I ) * CR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 1 ) * CR4 - WA3 ( I ) * CI4 CH ( I , K , 4 ) = WA3 ( I - 1 ) * CI4 + WA3 ( I ) * CR4 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSB5 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 , WA4 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 5 , L1 ) , CH ( IDO , L1 , 5 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) , WA4 ( 1 ) C     *** TR11=COS(2*PI/5), TI11=SIN(2*PI/5) C     *** TR12=COS(4*PI/5), TI12=SIN(4*PI/5) DATA TR11 , TI11 , TR12 , TI12 / 0.3090169943749474241D0 , + 0.95105651629515357212D0 , + - 0.8090169943749474241D0 , 0.58778525229247312917D0 / IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TI5 = CC ( 2 , 2 , K ) - CC ( 2 , 5 , K ) TI2 = CC ( 2 , 2 , K ) + CC ( 2 , 5 , K ) TI4 = CC ( 2 , 3 , K ) - CC ( 2 , 4 , K ) TI3 = CC ( 2 , 3 , K ) + CC ( 2 , 4 , K ) TR5 = CC ( 1 , 2 , K ) - CC ( 1 , 5 , K ) TR2 = CC ( 1 , 2 , K ) + CC ( 1 , 5 , K ) TR4 = CC ( 1 , 3 , K ) - CC ( 1 , 4 , K ) TR3 = CC ( 1 , 3 , K ) + CC ( 1 , 4 , K ) CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 + TR3 CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + TI2 + TI3 CR2 = CC ( 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CI2 = CC ( 2 , 1 , K ) + TR11 * TI2 + TR12 * TI3 CR3 = CC ( 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI3 = CC ( 2 , 1 , K ) + TR12 * TI2 + TR11 * TI3 CR5 = TI11 * TR5 + TI12 * TR4 CI5 = TI11 * TI5 + TI12 * TI4 CR4 = TI12 * TR5 - TI11 * TR4 CI4 = TI12 * TI5 - TI11 * TI4 CH ( 1 , K , 2 ) = CR2 - CI5 CH ( 1 , K , 5 ) = CR2 + CI5 CH ( 2 , K , 2 ) = CI2 + CR5 CH ( 2 , K , 3 ) = CI3 + CR4 CH ( 1 , K , 3 ) = CR3 - CI4 CH ( 1 , K , 4 ) = CR3 + CI4 CH ( 2 , K , 4 ) = CI3 - CR4 CH ( 2 , K , 5 ) = CI2 - CR5 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TI5 = CC ( I , 2 , K ) - CC ( I , 5 , K ) TI2 = CC ( I , 2 , K ) + CC ( I , 5 , K ) TI4 = CC ( I , 3 , K ) - CC ( I , 4 , K ) TI3 = CC ( I , 3 , K ) + CC ( I , 4 , K ) TR5 = CC ( I - 1 , 2 , K ) - CC ( I - 1 , 5 , K ) TR2 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 5 , K ) TR4 = CC ( I - 1 , 3 , K ) - CC ( I - 1 , 4 , K ) TR3 = CC ( I - 1 , 3 , K ) + CC ( I - 1 , 4 , K ) CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 + TR3 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 + TI3 CR2 = CC ( I - 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CI2 = CC ( I , 1 , K ) + TR11 * TI2 + TR12 * TI3 CR3 = CC ( I - 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI3 = CC ( I , 1 , K ) + TR12 * TI2 + TR11 * TI3 CR5 = TI11 * TR5 + TI12 * TR4 CI5 = TI11 * TI5 + TI12 * TI4 CR4 = TI12 * TR5 - TI11 * TR4 CI4 = TI12 * TI5 - TI11 * TI4 DR3 = CR3 - CI4 DR4 = CR3 + CI4 DI3 = CI3 + CR4 DI4 = CI3 - CR4 DR5 = CR2 + CI5 DR2 = CR2 - CI5 DI5 = CI2 - CR5 DI2 = CI2 + CR5 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * DR2 - WA1 ( I ) * DI2 CH ( I , K , 2 ) = WA1 ( I - 1 ) * DI2 + WA1 ( I ) * DR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * DR3 - WA2 ( I ) * DI3 CH ( I , K , 3 ) = WA2 ( I - 1 ) * DI3 + WA2 ( I ) * DR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 1 ) * DR4 - WA3 ( I ) * DI4 CH ( I , K , 4 ) = WA3 ( I - 1 ) * DI4 + WA3 ( I ) * DR4 CH ( I - 1 , K , 5 ) = WA4 ( I - 1 ) * DR5 - WA4 ( I ) * DI5 CH ( I , K , 5 ) = WA4 ( I - 1 ) * DI5 + WA4 ( I ) * DR5 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSB ( NAC , IDO , IP , L1 , IDL1 , CC , C1 , C2 , CH , CH2 , WA ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , L1 , IP ) , CC ( IDO , IP , L1 ) , 1 C1 ( IDO , L1 , IP ) , WA ( 1 ) , C2 ( IDL1 , IP ), 2 CH2 ( IDL1 , IP ) IDOT = IDO / 2 NT = IP * IDL1 IPP2 = IP + 2 IPPH = ( IP + 1 ) / 2 IDP = IP * IDO C IF ( IDO . LT . L1 ) GO TO 106 DO 103 J = 2 , IPPH JC = IPP2 - J DO 102 K = 1 , L1 DO 101 I = 1 , IDO CH ( I , K , J ) = CC ( I , J , K ) + CC ( I , JC , K ) CH ( I , K , JC ) = CC ( I , J , K ) - CC ( I , JC , K ) 101 CONTINUE 102 CONTINUE 103 CONTINUE DO 105 K = 1 , L1 DO 104 I = 1 , IDO CH ( I , K , 1 ) = CC ( I , 1 , K ) 104 CONTINUE 105 CONTINUE GO TO 112 106 DO 109 J = 2 , IPPH JC = IPP2 - J DO 108 I = 1 , IDO DO 107 K = 1 , L1 CH ( I , K , J ) = CC ( I , J , K ) + CC ( I , JC , K ) CH ( I , K , JC ) = CC ( I , J , K ) - CC ( I , JC , K ) 107 CONTINUE 108 CONTINUE 109 CONTINUE DO 111 I = 1 , IDO DO 110 K = 1 , L1 CH ( I , K , 1 ) = CC ( I , 1 , K ) 110 CONTINUE 111 CONTINUE 112 IDL = 2 - IDO INC = 0 DO 116 L = 2 , IPPH LC = IPP2 - L IDL = IDL + IDO DO 113 IK = 1 , IDL1 C2 ( IK , L ) = CH2 ( IK , 1 ) + WA ( IDL - 1 ) * CH2 ( IK , 2 ) C2 ( IK , LC ) = WA ( IDL ) * CH2 ( IK , IP ) 113 CONTINUE IDLJ = IDL INC = INC + IDO DO 115 J = 3 , IPPH JC = IPP2 - J IDLJ = IDLJ + INC IF ( IDLJ . GT . IDP ) IDLJ = IDLJ - IDP WAR = WA ( IDLJ - 1 ) WAI = WA ( IDLJ ) DO 114 IK = 1 , IDL1 C2 ( IK , L ) = C2 ( IK , L ) + WAR * CH2 ( IK , J ) C2 ( IK , LC ) = C2 ( IK , LC ) + WAI * CH2 ( IK , JC ) 114 CONTINUE 115 CONTINUE 116 CONTINUE DO 118 J = 2 , IPPH DO 117 IK = 1 , IDL1 CH2 ( IK , 1 ) = CH2 ( IK , 1 ) + CH2 ( IK , J ) 117 CONTINUE 118 CONTINUE DO 120 J = 2 , IPPH JC = IPP2 - J DO 119 IK = 2 , IDL1 , 2 CH2 ( IK - 1 , J ) = C2 ( IK - 1 , J ) - C2 ( IK , JC ) CH2 ( IK - 1 , JC ) = C2 ( IK - 1 , J ) + C2 ( IK , JC ) CH2 ( IK , J ) = C2 ( IK , J ) + C2 ( IK - 1 , JC ) CH2 ( IK , JC ) = C2 ( IK , J ) - C2 ( IK - 1 , JC ) 119 CONTINUE 120 CONTINUE NAC = 1 IF ( IDO . EQ . 2 ) RETURN NAC = 0 DO 121 IK = 1 , IDL1 C2 ( IK , 1 ) = CH2 ( IK , 1 ) 121 CONTINUE DO 123 J = 2 , IP DO 122 K = 1 , L1 C1 ( 1 , K , J ) = CH ( 1 , K , J ) C1 ( 2 , K , J ) = CH ( 2 , K , J ) 122 CONTINUE 123 CONTINUE IF ( IDOT . GT . L1 ) GO TO 127 IDIJ = 0 DO 126 J = 2 , IP IDIJ = IDIJ + 2 DO 125 I = 4 , IDO , 2 IDIJ = IDIJ + 2 DO 124 K = 1 , L1 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) - WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) + WA ( IDIJ ) * CH ( I - 1 , K , J ) 124 CONTINUE 125 CONTINUE 126 CONTINUE RETURN 127 IDJ = 2 - IDO DO 130 J = 2 , IP IDJ = IDJ + IDO DO 129 K = 1 , L1 IDIJ = IDJ DO 128 I = 4 , IDO , 2 IDIJ = IDIJ + 2 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) - WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) + WA ( IDIJ ) * CH ( I - 1 , K , J ) 128 CONTINUE 129 CONTINUE 130 CONTINUE RETURN END SUBROUTINE PASSF2 ( IDO , L1 , CC , CH , WA1 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 2 , L1 ) , CH ( IDO , L1 , 2 ) , 1 WA1 ( 1 ) IF ( IDO . GT . 2 ) GO TO 102 DO 101 K = 1 , L1 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + CC ( 1 , 2 , K ) CH ( 1 , K , 2 ) = CC ( 1 , 1 , K ) - CC ( 1 , 2 , K ) CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + CC ( 2 , 2 , K ) CH ( 2 , K , 2 ) = CC ( 2 , 1 , K ) - CC ( 2 , 2 , K ) 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + CC ( I - 1 , 2 , K ) TR2 = CC ( I - 1 , 1 , K ) - CC ( I - 1 , 2 , K ) CH ( I , K , 1 ) = CC ( I , 1 , K ) + CC ( I , 2 , K ) TI2 = CC ( I , 1 , K ) - CC ( I , 2 , K ) CH ( I , K , 2 ) = WA1 ( I - 1 ) * TI2 - WA1 ( I ) * TR2 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * TR2 + WA1 ( I ) * TI2 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSF3 ( IDO , L1 , CC , CH , WA1 , WA2 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 3 , L1 ) , CH ( IDO , L1 , 3 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) C     *** TAUI IS -SQRT(3)/2 *** DATA TAUR , TAUI /- 0.5D0 , - 0.86602540378443864676D0 / IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TR2 = CC ( 1 , 2 , K ) + CC ( 1 , 3 , K ) CR2 = CC ( 1 , 1 , K ) + TAUR * TR2 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 TI2 = CC ( 2 , 2 , K ) + CC ( 2 , 3 , K ) CI2 = CC ( 2 , 1 , K ) + TAUR * TI2 CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + TI2 CR3 = TAUI * ( CC ( 1 , 2 , K ) - CC ( 1 , 3 , K )) CI3 = TAUI * ( CC ( 2 , 2 , K ) - CC ( 2 , 3 , K )) CH ( 1 , K , 2 ) = CR2 - CI3 CH ( 1 , K , 3 ) = CR2 + CI3 CH ( 2 , K , 2 ) = CI2 + CR3 CH ( 2 , K , 3 ) = CI2 - CR3 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TR2 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 3 , K ) CR2 = CC ( I - 1 , 1 , K ) + TAUR * TR2 CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 TI2 = CC ( I , 2 , K ) + CC ( I , 3 , K ) CI2 = CC ( I , 1 , K ) + TAUR * TI2 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 CR3 = TAUI * ( CC ( I - 1 , 2 , K ) - CC ( I - 1 , 3 , K )) CI3 = TAUI * ( CC ( I , 2 , K ) - CC ( I , 3 , K )) DR2 = CR2 - CI3 DR3 = CR2 + CI3 DI2 = CI2 + CR3 DI3 = CI2 - CR3 CH ( I , K , 2 ) = WA1 ( I - 1 ) * DI2 - WA1 ( I ) * DR2 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * DR2 + WA1 ( I ) * DI2 CH ( I , K , 3 ) = WA2 ( I - 1 ) * DI3 - WA2 ( I ) * DR3 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * DR3 + WA2 ( I ) * DI3 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSF4 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 4 , L1 ) , CH ( IDO , L1 , 4 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TI1 = CC ( 2 , 1 , K ) - CC ( 2 , 3 , K ) TI2 = CC ( 2 , 1 , K ) + CC ( 2 , 3 , K ) TR4 = CC ( 2 , 2 , K ) - CC ( 2 , 4 , K ) TI3 = CC ( 2 , 2 , K ) + CC ( 2 , 4 , K ) TR1 = CC ( 1 , 1 , K ) - CC ( 1 , 3 , K ) TR2 = CC ( 1 , 1 , K ) + CC ( 1 , 3 , K ) TI4 = CC ( 1 , 4 , K ) - CC ( 1 , 2 , K ) TR3 = CC ( 1 , 2 , K ) + CC ( 1 , 4 , K ) CH ( 1 , K , 1 ) = TR2 + TR3 CH ( 1 , K , 3 ) = TR2 - TR3 CH ( 2 , K , 1 ) = TI2 + TI3 CH ( 2 , K , 3 ) = TI2 - TI3 CH ( 1 , K , 2 ) = TR1 + TR4 CH ( 1 , K , 4 ) = TR1 - TR4 CH ( 2 , K , 2 ) = TI1 + TI4 CH ( 2 , K , 4 ) = TI1 - TI4 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TI1 = CC ( I , 1 , K ) - CC ( I , 3 , K ) TI2 = CC ( I , 1 , K ) + CC ( I , 3 , K ) TI3 = CC ( I , 2 , K ) + CC ( I , 4 , K ) TR4 = CC ( I , 2 , K ) - CC ( I , 4 , K ) TR1 = CC ( I - 1 , 1 , K ) - CC ( I - 1 , 3 , K ) TR2 = CC ( I - 1 , 1 , K ) + CC ( I - 1 , 3 , K ) TI4 = CC ( I - 1 , 4 , K ) - CC ( I - 1 , 2 , K ) TR3 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 4 , K ) CH ( I - 1 , K , 1 ) = TR2 + TR3 CR3 = TR2 - TR3 CH ( I , K , 1 ) = TI2 + TI3 CI3 = TI2 - TI3 CR2 = TR1 + TR4 CR4 = TR1 - TR4 CI2 = TI1 + TI4 CI4 = TI1 - TI4 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * CR2 + WA1 ( I ) * CI2 CH ( I , K , 2 ) = WA1 ( I - 1 ) * CI2 - WA1 ( I ) * CR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * CR3 + WA2 ( I ) * CI3 CH ( I , K , 3 ) = WA2 ( I - 1 ) * CI3 - WA2 ( I ) * CR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 1 ) * CR4 + WA3 ( I ) * CI4 CH ( I , K , 4 ) = WA3 ( I - 1 ) * CI4 - WA3 ( I ) * CR4 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSF5 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 , WA4 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 5 , L1 ) , CH ( IDO , L1 , 5 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) , WA4 ( 1 ) C     *** TR11=COS(2*PI/5), TI11=-SIN(2*PI/5) C     *** TR12=-COS(4*PI/5), TI12=-SIN(4*PI/5) DATA TR11 , TI11 , TR12 , TI12 / 0.3090169943749474241D0 , + - 0.95105651629515357212D0 , 1 - 0.8090169943749474241D0 , - 0.58778525229247312917D0 / IF ( IDO . NE . 2 ) GO TO 102 DO 101 K = 1 , L1 TI5 = CC ( 2 , 2 , K ) - CC ( 2 , 5 , K ) TI2 = CC ( 2 , 2 , K ) + CC ( 2 , 5 , K ) TI4 = CC ( 2 , 3 , K ) - CC ( 2 , 4 , K ) TI3 = CC ( 2 , 3 , K ) + CC ( 2 , 4 , K ) TR5 = CC ( 1 , 2 , K ) - CC ( 1 , 5 , K ) TR2 = CC ( 1 , 2 , K ) + CC ( 1 , 5 , K ) TR4 = CC ( 1 , 3 , K ) - CC ( 1 , 4 , K ) TR3 = CC ( 1 , 3 , K ) + CC ( 1 , 4 , K ) CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 + TR3 CH ( 2 , K , 1 ) = CC ( 2 , 1 , K ) + TI2 + TI3 CR2 = CC ( 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CI2 = CC ( 2 , 1 , K ) + TR11 * TI2 + TR12 * TI3 CR3 = CC ( 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI3 = CC ( 2 , 1 , K ) + TR12 * TI2 + TR11 * TI3 CR5 = TI11 * TR5 + TI12 * TR4 CI5 = TI11 * TI5 + TI12 * TI4 CR4 = TI12 * TR5 - TI11 * TR4 CI4 = TI12 * TI5 - TI11 * TI4 CH ( 1 , K , 2 ) = CR2 - CI5 CH ( 1 , K , 5 ) = CR2 + CI5 CH ( 2 , K , 2 ) = CI2 + CR5 CH ( 2 , K , 3 ) = CI3 + CR4 CH ( 1 , K , 3 ) = CR3 - CI4 CH ( 1 , K , 4 ) = CR3 + CI4 CH ( 2 , K , 4 ) = CI3 - CR4 CH ( 2 , K , 5 ) = CI2 - CR5 101 CONTINUE RETURN 102 DO 104 K = 1 , L1 DO 103 I = 2 , IDO , 2 TI5 = CC ( I , 2 , K ) - CC ( I , 5 , K ) TI2 = CC ( I , 2 , K ) + CC ( I , 5 , K ) TI4 = CC ( I , 3 , K ) - CC ( I , 4 , K ) TI3 = CC ( I , 3 , K ) + CC ( I , 4 , K ) TR5 = CC ( I - 1 , 2 , K ) - CC ( I - 1 , 5 , K ) TR2 = CC ( I - 1 , 2 , K ) + CC ( I - 1 , 5 , K ) TR4 = CC ( I - 1 , 3 , K ) - CC ( I - 1 , 4 , K ) TR3 = CC ( I - 1 , 3 , K ) + CC ( I - 1 , 4 , K ) CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 + TR3 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 + TI3 CR2 = CC ( I - 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CI2 = CC ( I , 1 , K ) + TR11 * TI2 + TR12 * TI3 CR3 = CC ( I - 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI3 = CC ( I , 1 , K ) + TR12 * TI2 + TR11 * TI3 CR5 = TI11 * TR5 + TI12 * TR4 CI5 = TI11 * TI5 + TI12 * TI4 CR4 = TI12 * TR5 - TI11 * TR4 CI4 = TI12 * TI5 - TI11 * TI4 DR3 = CR3 - CI4 DR4 = CR3 + CI4 DI3 = CI3 + CR4 DI4 = CI3 - CR4 DR5 = CR2 + CI5 DR2 = CR2 - CI5 DI5 = CI2 - CR5 DI2 = CI2 + CR5 CH ( I - 1 , K , 2 ) = WA1 ( I - 1 ) * DR2 + WA1 ( I ) * DI2 CH ( I , K , 2 ) = WA1 ( I - 1 ) * DI2 - WA1 ( I ) * DR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 1 ) * DR3 + WA2 ( I ) * DI3 CH ( I , K , 3 ) = WA2 ( I - 1 ) * DI3 - WA2 ( I ) * DR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 1 ) * DR4 + WA3 ( I ) * DI4 CH ( I , K , 4 ) = WA3 ( I - 1 ) * DI4 - WA3 ( I ) * DR4 CH ( I - 1 , K , 5 ) = WA4 ( I - 1 ) * DR5 + WA4 ( I ) * DI5 CH ( I , K , 5 ) = WA4 ( I - 1 ) * DI5 - WA4 ( I ) * DR5 103 CONTINUE 104 CONTINUE RETURN END SUBROUTINE PASSF ( NAC , IDO , IP , L1 , IDL1 , CC , C1 , C2 , CH , CH2 , WA ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , L1 , IP ) , CC ( IDO , IP , L1 ) , 1 C1 ( IDO , L1 , IP ) , WA ( 1 ) , C2 ( IDL1 , IP ), 2 CH2 ( IDL1 , IP ) IDOT = IDO / 2 NT = IP * IDL1 IPP2 = IP + 2 IPPH = ( IP + 1 ) / 2 IDP = IP * IDO C IF ( IDO . LT . L1 ) GO TO 106 DO 103 J = 2 , IPPH JC = IPP2 - J DO 102 K = 1 , L1 DO 101 I = 1 , IDO CH ( I , K , J ) = CC ( I , J , K ) + CC ( I , JC , K ) CH ( I , K , JC ) = CC ( I , J , K ) - CC ( I , JC , K ) 101 CONTINUE 102 CONTINUE 103 CONTINUE DO 105 K = 1 , L1 DO 104 I = 1 , IDO CH ( I , K , 1 ) = CC ( I , 1 , K ) 104 CONTINUE 105 CONTINUE GO TO 112 106 DO 109 J = 2 , IPPH JC = IPP2 - J DO 108 I = 1 , IDO DO 107 K = 1 , L1 CH ( I , K , J ) = CC ( I , J , K ) + CC ( I , JC , K ) CH ( I , K , JC ) = CC ( I , J , K ) - CC ( I , JC , K ) 107 CONTINUE 108 CONTINUE 109 CONTINUE DO 111 I = 1 , IDO DO 110 K = 1 , L1 CH ( I , K , 1 ) = CC ( I , 1 , K ) 110 CONTINUE 111 CONTINUE 112 IDL = 2 - IDO INC = 0 DO 116 L = 2 , IPPH LC = IPP2 - L IDL = IDL + IDO DO 113 IK = 1 , IDL1 C2 ( IK , L ) = CH2 ( IK , 1 ) + WA ( IDL - 1 ) * CH2 ( IK , 2 ) C2 ( IK , LC ) = - WA ( IDL ) * CH2 ( IK , IP ) 113 CONTINUE IDLJ = IDL INC = INC + IDO DO 115 J = 3 , IPPH JC = IPP2 - J IDLJ = IDLJ + INC IF ( IDLJ . GT . IDP ) IDLJ = IDLJ - IDP WAR = WA ( IDLJ - 1 ) WAI = WA ( IDLJ ) DO 114 IK = 1 , IDL1 C2 ( IK , L ) = C2 ( IK , L ) + WAR * CH2 ( IK , J ) C2 ( IK , LC ) = C2 ( IK , LC ) - WAI * CH2 ( IK , JC ) 114 CONTINUE 115 CONTINUE 116 CONTINUE DO 118 J = 2 , IPPH DO 117 IK = 1 , IDL1 CH2 ( IK , 1 ) = CH2 ( IK , 1 ) + CH2 ( IK , J ) 117 CONTINUE 118 CONTINUE DO 120 J = 2 , IPPH JC = IPP2 - J DO 119 IK = 2 , IDL1 , 2 CH2 ( IK - 1 , J ) = C2 ( IK - 1 , J ) - C2 ( IK , JC ) CH2 ( IK - 1 , JC ) = C2 ( IK - 1 , J ) + C2 ( IK , JC ) CH2 ( IK , J ) = C2 ( IK , J ) + C2 ( IK - 1 , JC ) CH2 ( IK , JC ) = C2 ( IK , J ) - C2 ( IK - 1 , JC ) 119 CONTINUE 120 CONTINUE NAC = 1 IF ( IDO . EQ . 2 ) RETURN NAC = 0 DO 121 IK = 1 , IDL1 C2 ( IK , 1 ) = CH2 ( IK , 1 ) 121 CONTINUE DO 123 J = 2 , IP DO 122 K = 1 , L1 C1 ( 1 , K , J ) = CH ( 1 , K , J ) C1 ( 2 , K , J ) = CH ( 2 , K , J ) 122 CONTINUE 123 CONTINUE IF ( IDOT . GT . L1 ) GO TO 127 IDIJ = 0 DO 126 J = 2 , IP IDIJ = IDIJ + 2 DO 125 I = 4 , IDO , 2 IDIJ = IDIJ + 2 DO 124 K = 1 , L1 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) + WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) - WA ( IDIJ ) * CH ( I - 1 , K , J ) 124 CONTINUE 125 CONTINUE 126 CONTINUE RETURN 127 IDJ = 2 - IDO DO 130 J = 2 , IP IDJ = IDJ + IDO DO 129 K = 1 , L1 IDIJ = IDJ DO 128 I = 4 , IDO , 2 IDIJ = IDIJ + 2 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) + WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) - WA ( IDIJ ) * CH ( I - 1 , K , J ) 128 CONTINUE 129 CONTINUE 130 CONTINUE RETURN END SUBROUTINE RADB2 ( IDO , L1 , CC , CH , WA1 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 2 , L1 ) , CH ( IDO , L1 , 2 ) , 1 WA1 ( 1 ) DO 101 K = 1 , L1 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + CC ( IDO , 2 , K ) CH ( 1 , K , 2 ) = CC ( 1 , 1 , K ) - CC ( IDO , 2 , K ) 101 CONTINUE IF ( IDO - 2 ) 107 , 105 , 102 102 IDP2 = IDO + 2 DO 104 K = 1 , L1 DO 103 I = 3 , IDO , 2 IC = IDP2 - I CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + CC ( IC - 1 , 2 , K ) TR2 = CC ( I - 1 , 1 , K ) - CC ( IC - 1 , 2 , K ) CH ( I , K , 1 ) = CC ( I , 1 , K ) - CC ( IC , 2 , K ) TI2 = CC ( I , 1 , K ) + CC ( IC , 2 , K ) CH ( I - 1 , K , 2 ) = WA1 ( I - 2 ) * TR2 - WA1 ( I - 1 ) * TI2 CH ( I , K , 2 ) = WA1 ( I - 2 ) * TI2 + WA1 ( I - 1 ) * TR2 103 CONTINUE 104 CONTINUE IF ( MOD ( IDO , 2 ) . EQ . 1 ) RETURN 105 DO 106 K = 1 , L1 CH ( IDO , K , 1 ) = CC ( IDO , 1 , K ) + CC ( IDO , 1 , K ) CH ( IDO , K , 2 ) = - ( CC ( 1 , 2 , K ) + CC ( 1 , 2 , K )) 106 CONTINUE 107 RETURN END SUBROUTINE RADB3 ( IDO , L1 , CC , CH , WA1 , WA2 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 3 , L1 ) , CH ( IDO , L1 , 3 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) C     *** TAUI IS SQRT(3)/2 *** DATA TAUR , TAUI /- 0.5D0 , 0.86602540378443864676D0 / DO 101 K = 1 , L1 TR2 = CC ( IDO , 2 , K ) + CC ( IDO , 2 , K ) CR2 = CC ( 1 , 1 , K ) + TAUR * TR2 CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 CI3 = TAUI * ( CC ( 1 , 3 , K ) + CC ( 1 , 3 , K )) CH ( 1 , K , 2 ) = CR2 - CI3 CH ( 1 , K , 3 ) = CR2 + CI3 101 CONTINUE IF ( IDO . EQ . 1 ) RETURN IDP2 = IDO + 2 DO 103 K = 1 , L1 DO 102 I = 3 , IDO , 2 IC = IDP2 - I TR2 = CC ( I - 1 , 3 , K ) + CC ( IC - 1 , 2 , K ) CR2 = CC ( I - 1 , 1 , K ) + TAUR * TR2 CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 TI2 = CC ( I , 3 , K ) - CC ( IC , 2 , K ) CI2 = CC ( I , 1 , K ) + TAUR * TI2 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 CR3 = TAUI * ( CC ( I - 1 , 3 , K ) - CC ( IC - 1 , 2 , K )) CI3 = TAUI * ( CC ( I , 3 , K ) + CC ( IC , 2 , K )) DR2 = CR2 - CI3 DR3 = CR2 + CI3 DI2 = CI2 + CR3 DI3 = CI2 - CR3 CH ( I - 1 , K , 2 ) = WA1 ( I - 2 ) * DR2 - WA1 ( I - 1 ) * DI2 CH ( I , K , 2 ) = WA1 ( I - 2 ) * DI2 + WA1 ( I - 1 ) * DR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 2 ) * DR3 - WA2 ( I - 1 ) * DI3 CH ( I , K , 3 ) = WA2 ( I - 2 ) * DI3 + WA2 ( I - 1 ) * DR3 102 CONTINUE 103 CONTINUE RETURN END SUBROUTINE RADB4 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 4 , L1 ) , CH ( IDO , L1 , 4 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) DATA SQRT2 / 1.41421356237309504880D0 / DO 101 K = 1 , L1 TR1 = CC ( 1 , 1 , K ) - CC ( IDO , 4 , K ) TR2 = CC ( 1 , 1 , K ) + CC ( IDO , 4 , K ) TR3 = CC ( IDO , 2 , K ) + CC ( IDO , 2 , K ) TR4 = CC ( 1 , 3 , K ) + CC ( 1 , 3 , K ) CH ( 1 , K , 1 ) = TR2 + TR3 CH ( 1 , K , 2 ) = TR1 - TR4 CH ( 1 , K , 3 ) = TR2 - TR3 CH ( 1 , K , 4 ) = TR1 + TR4 101 CONTINUE IF ( IDO - 2 ) 107 , 105 , 102 102 IDP2 = IDO + 2 DO 104 K = 1 , L1 DO 103 I = 3 , IDO , 2 IC = IDP2 - I TI1 = CC ( I , 1 , K ) + CC ( IC , 4 , K ) TI2 = CC ( I , 1 , K ) - CC ( IC , 4 , K ) TI3 = CC ( I , 3 , K ) - CC ( IC , 2 , K ) TR4 = CC ( I , 3 , K ) + CC ( IC , 2 , K ) TR1 = CC ( I - 1 , 1 , K ) - CC ( IC - 1 , 4 , K ) TR2 = CC ( I - 1 , 1 , K ) + CC ( IC - 1 , 4 , K ) TI4 = CC ( I - 1 , 3 , K ) - CC ( IC - 1 , 2 , K ) TR3 = CC ( I - 1 , 3 , K ) + CC ( IC - 1 , 2 , K ) CH ( I - 1 , K , 1 ) = TR2 + TR3 CR3 = TR2 - TR3 CH ( I , K , 1 ) = TI2 + TI3 CI3 = TI2 - TI3 CR2 = TR1 - TR4 CR4 = TR1 + TR4 CI2 = TI1 + TI4 CI4 = TI1 - TI4 CH ( I - 1 , K , 2 ) = WA1 ( I - 2 ) * CR2 - WA1 ( I - 1 ) * CI2 CH ( I , K , 2 ) = WA1 ( I - 2 ) * CI2 + WA1 ( I - 1 ) * CR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 2 ) * CR3 - WA2 ( I - 1 ) * CI3 CH ( I , K , 3 ) = WA2 ( I - 2 ) * CI3 + WA2 ( I - 1 ) * CR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 2 ) * CR4 - WA3 ( I - 1 ) * CI4 CH ( I , K , 4 ) = WA3 ( I - 2 ) * CI4 + WA3 ( I - 1 ) * CR4 103 CONTINUE 104 CONTINUE IF ( MOD ( IDO , 2 ) . EQ . 1 ) RETURN 105 CONTINUE DO 106 K = 1 , L1 TI1 = CC ( 1 , 2 , K ) + CC ( 1 , 4 , K ) TI2 = CC ( 1 , 4 , K ) - CC ( 1 , 2 , K ) TR1 = CC ( IDO , 1 , K ) - CC ( IDO , 3 , K ) TR2 = CC ( IDO , 1 , K ) + CC ( IDO , 3 , K ) CH ( IDO , K , 1 ) = TR2 + TR2 CH ( IDO , K , 2 ) = SQRT2 * ( TR1 - TI1 ) CH ( IDO , K , 3 ) = TI2 + TI2 CH ( IDO , K , 4 ) = - SQRT2 * ( TR1 + TI1 ) 106 CONTINUE 107 RETURN END SUBROUTINE RADB5 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 , WA4 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , 5 , L1 ) , CH ( IDO , L1 , 5 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) , WA4 ( 1 ) C     *** TR11=COS(2*PI/5), TI11=SIN(2*PI/5) C     *** TR12=COS(4*PI/5), TI12=SIN(4*PI/5) DATA TR11 , TI11 , TR12 , TI12 / 0.3090169943749474241D0 , + 0.95105651629515357212D0 , + - 0.8090169943749474241D0 , 0.58778525229247312917D0 / DO 101 K = 1 , L1 TI5 = CC ( 1 , 3 , K ) + CC ( 1 , 3 , K ) TI4 = CC ( 1 , 5 , K ) + CC ( 1 , 5 , K ) TR2 = CC ( IDO , 2 , K ) + CC ( IDO , 2 , K ) TR3 = CC ( IDO , 4 , K ) + CC ( IDO , 4 , K ) CH ( 1 , K , 1 ) = CC ( 1 , 1 , K ) + TR2 + TR3 CR2 = CC ( 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CR3 = CC ( 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI5 = TI11 * TI5 + TI12 * TI4 CI4 = TI12 * TI5 - TI11 * TI4 CH ( 1 , K , 2 ) = CR2 - CI5 CH ( 1 , K , 3 ) = CR3 - CI4 CH ( 1 , K , 4 ) = CR3 + CI4 CH ( 1 , K , 5 ) = CR2 + CI5 101 CONTINUE IF ( IDO . EQ . 1 ) RETURN IDP2 = IDO + 2 DO 103 K = 1 , L1 DO 102 I = 3 , IDO , 2 IC = IDP2 - I TI5 = CC ( I , 3 , K ) + CC ( IC , 2 , K ) TI2 = CC ( I , 3 , K ) - CC ( IC , 2 , K ) TI4 = CC ( I , 5 , K ) + CC ( IC , 4 , K ) TI3 = CC ( I , 5 , K ) - CC ( IC , 4 , K ) TR5 = CC ( I - 1 , 3 , K ) - CC ( IC - 1 , 2 , K ) TR2 = CC ( I - 1 , 3 , K ) + CC ( IC - 1 , 2 , K ) TR4 = CC ( I - 1 , 5 , K ) - CC ( IC - 1 , 4 , K ) TR3 = CC ( I - 1 , 5 , K ) + CC ( IC - 1 , 4 , K ) CH ( I - 1 , K , 1 ) = CC ( I - 1 , 1 , K ) + TR2 + TR3 CH ( I , K , 1 ) = CC ( I , 1 , K ) + TI2 + TI3 CR2 = CC ( I - 1 , 1 , K ) + TR11 * TR2 + TR12 * TR3 CI2 = CC ( I , 1 , K ) + TR11 * TI2 + TR12 * TI3 CR3 = CC ( I - 1 , 1 , K ) + TR12 * TR2 + TR11 * TR3 CI3 = CC ( I , 1 , K ) + TR12 * TI2 + TR11 * TI3 CR5 = TI11 * TR5 + TI12 * TR4 CI5 = TI11 * TI5 + TI12 * TI4 CR4 = TI12 * TR5 - TI11 * TR4 CI4 = TI12 * TI5 - TI11 * TI4 DR3 = CR3 - CI4 DR4 = CR3 + CI4 DI3 = CI3 + CR4 DI4 = CI3 - CR4 DR5 = CR2 + CI5 DR2 = CR2 - CI5 DI5 = CI2 - CR5 DI2 = CI2 + CR5 CH ( I - 1 , K , 2 ) = WA1 ( I - 2 ) * DR2 - WA1 ( I - 1 ) * DI2 CH ( I , K , 2 ) = WA1 ( I - 2 ) * DI2 + WA1 ( I - 1 ) * DR2 CH ( I - 1 , K , 3 ) = WA2 ( I - 2 ) * DR3 - WA2 ( I - 1 ) * DI3 CH ( I , K , 3 ) = WA2 ( I - 2 ) * DI3 + WA2 ( I - 1 ) * DR3 CH ( I - 1 , K , 4 ) = WA3 ( I - 2 ) * DR4 - WA3 ( I - 1 ) * DI4 CH ( I , K , 4 ) = WA3 ( I - 2 ) * DI4 + WA3 ( I - 1 ) * DR4 CH ( I - 1 , K , 5 ) = WA4 ( I - 2 ) * DR5 - WA4 ( I - 1 ) * DI5 CH ( I , K , 5 ) = WA4 ( I - 2 ) * DI5 + WA4 ( I - 1 ) * DR5 102 CONTINUE 103 CONTINUE RETURN END SUBROUTINE RADBG ( IDO , IP , L1 , IDL1 , CC , C1 , C2 , CH , CH2 , WA ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , L1 , IP ) , CC ( IDO , IP , L1 ) , 1 C1 ( IDO , L1 , IP ) , C2 ( IDL1 , IP ), 2 CH2 ( IDL1 , IP ) , WA ( 1 ) DATA TPI / 6.28318530717958647692D0 / ARG = TPI / FLOAT ( IP ) DCP = COS ( ARG ) DSP = SIN ( ARG ) IDP2 = IDO + 2 NBD = ( IDO - 1 ) / 2 IPP2 = IP + 2 IPPH = ( IP + 1 ) / 2 IF ( IDO . LT . L1 ) GO TO 103 DO 102 K = 1 , L1 DO 101 I = 1 , IDO CH ( I , K , 1 ) = CC ( I , 1 , K ) 101 CONTINUE 102 CONTINUE GO TO 106 103 DO 105 I = 1 , IDO DO 104 K = 1 , L1 CH ( I , K , 1 ) = CC ( I , 1 , K ) 104 CONTINUE 105 CONTINUE 106 DO 108 J = 2 , IPPH JC = IPP2 - J J2 = J + J DO 107 K = 1 , L1 CH ( 1 , K , J ) = CC ( IDO , J2 - 2 , K ) + CC ( IDO , J2 - 2 , K ) CH ( 1 , K , JC ) = CC ( 1 , J2 - 1 , K ) + CC ( 1 , J2 - 1 , K ) 107 CONTINUE 108 CONTINUE IF ( IDO . EQ . 1 ) GO TO 116 IF ( NBD . LT . L1 ) GO TO 112 DO 111 J = 2 , IPPH JC = IPP2 - J DO 110 K = 1 , L1 DO 109 I = 3 , IDO , 2 IC = IDP2 - I CH ( I - 1 , K , J ) = CC ( I - 1 , 2 * J - 1 , K ) + CC ( IC - 1 , 2 * J - 2 , K ) CH ( I - 1 , K , JC ) = CC ( I - 1 , 2 * J - 1 , K ) - CC ( IC - 1 , 2 * J - 2 , K ) CH ( I , K , J ) = CC ( I , 2 * J - 1 , K ) - CC ( IC , 2 * J - 2 , K ) CH ( I , K , JC ) = CC ( I , 2 * J - 1 , K ) + CC ( IC , 2 * J - 2 , K ) 109 CONTINUE 110 CONTINUE 111 CONTINUE GO TO 116 112 DO 115 J = 2 , IPPH JC = IPP2 - J DO 114 I = 3 , IDO , 2 IC = IDP2 - I DO 113 K = 1 , L1 CH ( I - 1 , K , J ) = CC ( I - 1 , 2 * J - 1 , K ) + CC ( IC - 1 , 2 * J - 2 , K ) CH ( I - 1 , K , JC ) = CC ( I - 1 , 2 * J - 1 , K ) - CC ( IC - 1 , 2 * J - 2 , K ) CH ( I , K , J ) = CC ( I , 2 * J - 1 , K ) - CC ( IC , 2 * J - 2 , K ) CH ( I , K , JC ) = CC ( I , 2 * J - 1 , K ) + CC ( IC , 2 * J - 2 , K ) 113 CONTINUE 114 CONTINUE 115 CONTINUE 116 AR1 = 1.0D0 AI1 = 0.0D0 DO 120 L = 2 , IPPH LC = IPP2 - L AR1H = DCP * AR1 - DSP * AI1 AI1 = DCP * AI1 + DSP * AR1 AR1 = AR1H DO 117 IK = 1 , IDL1 C2 ( IK , L ) = CH2 ( IK , 1 ) + AR1 * CH2 ( IK , 2 ) C2 ( IK , LC ) = AI1 * CH2 ( IK , IP ) 117 CONTINUE DC2 = AR1 DS2 = AI1 AR2 = AR1 AI2 = AI1 DO 119 J = 3 , IPPH JC = IPP2 - J AR2H = DC2 * AR2 - DS2 * AI2 AI2 = DC2 * AI2 + DS2 * AR2 AR2 = AR2H DO 118 IK = 1 , IDL1 C2 ( IK , L ) = C2 ( IK , L ) + AR2 * CH2 ( IK , J ) C2 ( IK , LC ) = C2 ( IK , LC ) + AI2 * CH2 ( IK , JC ) 118 CONTINUE 119 CONTINUE 120 CONTINUE DO 122 J = 2 , IPPH DO 121 IK = 1 , IDL1 CH2 ( IK , 1 ) = CH2 ( IK , 1 ) + CH2 ( IK , J ) 121 CONTINUE 122 CONTINUE DO 124 J = 2 , IPPH JC = IPP2 - J DO 123 K = 1 , L1 CH ( 1 , K , J ) = C1 ( 1 , K , J ) - C1 ( 1 , K , JC ) CH ( 1 , K , JC ) = C1 ( 1 , K , J ) + C1 ( 1 , K , JC ) 123 CONTINUE 124 CONTINUE IF ( IDO . EQ . 1 ) GO TO 132 IF ( NBD . LT . L1 ) GO TO 128 DO 127 J = 2 , IPPH JC = IPP2 - J DO 126 K = 1 , L1 DO 125 I = 3 , IDO , 2 CH ( I - 1 , K , J ) = C1 ( I - 1 , K , J ) - C1 ( I , K , JC ) CH ( I - 1 , K , JC ) = C1 ( I - 1 , K , J ) + C1 ( I , K , JC ) CH ( I , K , J ) = C1 ( I , K , J ) + C1 ( I - 1 , K , JC ) CH ( I , K , JC ) = C1 ( I , K , J ) - C1 ( I - 1 , K , JC ) 125 CONTINUE 126 CONTINUE 127 CONTINUE GO TO 132 128 DO 131 J = 2 , IPPH JC = IPP2 - J DO 130 I = 3 , IDO , 2 DO 129 K = 1 , L1 CH ( I - 1 , K , J ) = C1 ( I - 1 , K , J ) - C1 ( I , K , JC ) CH ( I - 1 , K , JC ) = C1 ( I - 1 , K , J ) + C1 ( I , K , JC ) CH ( I , K , J ) = C1 ( I , K , J ) + C1 ( I - 1 , K , JC ) CH ( I , K , JC ) = C1 ( I , K , J ) - C1 ( I - 1 , K , JC ) 129 CONTINUE 130 CONTINUE 131 CONTINUE 132 CONTINUE IF ( IDO . EQ . 1 ) RETURN DO 133 IK = 1 , IDL1 C2 ( IK , 1 ) = CH2 ( IK , 1 ) 133 CONTINUE DO 135 J = 2 , IP DO 134 K = 1 , L1 C1 ( 1 , K , J ) = CH ( 1 , K , J ) 134 CONTINUE 135 CONTINUE IF ( NBD . GT . L1 ) GO TO 139 IS = - IDO DO 138 J = 2 , IP IS = IS + IDO IDIJ = IS DO 137 I = 3 , IDO , 2 IDIJ = IDIJ + 2 DO 136 K = 1 , L1 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) - WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) + WA ( IDIJ ) * CH ( I - 1 , K , J ) 136 CONTINUE 137 CONTINUE 138 CONTINUE GO TO 143 139 IS = - IDO DO 142 J = 2 , IP IS = IS + IDO DO 141 K = 1 , L1 IDIJ = IS DO 140 I = 3 , IDO , 2 IDIJ = IDIJ + 2 C1 ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * CH ( I - 1 , K , J ) - WA ( IDIJ ) * CH ( I , K , J ) C1 ( I , K , J ) = WA ( IDIJ - 1 ) * CH ( I , K , J ) + WA ( IDIJ ) * CH ( I - 1 , K , J ) 140 CONTINUE 141 CONTINUE 142 CONTINUE 143 RETURN END SUBROUTINE RADF2 ( IDO , L1 , CC , CH , WA1 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , 2 , L1 ) , CC ( IDO , L1 , 2 ) , 1 WA1 ( 1 ) DO 101 K = 1 , L1 CH ( 1 , 1 , K ) = CC ( 1 , K , 1 ) + CC ( 1 , K , 2 ) CH ( IDO , 2 , K ) = CC ( 1 , K , 1 ) - CC ( 1 , K , 2 ) 101 CONTINUE IF ( IDO - 2 ) 107 , 105 , 102 102 IDP2 = IDO + 2 DO 104 K = 1 , L1 DO 103 I = 3 , IDO , 2 IC = IDP2 - I TR2 = WA1 ( I - 2 ) * CC ( I - 1 , K , 2 ) + WA1 ( I - 1 ) * CC ( I , K , 2 ) TI2 = WA1 ( I - 2 ) * CC ( I , K , 2 ) - WA1 ( I - 1 ) * CC ( I - 1 , K , 2 ) CH ( I , 1 , K ) = CC ( I , K , 1 ) + TI2 CH ( IC , 2 , K ) = TI2 - CC ( I , K , 1 ) CH ( I - 1 , 1 , K ) = CC ( I - 1 , K , 1 ) + TR2 CH ( IC - 1 , 2 , K ) = CC ( I - 1 , K , 1 ) - TR2 103 CONTINUE 104 CONTINUE IF ( MOD ( IDO , 2 ) . EQ . 1 ) RETURN 105 DO 106 K = 1 , L1 CH ( 1 , 2 , K ) = - CC ( IDO , K , 2 ) CH ( IDO , 1 , K ) = CC ( IDO , K , 1 ) 106 CONTINUE 107 RETURN END SUBROUTINE RADF3 ( IDO , L1 , CC , CH , WA1 , WA2 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , 3 , L1 ) , CC ( IDO , L1 , 3 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) C     *** TAUI IS -SQRT(3)/2 *** DATA TAUR , TAUI /- 0.5D0 , 0.86602540378443864676D0 / DO 101 K = 1 , L1 CR2 = CC ( 1 , K , 2 ) + CC ( 1 , K , 3 ) CH ( 1 , 1 , K ) = CC ( 1 , K , 1 ) + CR2 CH ( 1 , 3 , K ) = TAUI * ( CC ( 1 , K , 3 ) - CC ( 1 , K , 2 )) CH ( IDO , 2 , K ) = CC ( 1 , K , 1 ) + TAUR * CR2 101 CONTINUE IF ( IDO . EQ . 1 ) RETURN IDP2 = IDO + 2 DO 103 K = 1 , L1 DO 102 I = 3 , IDO , 2 IC = IDP2 - I DR2 = WA1 ( I - 2 ) * CC ( I - 1 , K , 2 ) + WA1 ( I - 1 ) * CC ( I , K , 2 ) DI2 = WA1 ( I - 2 ) * CC ( I , K , 2 ) - WA1 ( I - 1 ) * CC ( I - 1 , K , 2 ) DR3 = WA2 ( I - 2 ) * CC ( I - 1 , K , 3 ) + WA2 ( I - 1 ) * CC ( I , K , 3 ) DI3 = WA2 ( I - 2 ) * CC ( I , K , 3 ) - WA2 ( I - 1 ) * CC ( I - 1 , K , 3 ) CR2 = DR2 + DR3 CI2 = DI2 + DI3 CH ( I - 1 , 1 , K ) = CC ( I - 1 , K , 1 ) + CR2 CH ( I , 1 , K ) = CC ( I , K , 1 ) + CI2 TR2 = CC ( I - 1 , K , 1 ) + TAUR * CR2 TI2 = CC ( I , K , 1 ) + TAUR * CI2 TR3 = TAUI * ( DI2 - DI3 ) TI3 = TAUI * ( DR3 - DR2 ) CH ( I - 1 , 3 , K ) = TR2 + TR3 CH ( IC - 1 , 2 , K ) = TR2 - TR3 CH ( I , 3 , K ) = TI2 + TI3 CH ( IC , 2 , K ) = TI3 - TI2 102 CONTINUE 103 CONTINUE RETURN END SUBROUTINE RADF4 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , L1 , 4 ) , CH ( IDO , 4 , L1 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) DATA HSQT2 / 0.70710678118654752440D0 / DO 101 K = 1 , L1 TR1 = CC ( 1 , K , 2 ) + CC ( 1 , K , 4 ) TR2 = CC ( 1 , K , 1 ) + CC ( 1 , K , 3 ) CH ( 1 , 1 , K ) = TR1 + TR2 CH ( IDO , 4 , K ) = TR2 - TR1 CH ( IDO , 2 , K ) = CC ( 1 , K , 1 ) - CC ( 1 , K , 3 ) CH ( 1 , 3 , K ) = CC ( 1 , K , 4 ) - CC ( 1 , K , 2 ) 101 CONTINUE IF ( IDO - 2 ) 107 , 105 , 102 102 IDP2 = IDO + 2 DO 104 K = 1 , L1 DO 103 I = 3 , IDO , 2 IC = IDP2 - I CR2 = WA1 ( I - 2 ) * CC ( I - 1 , K , 2 ) + WA1 ( I - 1 ) * CC ( I , K , 2 ) CI2 = WA1 ( I - 2 ) * CC ( I , K , 2 ) - WA1 ( I - 1 ) * CC ( I - 1 , K , 2 ) CR3 = WA2 ( I - 2 ) * CC ( I - 1 , K , 3 ) + WA2 ( I - 1 ) * CC ( I , K , 3 ) CI3 = WA2 ( I - 2 ) * CC ( I , K , 3 ) - WA2 ( I - 1 ) * CC ( I - 1 , K , 3 ) CR4 = WA3 ( I - 2 ) * CC ( I - 1 , K , 4 ) + WA3 ( I - 1 ) * CC ( I , K , 4 ) CI4 = WA3 ( I - 2 ) * CC ( I , K , 4 ) - WA3 ( I - 1 ) * CC ( I - 1 , K , 4 ) TR1 = CR2 + CR4 TR4 = CR4 - CR2 TI1 = CI2 + CI4 TI4 = CI2 - CI4 TI2 = CC ( I , K , 1 ) + CI3 TI3 = CC ( I , K , 1 ) - CI3 TR2 = CC ( I - 1 , K , 1 ) + CR3 TR3 = CC ( I - 1 , K , 1 ) - CR3 CH ( I - 1 , 1 , K ) = TR1 + TR2 CH ( IC - 1 , 4 , K ) = TR2 - TR1 CH ( I , 1 , K ) = TI1 + TI2 CH ( IC , 4 , K ) = TI1 - TI2 CH ( I - 1 , 3 , K ) = TI4 + TR3 CH ( IC - 1 , 2 , K ) = TR3 - TI4 CH ( I , 3 , K ) = TR4 + TI3 CH ( IC , 2 , K ) = TR4 - TI3 103 CONTINUE 104 CONTINUE IF ( MOD ( IDO , 2 ) . EQ . 1 ) RETURN 105 CONTINUE DO 106 K = 1 , L1 TI1 = - HSQT2 * ( CC ( IDO , K , 2 ) + CC ( IDO , K , 4 )) TR1 = HSQT2 * ( CC ( IDO , K , 2 ) - CC ( IDO , K , 4 )) CH ( IDO , 1 , K ) = TR1 + CC ( IDO , K , 1 ) CH ( IDO , 3 , K ) = CC ( IDO , K , 1 ) - TR1 CH ( 1 , 2 , K ) = TI1 - CC ( IDO , K , 3 ) CH ( 1 , 4 , K ) = TI1 + CC ( IDO , K , 3 ) 106 CONTINUE 107 RETURN END SUBROUTINE RADF5 ( IDO , L1 , CC , CH , WA1 , WA2 , WA3 , WA4 ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CC ( IDO , L1 , 5 ) , CH ( IDO , 5 , L1 ) , 1 WA1 ( 1 ) , WA2 ( 1 ) , WA3 ( 1 ) , WA4 ( 1 ) DATA TR11 , TI11 , TR12 , TI12 / 0.3090169943749474241D0 , + 0.95105651629515357212D0 , 1 - 0.8090169943749474241D0 , 0.58778525229247312917D0 / DO 101 K = 1 , L1 CR2 = CC ( 1 , K , 5 ) + CC ( 1 , K , 2 ) CI5 = CC ( 1 , K , 5 ) - CC ( 1 , K , 2 ) CR3 = CC ( 1 , K , 4 ) + CC ( 1 , K , 3 ) CI4 = CC ( 1 , K , 4 ) - CC ( 1 , K , 3 ) CH ( 1 , 1 , K ) = CC ( 1 , K , 1 ) + CR2 + CR3 CH ( IDO , 2 , K ) = CC ( 1 , K , 1 ) + TR11 * CR2 + TR12 * CR3 CH ( 1 , 3 , K ) = TI11 * CI5 + TI12 * CI4 CH ( IDO , 4 , K ) = CC ( 1 , K , 1 ) + TR12 * CR2 + TR11 * CR3 CH ( 1 , 5 , K ) = TI12 * CI5 - TI11 * CI4 101 CONTINUE IF ( IDO . EQ . 1 ) RETURN IDP2 = IDO + 2 DO 103 K = 1 , L1 DO 102 I = 3 , IDO , 2 IC = IDP2 - I DR2 = WA1 ( I - 2 ) * CC ( I - 1 , K , 2 ) + WA1 ( I - 1 ) * CC ( I , K , 2 ) DI2 = WA1 ( I - 2 ) * CC ( I , K , 2 ) - WA1 ( I - 1 ) * CC ( I - 1 , K , 2 ) DR3 = WA2 ( I - 2 ) * CC ( I - 1 , K , 3 ) + WA2 ( I - 1 ) * CC ( I , K , 3 ) DI3 = WA2 ( I - 2 ) * CC ( I , K , 3 ) - WA2 ( I - 1 ) * CC ( I - 1 , K , 3 ) DR4 = WA3 ( I - 2 ) * CC ( I - 1 , K , 4 ) + WA3 ( I - 1 ) * CC ( I , K , 4 ) DI4 = WA3 ( I - 2 ) * CC ( I , K , 4 ) - WA3 ( I - 1 ) * CC ( I - 1 , K , 4 ) DR5 = WA4 ( I - 2 ) * CC ( I - 1 , K , 5 ) + WA4 ( I - 1 ) * CC ( I , K , 5 ) DI5 = WA4 ( I - 2 ) * CC ( I , K , 5 ) - WA4 ( I - 1 ) * CC ( I - 1 , K , 5 ) CR2 = DR2 + DR5 CI5 = DR5 - DR2 CR5 = DI2 - DI5 CI2 = DI2 + DI5 CR3 = DR3 + DR4 CI4 = DR4 - DR3 CR4 = DI3 - DI4 CI3 = DI3 + DI4 CH ( I - 1 , 1 , K ) = CC ( I - 1 , K , 1 ) + CR2 + CR3 CH ( I , 1 , K ) = CC ( I , K , 1 ) + CI2 + CI3 TR2 = CC ( I - 1 , K , 1 ) + TR11 * CR2 + TR12 * CR3 TI2 = CC ( I , K , 1 ) + TR11 * CI2 + TR12 * CI3 TR3 = CC ( I - 1 , K , 1 ) + TR12 * CR2 + TR11 * CR3 TI3 = CC ( I , K , 1 ) + TR12 * CI2 + TR11 * CI3 TR5 = TI11 * CR5 + TI12 * CR4 TI5 = TI11 * CI5 + TI12 * CI4 TR4 = TI12 * CR5 - TI11 * CR4 TI4 = TI12 * CI5 - TI11 * CI4 CH ( I - 1 , 3 , K ) = TR2 + TR5 CH ( IC - 1 , 2 , K ) = TR2 - TR5 CH ( I , 3 , K ) = TI2 + TI5 CH ( IC , 2 , K ) = TI5 - TI2 CH ( I - 1 , 5 , K ) = TR3 + TR4 CH ( IC - 1 , 4 , K ) = TR3 - TR4 CH ( I , 5 , K ) = TI3 + TI4 CH ( IC , 4 , K ) = TI4 - TI3 102 CONTINUE 103 CONTINUE RETURN END SUBROUTINE RADFG ( IDO , IP , L1 , IDL1 , CC , C1 , C2 , CH , CH2 , WA ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( IDO , L1 , IP ) , CC ( IDO , IP , L1 ) , 1 C1 ( IDO , L1 , IP ) , C2 ( IDL1 , IP ), 2 CH2 ( IDL1 , IP ) , WA ( 1 ) DATA TPI / 6.28318530717958647692D0 / ARG = TPI / FLOAT ( IP ) DCP = COS ( ARG ) DSP = SIN ( ARG ) IPPH = ( IP + 1 ) / 2 IPP2 = IP + 2 IDP2 = IDO + 2 NBD = ( IDO - 1 ) / 2 IF ( IDO . EQ . 1 ) GO TO 119 DO 101 IK = 1 , IDL1 CH2 ( IK , 1 ) = C2 ( IK , 1 ) 101 CONTINUE DO 103 J = 2 , IP DO 102 K = 1 , L1 CH ( 1 , K , J ) = C1 ( 1 , K , J ) 102 CONTINUE 103 CONTINUE IF ( NBD . GT . L1 ) GO TO 107 IS = - IDO DO 106 J = 2 , IP IS = IS + IDO IDIJ = IS DO 105 I = 3 , IDO , 2 IDIJ = IDIJ + 2 DO 104 K = 1 , L1 CH ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * C1 ( I - 1 , K , J ) + WA ( IDIJ ) * C1 ( I , K , J ) CH ( I , K , J ) = WA ( IDIJ - 1 ) * C1 ( I , K , J ) - WA ( IDIJ ) * C1 ( I - 1 , K , J ) 104 CONTINUE 105 CONTINUE 106 CONTINUE GO TO 111 107 IS = - IDO DO 110 J = 2 , IP IS = IS + IDO DO 109 K = 1 , L1 IDIJ = IS DO 108 I = 3 , IDO , 2 IDIJ = IDIJ + 2 CH ( I - 1 , K , J ) = WA ( IDIJ - 1 ) * C1 ( I - 1 , K , J ) + WA ( IDIJ ) * C1 ( I , K , J ) CH ( I , K , J ) = WA ( IDIJ - 1 ) * C1 ( I , K , J ) - WA ( IDIJ ) * C1 ( I - 1 , K , J ) 108 CONTINUE 109 CONTINUE 110 CONTINUE 111 IF ( NBD . LT . L1 ) GO TO 115 DO 114 J = 2 , IPPH JC = IPP2 - J DO 113 K = 1 , L1 DO 112 I = 3 , IDO , 2 C1 ( I - 1 , K , J ) = CH ( I - 1 , K , J ) + CH ( I - 1 , K , JC ) C1 ( I - 1 , K , JC ) = CH ( I , K , J ) - CH ( I , K , JC ) C1 ( I , K , J ) = CH ( I , K , J ) + CH ( I , K , JC ) C1 ( I , K , JC ) = CH ( I - 1 , K , JC ) - CH ( I - 1 , K , J ) 112 CONTINUE 113 CONTINUE 114 CONTINUE GO TO 121 115 DO 118 J = 2 , IPPH JC = IPP2 - J DO 117 I = 3 , IDO , 2 DO 116 K = 1 , L1 C1 ( I - 1 , K , J ) = CH ( I - 1 , K , J ) + CH ( I - 1 , K , JC ) C1 ( I - 1 , K , JC ) = CH ( I , K , J ) - CH ( I , K , JC ) C1 ( I , K , J ) = CH ( I , K , J ) + CH ( I , K , JC ) C1 ( I , K , JC ) = CH ( I - 1 , K , JC ) - CH ( I - 1 , K , J ) 116 CONTINUE 117 CONTINUE 118 CONTINUE GO TO 121 119 DO 120 IK = 1 , IDL1 C2 ( IK , 1 ) = CH2 ( IK , 1 ) 120 CONTINUE 121 DO 123 J = 2 , IPPH JC = IPP2 - J DO 122 K = 1 , L1 C1 ( 1 , K , J ) = CH ( 1 , K , J ) + CH ( 1 , K , JC ) C1 ( 1 , K , JC ) = CH ( 1 , K , JC ) - CH ( 1 , K , J ) 122 CONTINUE 123 CONTINUE C AR1 = 1.0D0 AI1 = 0.0D0 DO 127 L = 2 , IPPH LC = IPP2 - L AR1H = DCP * AR1 - DSP * AI1 AI1 = DCP * AI1 + DSP * AR1 AR1 = AR1H DO 124 IK = 1 , IDL1 CH2 ( IK , L ) = C2 ( IK , 1 ) + AR1 * C2 ( IK , 2 ) CH2 ( IK , LC ) = AI1 * C2 ( IK , IP ) 124 CONTINUE DC2 = AR1 DS2 = AI1 AR2 = AR1 AI2 = AI1 DO 126 J = 3 , IPPH JC = IPP2 - J AR2H = DC2 * AR2 - DS2 * AI2 AI2 = DC2 * AI2 + DS2 * AR2 AR2 = AR2H DO 125 IK = 1 , IDL1 CH2 ( IK , L ) = CH2 ( IK , L ) + AR2 * C2 ( IK , J ) CH2 ( IK , LC ) = CH2 ( IK , LC ) + AI2 * C2 ( IK , JC ) 125 CONTINUE 126 CONTINUE 127 CONTINUE DO 129 J = 2 , IPPH DO 128 IK = 1 , IDL1 CH2 ( IK , 1 ) = CH2 ( IK , 1 ) + C2 ( IK , J ) 128 CONTINUE 129 CONTINUE C IF ( IDO . LT . L1 ) GO TO 132 DO 131 K = 1 , L1 DO 130 I = 1 , IDO CC ( I , 1 , K ) = CH ( I , K , 1 ) 130 CONTINUE 131 CONTINUE GO TO 135 132 DO 134 I = 1 , IDO DO 133 K = 1 , L1 CC ( I , 1 , K ) = CH ( I , K , 1 ) 133 CONTINUE 134 CONTINUE 135 DO 137 J = 2 , IPPH JC = IPP2 - J J2 = J + J DO 136 K = 1 , L1 CC ( IDO , J2 - 2 , K ) = CH ( 1 , K , J ) CC ( 1 , J2 - 1 , K ) = CH ( 1 , K , JC ) 136 CONTINUE 137 CONTINUE IF ( IDO . EQ . 1 ) RETURN IF ( NBD . LT . L1 ) GO TO 141 DO 140 J = 2 , IPPH JC = IPP2 - J J2 = J + J DO 139 K = 1 , L1 DO 138 I = 3 , IDO , 2 IC = IDP2 - I CC ( I - 1 , J2 - 1 , K ) = CH ( I - 1 , K , J ) + CH ( I - 1 , K , JC ) CC ( IC - 1 , J2 - 2 , K ) = CH ( I - 1 , K , J ) - CH ( I - 1 , K , JC ) CC ( I , J2 - 1 , K ) = CH ( I , K , J ) + CH ( I , K , JC ) CC ( IC , J2 - 2 , K ) = CH ( I , K , JC ) - CH ( I , K , J ) 138 CONTINUE 139 CONTINUE 140 CONTINUE RETURN 141 DO 144 J = 2 , IPPH JC = IPP2 - J J2 = J + J DO 143 I = 3 , IDO , 2 IC = IDP2 - I DO 142 K = 1 , L1 CC ( I - 1 , J2 - 1 , K ) = CH ( I - 1 , K , J ) + CH ( I - 1 , K , JC ) CC ( IC - 1 , J2 - 2 , K ) = CH ( I - 1 , K , J ) - CH ( I - 1 , K , JC ) CC ( I , J2 - 1 , K ) = CH ( I , K , J ) + CH ( I , K , JC ) CC ( IC , J2 - 2 , K ) = CH ( I , K , JC ) - CH ( I , K , J ) 142 CONTINUE 143 CONTINUE 144 CONTINUE RETURN END SUBROUTINE RFFTB1 ( N , C , CH , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( * ) , C ( * ) , WA ( * ) , IFAC ( * ) NF = IFAC ( 2 ) NA = 0 L1 = 1 IW = 1 DO 116 K1 = 1 , NF IP = IFAC ( K1 + 2 ) L2 = IP * L1 IDO = N / L2 IDL1 = IDO * L1 IF ( IP . NE . 4 ) GO TO 103 IX2 = IW + IDO IX3 = IX2 + IDO IF ( NA . NE . 0 ) GO TO 101 CALL RADB4 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 )) GO TO 102 101 CALL RADB4 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 )) 102 NA = 1 - NA GO TO 115 103 IF ( IP . NE . 2 ) GO TO 106 IF ( NA . NE . 0 ) GO TO 104 CALL RADB2 ( IDO , L1 , C , CH , WA ( IW )) GO TO 105 104 CALL RADB2 ( IDO , L1 , CH , C , WA ( IW )) 105 NA = 1 - NA GO TO 115 106 IF ( IP . NE . 3 ) GO TO 109 IX2 = IW + IDO IF ( NA . NE . 0 ) GO TO 107 CALL RADB3 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 )) GO TO 108 107 CALL RADB3 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 )) 108 NA = 1 - NA GO TO 115 109 IF ( IP . NE . 5 ) GO TO 112 IX2 = IW + IDO IX3 = IX2 + IDO IX4 = IX3 + IDO IF ( NA . NE . 0 ) GO TO 110 CALL RADB5 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) GO TO 111 110 CALL RADB5 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) 111 NA = 1 - NA GO TO 115 112 IF ( NA . NE . 0 ) GO TO 113 CALL RADBG ( IDO , IP , L1 , IDL1 , C , C , C , CH , CH , WA ( IW )) GO TO 114 113 CALL RADBG ( IDO , IP , L1 , IDL1 , CH , CH , CH , C , C , WA ( IW )) 114 IF ( IDO . EQ . 1 ) NA = 1 - NA 115 L1 = L2 IW = IW + ( IP - 1 ) * IDO 116 CONTINUE IF ( NA . EQ . 0 ) RETURN DO 117 I = 1 , N C ( I ) = CH ( I ) 117 CONTINUE RETURN END SUBROUTINE RFFTF1 ( N , C , CH , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION CH ( * ) , C ( * ) , WA ( * ) , IFAC ( * ) NF = IFAC ( 2 ) NA = 1 L2 = N IW = N DO 111 K1 = 1 , NF KH = NF - K1 IP = IFAC ( KH + 3 ) L1 = L2 / IP IDO = N / L2 IDL1 = IDO * L1 IW = IW - ( IP - 1 ) * IDO NA = 1 - NA IF ( IP . NE . 4 ) GO TO 102 IX2 = IW + IDO IX3 = IX2 + IDO IF ( NA . NE . 0 ) GO TO 101 CALL RADF4 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 )) GO TO 110 101 CALL RADF4 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 )) GO TO 110 102 IF ( IP . NE . 2 ) GO TO 104 IF ( NA . NE . 0 ) GO TO 103 CALL RADF2 ( IDO , L1 , C , CH , WA ( IW )) GO TO 110 103 CALL RADF2 ( IDO , L1 , CH , C , WA ( IW )) GO TO 110 104 IF ( IP . NE . 3 ) GO TO 106 IX2 = IW + IDO IF ( NA . NE . 0 ) GO TO 105 CALL RADF3 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 )) GO TO 110 105 CALL RADF3 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 )) GO TO 110 106 IF ( IP . NE . 5 ) GO TO 108 IX2 = IW + IDO IX3 = IX2 + IDO IX4 = IX3 + IDO IF ( NA . NE . 0 ) GO TO 107 CALL RADF5 ( IDO , L1 , C , CH , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) GO TO 110 107 CALL RADF5 ( IDO , L1 , CH , C , WA ( IW ), WA ( IX2 ), WA ( IX3 ), WA ( IX4 )) GO TO 110 108 IF ( IDO . EQ . 1 ) NA = 1 - NA IF ( NA . NE . 0 ) GO TO 109 CALL RADFG ( IDO , IP , L1 , IDL1 , C , C , C , CH , CH , WA ( IW )) NA = 1 GO TO 110 109 CALL RADFG ( IDO , IP , L1 , IDL1 , CH , CH , CH , C , C , WA ( IW )) NA = 0 110 L2 = L1 111 CONTINUE IF ( NA . EQ . 1 ) RETURN DO 112 I = 1 , N C ( I ) = CH ( I ) 112 CONTINUE RETURN END SUBROUTINE RFFTI1 ( N , WA , IFAC ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION WA ( * ) , IFAC ( * ) , NTRYH ( 4 ) DATA NTRYH ( 1 ), NTRYH ( 2 ), NTRYH ( 3 ), NTRYH ( 4 ) / 4 , 2 , 3 , 5 / NL = N NF = 0 J = 0 101 J = J + 1 IF ( J - 4 ) 102 , 102 , 103 102 NTRY = NTRYH ( J ) GO TO 104 103 NTRY = NTRY + 2 104 NQ = NL / NTRY NR = NL - NTRY * NQ IF ( NR ) 101 , 105 , 101 105 NF = NF + 1 IFAC ( NF + 2 ) = NTRY NL = NQ IF ( NTRY . NE . 2 ) GO TO 107 IF ( NF . EQ . 1 ) GO TO 107 DO 106 I = 2 , NF IB = NF - I + 2 IFAC ( IB + 2 ) = IFAC ( IB + 1 ) 106 CONTINUE IFAC ( 3 ) = 2 107 IF ( NL . NE . 1 ) GO TO 104 IFAC ( 1 ) = N IFAC ( 2 ) = NF TPI = 6.28318530717958647692D0 ARGH = TPI / FLOAT ( N ) IS = 0 NFM1 = NF - 1 L1 = 1 IF ( NFM1 . EQ . 0 ) RETURN DO 110 K1 = 1 , NFM1 IP = IFAC ( K1 + 2 ) LD = 0 L2 = L1 * IP IDO = N / L2 IPM = IP - 1 DO 109 J = 1 , IPM LD = LD + L1 I = IS ARGLD = FLOAT ( LD ) * ARGH FI = 0.0D0 DO 108 II = 3 , IDO , 2 I = I + 2 FI = FI + 1.0D0 ARG = FI * ARGLD WA ( I - 1 ) = COS ( ARG ) WA ( I ) = SIN ( ARG ) 108 CONTINUE IS = IS + IDO 109 CONTINUE L1 = L2 110 CONTINUE RETURN END SUBROUTINE ZFFTB ( N , C , WSAVE ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION C ( 1 ) , WSAVE ( 1 ) IF ( N . EQ . 1 ) RETURN IW1 = N + N + 1 IW2 = IW1 + N + N CALL CFFTB1 ( N , C , WSAVE , WSAVE ( IW1 ), WSAVE ( IW2 )) RETURN END SUBROUTINE ZFFTF ( N , C , WSAVE ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION C ( 1 ) , WSAVE ( 1 ) IF ( N . EQ . 1 ) RETURN IW1 = N + N + 1 IW2 = IW1 + N + N CALL CFFTF1 ( N , C , WSAVE , WSAVE ( IW1 ), WSAVE ( IW2 )) RETURN END SUBROUTINE ZFFTI ( N , WSAVE ) IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) DIMENSION WSAVE ( 1 ) IF ( N . EQ . 1 ) RETURN IW1 = N + N + 1 IW2 = IW1 + N + N CALL CFFTI1 ( N , WSAVE ( IW1 ), WSAVE ( IW2 )) RETURN END","tags":"","loc":"sourcefile/dfftpack.f.html","title":"dfftpack.f – LibPFASST"},{"text":"Sweeper for Magnus integrator This file depends on sourcefile~~pf_magnus_picard.f90~~EfferentGraph sourcefile~pf_magnus_picard.f90 pf_magnus_picard.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_magnus_picard.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_magnus_picard Source Code pf_magnus_picard.f90 Source Code !!  Sweeper for Magnus integrator ! ! This file is part of LIBPFASST. ! !>  This module implements fully implicit Magnus method using explicit Picard sweeping module pf_mod_magnus_picard use pf_mod_dtype use pf_mod_utils implicit none !>  Magnus Picard sweeper type, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_magpicard_t real ( pfdp ), allocatable :: dtsdc (:) integer :: magnus_order , qtype real ( pfdp ) :: dt , commutator_coefs ( 9 , 3 , 4 ) complex ( pfdp ), allocatable :: commutators (:,:,:) class ( pf_encap_t ), allocatable :: omega (:), time_ev_op (:) contains procedure :: sweep => magpicard_sweep procedure :: initialize => magpicard_initialize procedure :: evaluate => magpicard_evaluate procedure :: integrate => magpicard_integrate procedure :: residual => magpicard_residual procedure :: spreadq0 => magpicard_spreadq0 procedure :: evaluate_all => magpicard_evaluate_all procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_compute_single_commutators_p ), deferred :: compute_single_commutators procedure ( pf_compute_omega_p ), deferred :: compute_omega procedure ( pf_propagate_solution_p ), deferred :: propagate_solution procedure ( pf_destroy_magpicard_p ), deferred :: destroy procedure :: magpicard_destroy end type pf_magpicard_t interface subroutine pf_f_eval_p ( this , y , t , level , f ) import pf_magpicard_t , pf_encap_t , pfdp class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: level class ( pf_encap_t ), intent ( inout ) :: f end subroutine pf_f_eval_p subroutine pf_compute_single_commutators_p ( this , f ) import pf_magpicard_t , pf_encap_t , pfdp class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: f (:,:) end subroutine pf_compute_single_commutators_p subroutine pf_compute_omega_p ( this , omega , integrals , f , nodes , qmat , dt , this_node , coefs ) import pf_magpicard_t , pf_encap_t , pfdp class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: omega class ( pf_encap_t ), intent ( inout ) :: f (:,:), integrals (:) real ( pfdp ), intent ( in ) :: coefs (:,:), nodes (:), qmat (:,:), dt integer , intent ( in ) :: this_node end subroutine pf_compute_omega_p subroutine pf_propagate_solution_p ( this , sol_t0 , sol_tn , omega , level ) import pf_magpicard_t , pf_encap_t , pfdp class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: sol_t0 class ( pf_encap_t ), intent ( inout ) :: omega class ( pf_encap_t ), intent ( inout ) :: sol_tn integer , intent ( in ) :: level end subroutine pf_propagate_solution_p subroutine pf_destroy_magpicard_p ( this , Lev ) import pf_magpicard_t , pf_level_t class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: Lev end subroutine pf_destroy_magpicard_p end interface contains ! Perform one SDC sweep on level Lev and set qend appropriately. subroutine magpicard_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: dt , t0 integer , intent ( in ) :: level_index integer , intent ( in ) :: nsweeps integer , optional , intent ( in ) :: flags class ( pf_level_t ), pointer :: lev integer :: m , nnodes , k real ( pfdp ) :: t lev => pf % levels ( level_index ) nnodes = lev % nnodes call call_hooks ( pf , level_index , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 ) call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps ! Copy values into residual do m = 1 , nnodes - 1 call lev % R ( m )% copy ( lev % Q ( m + 1 )) end do t = t0 !$omp parallel do private(m, t) do m = 1 , nnodes !          t = t + dt*this%dtsdc(m) t = t0 + dt * lev % nodes ( m ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end do !$omp end parallel do !$omp barrier call magpicard_integrate ( this , lev , lev % Q , lev % F , dt , lev % I ) if ( this % magnus_order > 1 . and . nnodes > 2 ) then call start_timer ( pf , TAUX ) call this % compute_single_commutators ( lev % F ) call end_timer ( pf , TAUX ) endif !! this loop not OMP'd because the deferred procs are OMP'd do m = 1 , nnodes - 1 call start_timer ( pf , TAUX + 1 ) call this % compute_omega ( this % omega ( m ), lev % I , lev % F , & lev % nodes , lev % sdcmats % qmat , dt , m , this % commutator_coefs (:,:, m )) call end_timer ( pf , TAUX + 1 ) end do !$omp parallel do private(m) do m = 1 , nnodes - 1 call this % propagate_solution ( lev % Q ( 1 ), lev % Q ( m + 1 ), this % omega ( m ), lev % index ) end do !$omp end parallel do call pf_residual ( pf , lev , dt ) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! Loop over sweeps call lev % qend % copy ( lev % Q ( nnodes )) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine magpicard_sweep subroutine magpicard_initialize ( this , lev ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev integer :: m , nnodes this % commutator_coefs = 0.0_pfdp this % npieces = 1 nnodes = lev % nnodes allocate ( this % dtsdc ( nnodes - 1 )) this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) !  SDC time step size (unscaled) call get_commutator_coefs ( this % qtype , nnodes , this % dt , this % commutator_coefs ) call lev % ulevel % factory % create_array ( this % omega , nnodes - 1 , & lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % time_ev_op , nnodes - 1 , & lev % index , lev % shape ) do m = 1 , nnodes - 1 call this % omega ( m )% setval ( 0.0_pfdp ) call this % time_ev_op ( m )% setval ( 0.0_pfdp ) end do end subroutine magpicard_initialize !> Compute SDC integral !>  fintSDC = \\int_{t_n}&#94;{t_m} fSDC dt subroutine magpicard_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: j , m do m = 1 , lev % nnodes - 1 call fintSDC ( m )% setval ( 0.0_pfdp ) do j = 1 , lev % nnodes call fintSDC ( m )% axpy ( dt * lev % sdcmats % qmat ( m , j ), fSDC ( j , 1 )) end do end do end subroutine magpicard_integrate ! Evaluate function values subroutine magpicard_evaluate ( this , lev , t , m , flags , step ) use pf_mod_dtype class ( pf_magpicard_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev integer , optional , intent ( in ) :: flags , step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine magpicard_evaluate subroutine magpicard_evaluate_all ( this , lev , t , flags , step ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine magpicard_evaluate_all subroutine magpicard_residual ( this , lev , dt , flags ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m do m = 1 , lev % nnodes - 1 call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do lev % residual = lev % R ( lev % nnodes - 1 )% norm () end subroutine magpicard_residual subroutine magpicard_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine magpicard_spreadq0 ! Destroy the matrices subroutine magpicard_destroy ( this , lev ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % dtsdc , this % commutators ) call lev % ulevel % factory % destroy_array ( this % omega , lev % nnodes - 1 , & lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( this % time_ev_op , lev % nnodes - 1 , & lev % index , lev % shape ) end subroutine magpicard_destroy subroutine get_commutator_coefs ( qtype , nnodes , dt , coefs ) integer , intent ( in ) :: qtype , nnodes real ( pfdp ), intent ( in ) :: dt real ( pfdp ), intent ( inout ) :: coefs (:,:,:) ! coefs has the structure coefs(coefs, magnus_order, node) ! for a given node, pass subroutines the coefs for a magnus order, then ! loop over coefs if ( qtype == 1 ) then ! we're talking Lobatto nodes, where nnodes=3 includes, t0, t_1/2, tn ! need some way to differentiate whether you want full collocation or not ! coefs(1:3, 1, 1) = dt**2 * [real(8)::11/480., -1/480., 1/480.] ! coefs(1:3, 1, 2) = dt**2 * [real(8)::1/15., 1/60., 1/15.] coefs ( 1 , 1 , 1 ) = - 1 / 4 8.d0 * dt ** 2 coefs ( 2 , 1 , 2 ) = - 1 / 1 2.d0 * dt ** 2 elseif ( qtype == 5 ) then coefs ( 1 : 3 , 1 , 1 ) = 1.d-3 * [ real ( 8 ) :: - 0.708256232441739d0 , 0.201427439334681d0 , - 0.002608155816283d0 ] coefs ( 1 : 3 , 1 , 2 ) = [ real ( 8 ) :: - 0.035291589565775d0 , 0.004482619613666d0 , - 0.000569367343553d0 ] coefs ( 1 : 3 , 1 , 3 ) = [ real ( 8 ) :: - 0.078891497044705d0 , - 0.018131905893999d0 , - 0.035152700676886d0 ] coefs ( 1 : 3 , 1 , 4 ) = [ real ( 8 ) :: - 0.071721913818656d0 , - 0.035860956909328d0 , - 0.071721913818656d0 ] coefs (:, 1 ,:) = dt ** 2 * coefs (:, 1 ,:) coefs (:, 2 , 1 ) = & [ real ( 8 ) :: 1.466782892818107d-6 , - 2.546845448743404d-6 , 7.18855795894042d-7 , & - 3.065370250683271d-7 , 6.962336322868984d-7 , - 1.96845581200288d-7 , & - 2.262216360714434d-8 , - 2.72797194008496d-9 , 8.54843541920492d-10 ] coefs (:, 2 , 2 ) = & [ real ( 8 ) :: 0.001040114336531742d0 , - 0.001714330280871491d0 , 0.0001980882752518163d0 , & - 0.00006910549596945875d0 , 0.0002905401601450182d0 , - 0.00003465884693947625d0 , & 0.0000924518848932026d0 , 0.0000125950571649574d0 , - 2.4709074423913880d-6 ] coefs (:, 2 , 3 ) = & [ real ( 8 ) :: 0.004148295975360902d0 , - 0.006387421893168941d0 , - 0.003594231910817328d0 , & 0.000997378110327084d0 , 0.0001241530237557625d0 , - 0.0003805975423160699d0 , & 0.003718384934573079d0 , 0.001693514295056844d0 , - 0.001060408584538103d0 ] coefs (:, 2 , 4 ) = & [ real ( 8 ) :: 0.003453850676072909d0 , - 0.005584950029394391d0 , - 0.007128159905937654d0 , & 0.001653439153439147d0 , 0.0d0 , - 0.001653439153439143d0 , & 0.007128159905937675d0 , 0.005584950029394475d0 , - 0.003453850676072897d0 ] coefs (:, 2 ,:) = dt ** 3 * coefs (:, 2 ,:) coefs ( 1 , 3 , 4 ) = dt ** 4 / 6 0.d0 else stop 'oh no! unsupported qtype' endif end subroutine get_commutator_coefs end module pf_mod_magnus_picard","tags":"","loc":"sourcefile/pf_magnus_picard.f90.html","title":"pf_magnus_picard.f90 – LibPFASST"},{"text":"Routines that run the PFASST algorithm This file depends on sourcefile~~pf_parallel.f90~~EfferentGraph sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_parallel.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_parallel.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90 pf_results.f90 sourcefile~pf_parallel.f90->sourcefile~pf_results.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_parallel.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_parallel.f90->sourcefile~pf_dtype.f90 sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 sourcefile~pf_interpolate.f90 pf_interpolate.f90 sourcefile~pf_parallel.f90->sourcefile~pf_interpolate.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_parallel.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_restrict.f90 pf_restrict.f90 sourcefile~pf_parallel.f90->sourcefile~pf_restrict.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_results.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_hooks.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_utils.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_timer.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_dtype.f90 sourcefile~pf_interpolate.f90->sourcefile~pf_restrict.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_utils.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_dtype.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_mpi.f90 sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_restrict.f90->sourcefile~pf_hooks.f90 sourcefile~pf_restrict.f90->sourcefile~pf_timer.f90 sourcefile~pf_restrict.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_dtype.f90 var pansourcefilepf_parallelf90EfferentGraph = svgPanZoom('#sourcefilepf_parallelf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_parallel.f90~~AfferentGraph sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_parallel Source Code pf_parallel.f90 Source Code !!  Routines that run the PFASST algorithm ! ! This file is part of LIBPFASST. ! !> Module of routines to run  PFASST module pf_mod_parallel use pf_mod_pfasst use pf_mod_interpolate use pf_mod_restrict use pf_mod_utils use pf_mod_timer use pf_mod_dtype use pf_mod_hooks use pf_mod_comm use pf_mod_results implicit none contains !>  This is the main interface to pfasst. !!  It examines the parameters and decides which subroutine to call !!  to execute the code correctly subroutine pf_pfasst_run ( pf , q0 , dt , tend , nsteps , qend , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  The complete PFASST structure class ( pf_encap_t ), intent ( inout ) :: q0 !!  The initial condition real ( pfdp ), intent ( in ) :: dt !!  The time step for each processor real ( pfdp ), intent ( in ) :: tend !!  The final time of run integer , intent ( in ), optional :: nsteps !!  The number of time steps class ( pf_encap_t ), intent ( inout ), optional :: qend !!  The computed solution at tend integer , intent ( in ), optional :: flags (:) !!  User defnined flags !  Local variables integer :: nproc !!  Total number of processors integer :: nsteps_loc !!  local number of time steps real ( pfdp ) :: tend_loc !!  The final time of run ! make a local copy of nproc nproc = pf % comm % nproc !>  Set the number of time steps to do !!  The user can either pass in the number of time steps or !!  pass in the time step size and length of run if ( present ( nsteps )) then nsteps_loc = nsteps tend_loc = dble ( nsteps_loc * dt ) else nsteps_loc = ceiling ( tend / dt ) !  Do  sanity check on steps if ( abs ( real ( nsteps_loc , pfdp ) - tend / dt ) > dt / 10 0.0 ) then print * , 'dt=' , dt print * , 'nsteps=' , nsteps_loc print * , 'tend=' , tend stop \"Invalid nsteps\" end if end if pf % state % nsteps = nsteps_loc !>  Allocate stuff for holding results call pf_initialize_results ( pf ) !  do sanity checks on Nproc if ( mod ( nsteps , nproc ) > 0 ) stop \"ERROR: nsteps must be multiple of nproc (pf_parallel.f90).\" if ( present ( qend )) then call pf_block_run ( pf , q0 , dt , nsteps_loc , qend = qend , flags = flags ) else call pf_block_run ( pf , q0 , dt , nsteps_loc , flags = flags ) end if call pf_dump_results ( pf ) !  What we would like to do is check for !  1.  nlevels==1  and nprocs ==1 -> Serial SDC !      Predictor is either spreadQ or nothing !      Then we just call a loop on sweeps !      Communication is copy !  2.  nlevels > 1  and nprocs ==1 -> Serial MLSDC !      Predictor is needed to populate levels (or nothing) !      Then we just call a loop on MLSDC sweeps !      Communication is copy !  3.  nlevels == 1  and nprocs > 1 -> Pipelined SDC !      Predictor is just like PFASST, but on finest (only) level (or nothing) !  4.  nlevels > 1  and nprocs > 1 -> PFASST end subroutine pf_pfasst_run ! !> PFASST Predictor. !>  Subroutine  to initialize the solution on each processor !!  The goal is to have a solution at each level and each node set to a consistent value !!  When this is called, the value of q0 at the fine level on each processor has been set somehow (see q0_style below) !! !! This can be broken down into four substeps !! 1. Get the  initial condition on the finest level at each node !! 2. Coarsen the initial condition to each coarser level with tau corrections !! 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent !!    (this is skipped if the fine initial conditions are already consistent) !! 4. Do some coarse grid sweeps to improve initial solutions on coarsest nodes !! 5. Interpolating coarse correction back to finer levels sweeping along the way. !! !! There are several parameters or flags that determine how things are done: !!  integer  q0_style:    can take 3 values !!           0:  Only the q0 at t=0 is valid  (default) !!           1:  The q0 at each processor is valid !!           2:  q0 and all nodes at each processor is valid !! logical  PFASST_pred:  If true, the burn-in step uses the \"PFASST predictor\" trick !! integer  nsweeps_burn: Determines how many sweeps are done on the coarse level during burn in !! integer  nsweeps_pred: Determines how many sweeps are done at the coarse level after burn in !! logical Pipeline_burn: True if coarse sweeps during burn in are pipelined  (meaningless if nsweeps_burn>1 on coarse level) !! logical Pipeline_pred: True if coarse sweeps after burn in are pipelined  (meaningless if nsweeps_pred>1 on coarse level) !!    Pipeline variables do nothing if there is only one processor !! logical  RK_pred:      If true, the coarse level is initialized with Runge-Kutta instead of the  PFASST burn in. !!                        We  will still do coarse sweeps after and correct finer levels !! !! The user defined flags(:) parameter is used to determine whether we are in a (standard) forward-in-time run (flags(1) == 1) !! or backward-in-time (for the adjoint) with a given terminal condition qend instead of initial condition q0  (flags(1) == 2). !! In the latter case, e.g., sweeper%spreadq0 has to do the correct thing (i.e., spread qend instead of q0). !! !! No time communication is performed during the predictor since all !! procesors can do the work themselves !! !!  The iteration count is reset to 0, and the status is reset to !!  ITERATING. subroutine pf_predictor ( pf , t0 , dt , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! PFASST main data structure real ( pfdp ), intent ( in ) :: t0 !! Initial time of this processor real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ), optional :: flags (:) !!  User defined flags class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p !! integer :: k !!  Loop indices integer :: level_index !!  Local variable for looping over levels real ( pfdp ) :: t0k !!  Initial time at time step k call call_hooks ( pf , 1 , PF_PRE_PREDICTOR ) call start_timer ( pf , TPREDICTOR ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'beginning predictor' !! !! Step 1. Getting the  initial condition on the finest level at each processor !!         If we are doing multiple levels, then we need to coarsen to fine level f_lev_p => pf % levels ( pf % nlevels ) if ( pf % q0_style < 2 ) then !  Spread q0 to all the nodes call f_lev_p % ulevel % sweeper % spreadq0 ( f_lev_p , t0 ) endif !! !!  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do coarsen  in predictor' if ( pf % nlevels > 1 ) then do level_index = pf % nlevels , 2 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call pf_residual ( pf , f_lev_p , dt ) call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % q0 , c_lev_p % q0 , t0 ) call restrict_time_space_fas ( pf , t0 , dt , level_index ) !  Restrict call save ( c_lev_p ) end do !  level_index = pf%nlevels, 2, -1 else level_index = 1 c_lev_p => pf % levels ( 1 ) end if !! !! Step 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent !!         (this is skipped if the fine initial conditions are already consistent) !! The first processor does nothing, the second does one set of sweeps, the third two, etc !! Hence, this is skipped completely if nprocs=1 if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do burnin  in predictor' if ( pf % q0_style . eq . 0 ) then !  The coarse level needs burn in !! If RK_pred is true, just do some RK_steps if ( pf % RK_pred ) then !  Use Runge-Kutta to get the coarse initial data !  Get new initial conditions call pf_recv ( pf , c_lev_p , 100000 + pf % rank , . true .) !  Do a RK_step call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 ) !  Send forward call pf_send ( pf , c_lev_p , 100000 + pf % rank + 1 , . false .) else !  Normal PFASST burn in level_index = 1 c_lev_p => pf % levels ( level_index ) do k = 1 , pf % rank + 1 pf % state % iter = - k t0k = t0 - ( pf % rank ) * dt + ( k - 1 ) * dt ! Remember t0=pf%rank*dt is the beginning of this time slice so t0-(pf%rank)*dt is 0 ! and we iterate up to the correct time step. ! for optimal control problem t, t0k has no influence on f_eval, so there this does something else ! Get new initial value (skip on first iteration) if ( k > 1 ) then call c_lev_p % q0 % copy ( c_lev_p % qend , flags = 0 ) ! If we are doing PFASST_pred, we use the old values at nodes, otherwise spread q0 if (. not . pf % PFASST_pred ) then call c_lev_p % ulevel % sweeper % spreadq0 ( c_lev_p , t0k ) end if end if !  Do some sweeps call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn ) end do endif !  RK_pred end if ! (q0_style .eq. 0) !! !! Step 4: Now we have everyone burned in, so do some coarse sweeps if ( pf % nlevels > 1 ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do sweeps  in predictor' , 'Pipeline_pred' , pf % Pipeline_pred pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING if ( pf % Pipeline_pred ) then do k = 1 , c_lev_p % nsweeps_pred pf % state % iter =- ( pf % rank + 1 ) - k !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + k , . true .) !  Do a sweep call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 ) !  Send forward call pf_send ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + 1 + k , . false .) end do ! k = 1, c_lev_p%nsweeps_pred-1 else !  Don't pipeline !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank , . true .) !  Do a sweeps call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , c_lev_p % nsweeps_pred ) !  Send forward call pf_send ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + 1 , . false .) endif ! (Pipeline_pred .eq. .true) then end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'returning to fine level in predictor' !! !!  Step 5:  Return to fine level sweeping on any level in between coarsest and finest do level_index = 2 , pf % nlevels !  Will do nothing with one level f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp ) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 0 ) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 0 ) !  Do a sweep on level unless we are at the finest level if ( level_index < pf % nlevels ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred ) end if end do call end_timer ( pf , TPREDICTOR ) call call_hooks ( pf , - 1 , PF_POST_PREDICTOR ) pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ending predictor' end subroutine pf_predictor !> Subroutine to test residuals to determine if the current processor has converged. subroutine pf_check_residual ( pf , residual_converged ) type ( pf_pfasst_t ), intent ( inout ) :: pf logical , intent ( out ) :: residual_converged !! Return true if residual is below tolerances residual_converged = . false . ! Check to see if relative tolerance is met if ( pf % levels ( pf % nlevels )% residual_rel < pf % rel_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , ' residual relative tol met' , pf % levels ( pf % nlevels )% residual_rel residual_converged = . true . end if ! Check to see if relative tolerance is met if ( pf % levels ( pf % nlevels )% residual < pf % abs_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( pf % nlevels )% residual residual_converged = . true . end if end subroutine pf_check_residual !> Subroutine to check if the current processor has converged and !> to update the next processor on the status !> Note that if the previous processor hasn't converged yet !> (pstatus), the current processor can't be converged yet either subroutine pf_check_convergence_block ( pf , send_tag ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: send_tag !! identifier for status send and receive logical :: residual_converged , converged ! Shortcut for fixed iteration mode if ( pf % abs_res_tol == 0 . and . pf % rel_res_tol == 0 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if call call_hooks ( pf , 1 , PF_PRE_CONVERGENCE ) !> Check to see if tolerances are met call pf_check_residual ( pf , residual_converged ) !>  Until I hear the previous processor is done, recieve it's status if ( pf % state % pstatus /= PF_STATUS_CONVERGED ) call pf_recv_status ( pf , send_tag ) !>  Check to see if I am converged converged = . false . if ( residual_converged ) then if ( pf % rank == 0 ) then converged = . true . else !  I am not the first processor, so I need to check the previous one if ( pf % state % pstatus == PF_STATUS_CONVERGED ) converged = . true . end if end if ! (residual_converged) !> Assign status and send it forward if ( converged ) then if ( pf % state % status == PF_STATUS_ITERATING ) then !  If I am converged for the first time !  then flip my flag and send the last status update pf % state % status = PF_STATUS_CONVERGED call pf_send_status ( pf , send_tag ) end if else !  I am not converged, send the news pf % state % status = PF_STATUS_ITERATING call pf_send_status ( pf , send_tag ) end if call call_hooks ( pf , 1 , PF_POST_CONVERGENCE ) end subroutine pf_check_convergence_block ! !>  PFASST controller for block mode subroutine pf_block_run ( pf , q0 , dt , nsteps , qend , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf class ( pf_encap_t ), intent ( in ) :: q0 real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsteps class ( pf_encap_t ), intent ( inout ), optional :: qend integer , intent ( in ), optional :: flags (:) class ( pf_level_t ), pointer :: lev_p !!  pointer to the one level we are operating on integer :: j , k integer :: nblocks !!  The number of blocks of steps to do integer :: nproc !!  The number of processors being used integer :: level_index_c !!  Coarsest leve in V-cycle call start_timer ( pf , TTOTAL ) pf % state % dt = dt pf % state % proc = pf % rank + 1 pf % state % step = pf % rank pf % state % t0 = pf % state % step * dt !  pointer to finest  level to start lev_p => pf % levels ( pf % nlevels ) !  Stick the initial condition into q0 (will happen on all processors) call lev_p % q0 % copy ( q0 , flags = 0 ) nproc = pf % comm % nproc nblocks = nsteps / nproc !  Decide what the coarsest level in the V-cycle is level_index_c = 1 if (. not . pf % Vcycle ) level_index_c = pf % nlevels do k = 1 , nblocks !  Loop over blocks of time steps ! print *,'Starting  step=',pf%state%step,'  block k=',k ! Each block will consist of !  1.  predictor !  2.  Vcycle until max iterations, or tolerances met !  3.  Move solution to next block !  Reset some flags !>  When starting a new block, broadcast new initial conditions to all procs !>  For initial block, this is done when initial conditions are set !> Reset some flags pf % state % iter = - 1 pf % state % itcnt = 0 pf % state % mysteps = 0 pf % state % status = PF_STATUS_PREDICTOR pf % state % pstatus = PF_STATUS_PREDICTOR pf % comm % statreq = - 66 pf % state % pfblock = k if ( k > 1 ) then if ( nproc > 1 ) then call lev_p % qend % pack ( lev_p % send ) !!  Pack away your last solution call pf_broadcast ( pf , lev_p % send , lev_p % mpibuflen , pf % comm % nproc - 1 ) call lev_p % q0 % unpack ( lev_p % send ) !!  Everyone resets their q0 else call lev_p % q0 % copy ( lev_p % qend , flags = 0 ) !!  Just stick qend in q0 end if !>  Update the step and t0 variables for new block pf % state % step = pf % state % step + pf % comm % nproc pf % state % t0 = pf % state % step * dt end if !> Call the predictor to get an initial guess on all levels and all processors call pf_predictor ( pf , pf % state % t0 , dt , flags ) !>  Start the loops over SDC sweeps pf % state % iter = 0 call call_hooks ( pf , - 1 , PF_POST_ITERATION ) call start_timer ( pf , TITERATION ) do j = 1 , pf % niters call call_hooks ( pf , - 1 , PF_PRE_ITERATION ) pf % state % iter = j !  Do a v_cycle call pf_v_cycle ( pf , k , pf % state % t0 , dt , level_index_c , pf % nlevels ) !  Check for convergence call pf_check_convergence_block ( pf , send_tag = 1111 * k + j ) !          print *,pf%rank, ' post res' call call_hooks ( pf , - 1 , PF_POST_ITERATION ) !  If we are converged, exit block if ( pf % state % status == PF_STATUS_CONVERGED ) exit end do !  Loop over the iteration in this bloc call call_hooks ( pf , - 1 , PF_POST_CONVERGENCE ) call end_timer ( pf , TITERATION ) call call_hooks ( pf , - 1 , PF_POST_STEP ) end do !  Loop over the blocks call end_timer ( pf , TTOTAL ) !  Grab the last solution for return (if wanted) if ( present ( qend )) then call qend % copy ( lev_p % qend , flags = 0 ) end if end subroutine pf_block_run !> Execute a V-cycle between levels nfine and ncoarse subroutine pf_v_cycle ( pf , iteration , t0 , dt , level_index_c , level_index_f , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 , dt integer , intent ( in ) :: iteration integer , intent ( in ) :: level_index_c !! Coarsest level of V-cycle integer , intent ( in ) :: level_index_f !! Finest level of V-cycle integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: f_lev_p , c_lev_p integer :: level_index , j !>  Post the nonblocking receives on the all the levels that will be recieving later !>    (for single level this will be skipped) do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ) call pf_post ( pf , f_lev_p , f_lev_p % index * 10000 + iteration ) end do !> move from fine to coarse doing sweeps do level_index = level_index_f , level_index_c + 1 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false .) call restrict_time_space_fas ( pf , t0 , dt , level_index ) call save ( c_lev_p ) end do ! Do the coarsest level level_index = level_index_c f_lev_p => pf % levels ( level_index ) if ( pf % pipeline_pred ) then do j = 1 , f_lev_p % nsweeps call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . true .) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . false .) end do else call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . true .) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false .) endif ! Now move coarse to fine interpolating and sweeping do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp ) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 0 ) call pf_recv ( pf , f_lev_p , level_index * 10000 + iteration , . false .) if ( pf % rank /= 0 ) then ! interpolate increment to q0 -- the fine initial condition ! needs the same increment that Q(1) got, but applied to the ! new fine initial condition call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 0 ) end if ! don't sweep on the finest level since that is only done at beginning if ( level_index < level_index_f ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) else !  compute residual for diagnostics since we didn't sweep pf % state % sweep = 1 call pf_residual ( pf , f_lev_p , dt ) end if end do end subroutine pf_v_cycle end module pf_mod_parallel","tags":"","loc":"sourcefile/pf_parallel.f90.html","title":"pf_parallel.f90 – LibPFASST"},{"text":"Multi-implicit forward-backward sweeper module This file depends on sourcefile~~pf_misdcq_oc.f90~~EfferentGraph sourcefile~pf_misdcq_oc.f90 pf_misdcQ_oc.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_timer.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_misdcq_oc.f90->sourcefile~pf_utils.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_misdcQ_oc Source Code pf_misdcQ_oc.f90 Source Code !! Multi-implicit forward-backward sweeper module ! ! This file is part of LIBPFASST. ! !>  Module of the  the derived sweeper class for doing MISDC sweeps for an equation of the form !!            y' = f_1(y) + f_2(y) + f_3(y)  !!  The f_1 piece is treated explicitly and f_2 and f_3 implicitly !!  Afer this sweeper is initialized (usually in main), the locgical flags can be changed if desired module pf_mod_misdcQ_oc use pf_mod_dtype use pf_mod_utils implicit none !>  Multi-implicit SDC sweeper type for optimal control, extends abstract sweeper type , extends ( pf_sweeper_t ), abstract :: pf_misdcQ_oc_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) real ( pfdp ), allocatable :: dtsdc (:) class ( pf_encap_t ), allocatable :: I3 (:) class ( pf_encap_t ), allocatable :: rhs contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdcQ_oc_sweep procedure :: initialize => misdcQ_oc_initialize procedure :: integrate => misdcQ_oc_integrate procedure :: residual => misdcQ_oc_residual procedure :: spreadq0 => misdcQ_oc_spreadq0 procedure :: evaluate_all => misdcQ_oc_evaluate_all procedure :: evaluate => misdcQ_oc_evaluate procedure :: destroy => misdcQ_oc_destroy procedure :: misdcQ_oc_destroy end type pf_misdcQ_oc_t interface !>  This is the interface for the routine to compute the RHS function values !>  Evaluate f_piece(y), where piece is one or two subroutine pf_f_eval_p ( this , y , t , level_index , f , piece , flags , idx , step ) !>  Evaluate f_piece(y), where piece is one or two import pf_misdcQ_oc_t , pf_encap_t , pfdp class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: y !!  Argument for evaluation real ( pfdp ), intent ( in ) :: t !!  Time at evaluation integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  RHS function value integer , intent ( in ) :: piece !!  Which piece to evaluate integer , intent ( in ) :: flags !!  forward or backward integer , intent ( in ), optional :: idx !! index of quadrature node integer , intent ( in ), optional :: step !! time step for sequential version end subroutine pf_f_eval_p !>  Solve the equation y - dtq*f_n(y) =rhs  where n is given by the argument piece subroutine pf_f_comp_p ( this , y , t , dtq , rhs , level_index , f , piece , flags ) import pf_misdcQ_oc_t , pf_encap_t , pfdp class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ) :: y !!  Solution of implicit solve real ( pfdp ), intent ( in ) :: t !!  Time of solve real ( pfdp ), intent ( in ) :: dtq !!  dt*quadrature weight class ( pf_encap_t ), intent ( in ) :: rhs !!  RHS for solve integer , intent ( in ) :: level_index !!  Level index class ( pf_encap_t ), intent ( inout ) :: f !!  f_n of solution y integer , intent ( in ) :: piece !!  Which piece to evaluate integer , intent ( in ) :: flags !!  forward or backward end subroutine pf_f_comp_p end interface contains ! Perform one forward and/or backward SDC sweep on level and set qend/q0 appropriately. subroutine misdcQ_oc_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index , nsweeps real ( pfdp ), intent ( in ) :: dt , t0 integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev integer :: k , m , n , which , Nnodes real ( pfdp ) :: t , tend logical :: sweep_y , sweep_p integer :: step lev => pf % levels ( level_index ) !!  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) step = pf % state % step + 1 which = 0 if ( present ( flags )) which = flags if ( which . eq . 1 ) then sweep_y = . true . sweep_p = . false . else if ( which . eq . 2 ) then sweep_y = . false . sweep_p = . true . else sweep_y = . true . sweep_p = . true . end if Nnodes = lev % nnodes tend = t0 + dt do k = 1 , nsweeps call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction if ( sweep_y ) then !  Forward in y do m = 1 , Nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp , 1 ) call this % I3 ( m )% setval ( 0.0_pfdp , 1 ) do n = 1 , Nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 ), 1 ) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( m , n ), lev % F ( n , 3 ), 1 ) call this % I3 ( m )% axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 ), 1 ) end do if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 1 ) end if end do end if if ( sweep_p ) then !  Backward in p do m = Nnodes - 1 , 1 , - 1 call lev % I ( m )% setval ( 0.0_pfdp , 2 ) call this % I3 ( m )% setval ( 0.0_pfdp , 2 ) do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffE ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 1 ), 2 ) call lev % I ( m )% axpy ( dt * this % QdiffI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 2 ), 2 ) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 3 ), 2 ) call this % I3 ( m )% axpy ( dt * this % QtilI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 3 ), 2 ) end do if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 2 ) end if end do end if ! do the time-stepping if ( k . eq . 1 ) then if ( sweep_y ) then call lev % Q ( 1 )% copy ( lev % q0 , 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 , 1 , 1 , step ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 , 1 , 1 , step ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 , 1 , 1 , step ) end if if ( sweep_p ) then call lev % Q ( Nnodes )% copy ( lev % qend , 2 ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 1 ), 1 , 2 , Nnodes , step ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 2 ), 2 , 2 , Nnodes , step ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 3 ), 3 , 2 , Nnodes , step ) end if end if ! k .eq. 1 if ( sweep_y ) then t = t0 do m = 1 , lev % nnodes - 1 t = t + dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp , 1 ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 ), 1 ) call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 ), 1 ) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 1 ) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( lev % Q ( m + 1 ), 1 ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 ), 1 ) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m ), 1 ) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 3 ), 3 , 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 , 1 , m + 1 , step ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 , m + 1 , step ) end do !call pf_residual(pf, lev, dt, 1) call lev % qend % copy ( lev % Q ( lev % nnodes ), 1 ) end if ! sweep_y if ( sweep_p ) then t = tend do m = Nnodes - 1 , 1 , - 1 t = t - dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp , 2 ) do n = Nnodes , m + 1 , - 1 call this % rhs % axpy ( dt * this % QtilE ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 1 ), 2 ) call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 2 ), 2 ) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( Nnodes ), 2 ) call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 2 ), 2 , 2 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( lev % Q ( m ), 2 ) do n = Nnodes , m + 1 , - 1 call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 3 ), 2 ) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m ), 2 ) call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 3 ), 3 , 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , 2 , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , 2 , m , step ) end do !call pf_residual(pf, lev, dt, 2) call lev % q0 % copy ( lev % Q ( 1 ), 2 ) end if ! sweep_p if ( sweep_p . and . sweep_y ) then call pf_residual ( pf , lev , dt , 0 ) else if ( sweep_y ) then call pf_residual ( pf , lev , dt , 1 ) else if ( sweep_p ) then call pf_residual ( pf , lev , dt , 2 ) else stop \"neither sweep on p nor on y : that should not happen\" end if ! done call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! k=1,nsweeps end subroutine misdcQ_oc_sweep ! Initialize matrices subroutine misdcQ_oc_initialize ( this , lev ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , n , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % dtsdc ( nnodes - 1 )) this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp !>  Array of substep sizes dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) !>  Make space for extra integration piece call lev % ulevel % factory % create_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) end subroutine misdcQ_oc_initialize subroutine misdcQ_oc_destroy ( this , lev ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( this % rhs , lev % index , lev % shape ) end subroutine misdcQ_oc_destroy ! Compute SDC integral subroutine misdcQ_oc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: n , m , p , which which = 0 if ( present ( flags )) which = flags do n = 1 , lev % nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call fintSDC ( n )% setval ( 0.0_pfdp , 1 ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , p ), 1 ) end do end do end if !  Backward in p if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call fintSDC ( lev % nnodes - n )% setval ( 0.0_pfdp , 2 ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( lev % nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( lev % nnodes + 1 - m , p ), 2 ) end do end do end if end do end subroutine misdcQ_oc_integrate ! Evaluate function values subroutine misdcQ_oc_evaluate ( this , lev , t , m , flags , step ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev integer , optional , intent ( in ) :: flags , step integer :: which , mystep which = 0 if ( present ( flags )) which = flags mystep = 1 if ( present ( step )) mystep = step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , which , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , which , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 , which , m , step ) end subroutine misdcQ_oc_evaluate subroutine misdcQ_oc_evaluate_all ( this , lev , t , flags , step ) !! Evaluate all function values class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , intent ( in ), optional :: flags , step !     call pf_generic_evaluate_all(this, lev, t, flags, step) integer :: m if (. not . present ( flags )) stop \"MISDCQ_OC EVAL_ALL WITHOUT FLAGS\" if (. not . present ( step )) stop \"MISDCQ_OC EVAL_ALL WITHOUT step\" do m = 1 , lev % nnodes call this % evaluate ( lev , t ( m ), m , flags , step ) end do end subroutine misdcQ_oc_evaluate_all subroutine misdcQ_oc_residual ( this , lev , dt , flags ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m , n , which which = 0 if ( present ( flags )) which = flags call this % integrate ( lev , lev % Q , lev % F , dt , lev % I , which ) ! add tau (which is 'node to node') if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), which ) end do end if ! subtract out Q do m = 1 , lev % nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 1 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 ), 1 ) end if if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 2 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( lev % nnodes ), 2 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m ), 2 ) end if end do end subroutine misdcQ_oc_residual subroutine misdcQ_oc_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer :: m , p , which , mystep which = 3 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SPREADQ0 WITHOUT FLAGS\" mystep = 1 if ( present ( step )) then mystep = step !needed for sequential version else print * , \"step not present in spreadq0\" , which stop end if select case ( which ) case ( 1 ) !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , 1 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , 1 , 1 , mystep ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), 1 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p ), 1 ) end do end do case ( 2 ) !  Stick terminal condition into last node slot call lev % Q ( lev % nnodes )% copy ( lev % qend , 2 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , lev % nnodes , 2 , mystep ) ! Spread F and solution to all nodes do m = lev % nnodes - 1 , 1 , - 1 call lev % Q ( m )% copy ( lev % Q ( lev % nnodes ), 2 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( lev % nnodes , p ), 2 ) end do end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) stop end select end subroutine misdcQ_oc_spreadq0 end module pf_mod_misdcQ_oc","tags":"","loc":"sourcefile/pf_misdcq_oc.f90.html","title":"pf_misdcQ_oc.f90 – LibPFASST"},{"text":"Communication wrappers This file depends on sourcefile~~pf_comm.f90~~EfferentGraph sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_pfasst.f90 pf_pfasst.f90 sourcefile~pf_comm.f90->sourcefile~pf_pfasst.f90 sourcefile~pf_quadrature.f90 pf_quadrature.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_quadrature.f90 sourcefile~pf_hooks.f90 pf_hooks.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_hooks.f90 sourcefile~pf_utils.f90 pf_utils.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90 pf_results.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_results.f90 sourcefile~pf_dtype.f90 pf_dtype.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90 pf_mpi.f90 sourcefile~pf_pfasst.f90->sourcefile~pf_mpi.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_utils.f90 sourcefile~pf_quadrature.f90->sourcefile~pf_dtype.f90 sourcefile~pf_hooks.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90 pf_timer.f90 sourcefile~pf_hooks.f90->sourcefile~pf_timer.f90 sourcefile~pf_utils.f90->sourcefile~pf_dtype.f90 sourcefile~pf_utils.f90->sourcefile~pf_timer.f90 sourcefile~pf_results.f90->sourcefile~pf_utils.f90 sourcefile~pf_results.f90->sourcefile~pf_dtype.f90 sourcefile~pf_mpi.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_dtype.f90 sourcefile~pf_timer.f90->sourcefile~pf_mpi.f90 var pansourcefilepf_commf90EfferentGraph = svgPanZoom('#sourcefilepf_commf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~pf_comm.f90~~AfferentGraph sourcefile~pf_comm.f90 pf_comm.f90 sourcefile~pf_parallel_oc.f90 pf_parallel_oc.f90 sourcefile~pf_parallel_oc.f90->sourcefile~pf_comm.f90 sourcefile~pf_parallel.f90 pf_parallel.f90 sourcefile~pf_parallel.f90->sourcefile~pf_comm.f90 sourcefile~pfasst.f90 pfasst.f90 sourcefile~pfasst.f90->sourcefile~pf_parallel.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules pf_mod_comm Source Code pf_comm.f90 Source Code !!  Communication wrappers ! ! This file is part of LIBPFASST. ! !> Module of communication wrappers module pf_mod_comm use pf_mod_pfasst implicit none contains !>  Subroutine to post a receive request for a new initial condition to be received after doing some work subroutine pf_post ( pf , level , tag , direction ) type ( pf_pfasst_t ), intent ( in ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: ierror , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'is beginning pf_post, state%pstatus=' , pf % state % pstatus , 'with tag =' , tag ierror = 0 if ( pf % rank /= 0 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 1 ) then source = pf % rank - 1 call pf % comm % post ( pf , level , tag , ierror , source ) elseif ( pf % rank /= pf % comm % nproc - 1 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 2 ) then source = pf % rank + 1 call pf % comm % post ( pf , level , tag , ierror , source ) end if if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during post' , ierror stop \"pf_parallel:pf_post\" endif if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'is leaving pf_post, state%pstatus=' , pf % state % pstatus , 'with tag =' , tag end subroutine pf_post !>  Subroutine to send this processor's convergence status to the next processor subroutine pf_send_status ( pf , tag , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: istatus integer :: ierror , dest if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction if ( pf % rank == 0 . and . dir == 2 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 1 ) return ierror = 0 istatus = pf % state % status if ( dir == 1 ) then dest = pf % rank + 1 elseif ( dir == 2 ) then dest = pf % rank - 1 else print * , pf % rank , 'warning: bad dir during send_status' , dir stop \"pf_parallel:pf_send_status\" end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begins send_status with status' , istatus , 'with tag =' , tag call pf % comm % send_status ( pf , tag , istatus , ierror , dest ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ends send_status' if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during send_status' , ierror stop \"pf_parallel:pf_send_status\" endif end subroutine pf_send_status !>  Subroutine to receive the convergence status from the previous processor subroutine pf_recv_status ( pf , tag , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: ierror , istatus , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction !  Return if this is the first processor if ( pf % rank == 0 . and . dir == 1 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 2 ) return if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin recv_status with pstatus=' , pf % state % pstatus , ' tag=' , tag ierror = 0 if ( dir == 1 ) then source = pf % rank - 1 elseif ( dir == 2 ) then source = pf % rank + 1 else print * , pf % rank , 'warning: bad dir in recv_status' , dir stop \"pf_parallel_oc:pf_recv_status\" end if if ( pf % debug ) print * , pf % rank , 'is receiving status backwards with tag ' , tag call pf % comm % recv_status ( pf , tag , istatus , ierror , source ) if ( ierror . eq . 0 ) then pf % state % pstatus = istatus else print * , pf % rank , 'warning: error during recv_status' , ierror stop \"pf_parallel_oc:pf_recv_status\" endif if ( pf % debug ) print * , pf % rank , 'status recvd = ' , istatus if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end recv_statuswith pstatus=' , pf % state % pstatus , 'tag=' , tag end subroutine pf_recv_status !>  Subroutine to send the solution to the next processor subroutine pf_send ( pf , level , tag , blocking , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , optional , intent ( in ) :: direction integer :: dir , ierror , dest if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default: send forward if ( present ( direction )) dir = direction if ( pf % rank == 0 . and . dir == 2 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 1 ) return if ( dir == 2 ) then call level % q0 % pack ( level % send , 2 ) dest = pf % rank - 1 else dest = pf % rank + 1 if ( present ( direction )) then !  This is for the imk sweeper where the presence of a flag matters call level % qend % pack ( level % send , 1 ) else call level % qend % pack ( level % send ) end if end if ierror = 0 call start_timer ( pf , TSEND + level % index - 1 ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin send, tag=' , tag , blocking , ' pf%state%status =' , pf % state % status call pf % comm % send ( pf , level , tag , blocking , ierror , dest ) if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during send' , ierror stop \"pf_parallel:pf_send\" endif if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end send, tag=' , tag , blocking call end_timer ( pf , TSEND + level % index - 1 ) end subroutine pf_send !>  Subroutine to recieve the solution from the previous processor subroutine pf_recv ( pf , level , tag , blocking , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf type ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , optional , intent ( in ) :: direction integer :: dir , ierror , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default: send forward if ( present ( direction )) dir = direction ierror = 0 call start_timer ( pf , TRECEIVE + level % index - 1 ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin recv, tag=' , tag , blocking , \"pf%state%pstatus=\" , pf % state % pstatus if ( pf % rank /= 0 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 1 ) then source = pf % rank - 1 call pf % comm % recv ( pf , level , tag , blocking , ierror , source ) if ( ierror . eq . 0 ) then if ( present ( direction )) then call level % q0 % unpack ( level % recv , 1 ) else call level % q0 % unpack ( level % recv ) end if end if elseif ( pf % rank /= pf % comm % nproc - 1 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 2 ) then source = pf % rank + 1 call pf % comm % recv ( pf , level , tag , blocking , ierror , source ) if ( ierror . eq . 0 ) then if ( present ( direction )) then call level % qend % unpack ( level % recv , 2 ) else call level % qend % unpack ( level % recv ) end if end if end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end recv, tag=' , tag , blocking if ( ierror . ne . 0 ) then print * , pf % rank , 'warning: mpi error during receive' , ierror stop \"pf_parallel:pf_recv\" end if call end_timer ( pf , TRECEIVE + level % index - 1 ) end subroutine pf_recv !>  Subroutine to broadcast the initial condition to all processors subroutine pf_broadcast ( pf , y , nvar , root ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: nvar , root real ( pfdp ) , intent ( in ) :: y ( nvar ) integer :: ierror if ( pf % comm % nproc . eq . 1 ) return call start_timer ( pf , TBROADCAST ) if ( pf % debug ) print * , 'beginning broadcast' call pf % comm % broadcast ( pf , y , nvar , root , ierror ) if ( ierror /= 0 ) then print * , pf % rank , 'warning:  error during broadcast' , ierror stop \"pf_parallel:pf_broadcast\" endif call end_timer ( pf , TBROADCAST ) if ( pf % debug ) print * , 'ending broadcast' end subroutine pf_broadcast !> Save current solution and function value so that future corrections can be computed subroutine save ( lev , flags ) class ( pf_level_t ), intent ( inout ) :: lev !!  Level to save on integer , optional , intent ( in ) :: flags !!  which component to save (state/adjoint) integer :: m , p if ( lev % Finterp ) then if ( allocated ( lev % pFflt )) then do m = 1 , lev % nnodes do p = 1 , size ( lev % F ( 1 ,:)) call lev % pF ( m , p )% copy ( lev % F ( m , p ), flags ) end do call lev % pQ ( m )% copy ( lev % Q ( m ), flags ) end do end if else if ( allocated ( lev % pQ )) then do m = 1 , lev % nnodes call lev % pQ ( m )% copy ( lev % Q ( m ), flags ) end do end if end if end subroutine save end module pf_mod_comm","tags":"","loc":"sourcefile/pf_comm.f90.html","title":"pf_comm.f90 – LibPFASST"},{"text":"type, public, extends( pf_factory_t ) :: ndsysarray_factory Type to create and destroy systems of N-dimensional arrays Inherits type~~ndsysarray_factory~~InheritsGraph type~ndsysarray_factory ndsysarray_factory type~pf_factory_t pf_factory_t type~ndsysarray_factory->type~pf_factory_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code ndsysarray_factory Type-Bound Procedures procedure, public :: create_single => ndsysarray_create_single public subroutine ndsysarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: create_array => ndsysarray_create_array public subroutine ndsysarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_single => ndsysarray_destroy_single public subroutine ndsysarray_destroy_single (this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_array => ndsysarray_destroy_array public subroutine ndsysarray_destroy_array (this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Source Code type , extends ( pf_factory_t ) :: ndsysarray_factory contains procedure :: create_single => ndsysarray_create_single procedure :: create_array => ndsysarray_create_array procedure :: destroy_single => ndsysarray_destroy_single procedure :: destroy_array => ndsysarray_destroy_array end type ndsysarray_factory","tags":"","loc":"type/ndsysarray_factory.html","title":"ndsysarray_factory – LibPFASST "},{"text":"type, public, extends( pf_encap_t ) :: ndsysarray Type for system of  N-dimensional arrays,  extends the abstract encap type Inherits type~~ndsysarray~~InheritsGraph type~ndsysarray ndsysarray type~pf_encap_t pf_encap_t type~ndsysarray->type~pf_encap_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dim ncomp ndof arr_shape flatarray Type-Bound Procedures setval copy norm pack unpack axpy eprint Source Code ndsysarray Components Type Visibility Attributes Name Initial integer, public :: dim integer, public :: ncomp integer, public :: ndof integer, public, allocatable :: arr_shape (:) real(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => ndsysarray_setval public subroutine ndsysarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure, public :: copy => ndsysarray_copy public subroutine ndsysarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure, public :: norm => ndsysarray_norm public function ndsysarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure, public :: pack => ndsysarray_pack public subroutine ndsysarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure, public :: unpack => ndsysarray_unpack public subroutine ndsysarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure, public :: axpy => ndsysarray_axpy public subroutine ndsysarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure, public :: eprint => ndsysarray_eprint public subroutine ndsysarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags Source Code type , extends ( pf_encap_t ) :: ndsysarray integer :: dim !  The spatial dimension of each component in system integer :: ncomp !  The number of components in the system integer :: ndof !  The number of variables in each component integer , allocatable :: arr_shape (:) real ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => ndsysarray_setval procedure :: copy => ndsysarray_copy procedure :: norm => ndsysarray_norm procedure :: pack => ndsysarray_pack procedure :: unpack => ndsysarray_unpack procedure :: axpy => ndsysarray_axpy procedure :: eprint => ndsysarray_eprint end type ndsysarray","tags":"","loc":"type/ndsysarray.html","title":"ndsysarray – LibPFASST "},{"text":"type, public :: pf_fft_t Define the fft package Inherits type~~pf_fft_t~~InheritsGraph type~pf_fft_t pf_fft_t c_ptr c_ptr type~pf_fft_t->c_ptr ffft, ifft Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables ffft ifft dim nx ny nz Lx Ly Lz normfact wk_1d wk_2d wk_3d Type-Bound Procedures fft_setup fft_destroy fftf fftb conv get_wk_ptr_1d get_wk_ptr_2d get_wk_ptr_3d make_lap_1d make_lap_2d make_lap_3d make_deriv_1d make_deriv_2d make_deriv_3d Source Code pf_fft_t Components Type Visibility Attributes Name Initial type(c_ptr), public :: ffft fftw pointers type(c_ptr), public :: ifft fftw pointers integer, public :: dim spatial number of dimensions integer, public :: nx grid sizes integer, public :: ny grid sizes integer, public :: nz grid sizes real(kind=pfdp), public :: Lx domain size real(kind=pfdp), public :: Ly domain size real(kind=pfdp), public :: Lz domain size real(kind=pfdp), public :: normfact normalization factor complex(kind=pfdp), public, pointer :: wk_1d (:) work space complex(kind=pfdp), public, pointer :: wk_2d (:,:) work space complex(kind=pfdp), public, pointer :: wk_3d (:,:,:) work space Type-Bound Procedures procedure, public :: fft_setup public subroutine fft_setup (this, grid_shape, dim, grid_size) Initialize the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) procedure, public :: fft_destroy public subroutine fft_destroy (this) Destroy the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this procedure, public :: fftf public subroutine fftf (this) Routine to take foreward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this procedure, public :: fftb public subroutine fftb (this) Routine to take inverse or backward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this generic, public :: conv => conv_1d, conv_2d, conv_3d public subroutine conv_1d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) public subroutine conv_2d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) public subroutine conv_3d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) procedure, public :: get_wk_ptr_1d public function get_wk_ptr_1d (this) result(wk) Routines to return the pointer to the work variable Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:) procedure, public :: get_wk_ptr_2d public function get_wk_ptr_2d (this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:,:) procedure, public :: get_wk_ptr_3d public function get_wk_ptr_3d (this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:,:,:) procedure, public :: make_lap_1d public subroutine make_lap_1d (this, lap) Routines to construct spectral differential operators Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) procedure, public :: make_lap_2d public subroutine make_lap_2d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) procedure, public :: make_lap_3d public subroutine make_lap_3d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) procedure, public :: make_deriv_1d public subroutine make_deriv_1d (this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) procedure, public :: make_deriv_2d public subroutine make_deriv_2d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir procedure, public :: make_deriv_3d public subroutine make_deriv_3d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir Source Code type :: pf_fft_t type ( c_ptr ) :: ffft , ifft !! fftw pointers integer :: dim !! spatial number of dimensions integer :: nx , ny , nz !! grid sizes real ( pfdp ) :: Lx , Ly , Lz !! domain size real ( pfdp ) :: normfact !! normalization factor complex ( pfdp ), pointer :: wk_1d (:) !! work space complex ( pfdp ), pointer :: wk_2d (:,:) !! work space complex ( pfdp ), pointer :: wk_3d (:,:,:) !! work space contains procedure :: fft_setup procedure :: fft_destroy procedure :: fftf procedure :: fftb procedure , private :: conv_1d , conv_2d , conv_3d generic :: conv => conv_1d , conv_2d , conv_3d procedure :: get_wk_ptr_1d procedure :: get_wk_ptr_2d procedure :: get_wk_ptr_3d procedure :: make_lap_1d procedure :: make_lap_2d procedure :: make_lap_3d procedure :: make_deriv_1d procedure :: make_deriv_2d procedure :: make_deriv_3d end type pf_fft_t","tags":"","loc":"type/pf_fft_t.html","title":"pf_fft_t – LibPFASST "},{"text":"type, public :: pf_fft_t Contents Variables nx ny nz dim lensavx lensavy lensavz Lx Ly Lz normfact wsavex wsavey wsavez workhatx workhaty workhatz wk_1d wk_2d wk_3d Type-Bound Procedures fft_setup fft_destroy fftf fftb conv get_wk_ptr_1d get_wk_ptr_2d get_wk_ptr_3d make_lap_1d make_lap_2d make_lap_3d make_deriv_1d make_deriv_2d make_deriv_3d Source Code pf_fft_t Components Type Visibility Attributes Name Initial integer, public :: nx grid sizes integer, public :: ny grid sizes integer, public :: nz grid sizes integer, public :: dim spatial dimension integer, public :: lensavx workspace lengths integer, public :: lensavy workspace lengths integer, public :: lensavz workspace lengths real(kind=pfdp), public :: Lx domain size real(kind=pfdp), public :: Ly domain size real(kind=pfdp), public :: Lz domain size real(kind=pfdp), public :: normfact normalization factor real(kind=pfdp), public, allocatable :: wsavex (:) real(kind=pfdp), public, allocatable :: wsavey (:) real(kind=pfdp), public, allocatable :: wsavez (:) complex(kind=pfdp), public, pointer :: workhatx (:) complex(kind=pfdp), public, pointer :: workhaty (:) complex(kind=pfdp), public, pointer :: workhatz (:) complex(kind=pfdp), public, pointer :: wk_1d (:) complex(kind=pfdp), public, pointer :: wk_2d (:,:) complex(kind=pfdp), public, pointer :: wk_3d (:,:,:) Type-Bound Procedures procedure, public :: fft_setup public subroutine fft_setup (this, grid_shape, dim, grid_size) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) procedure, public :: fft_destroy public subroutine fft_destroy (this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this procedure, public :: fftf public subroutine fftf (this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this procedure, public :: fftb public subroutine fftb (this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this generic, public :: conv => conv_1d, conv_2d, conv_3d public subroutine conv_1d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) public subroutine conv_2d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) public subroutine conv_3d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) procedure, public :: get_wk_ptr_1d public function get_wk_ptr_1d (this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:) procedure, public :: get_wk_ptr_2d public function get_wk_ptr_2d (this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:,:) procedure, public :: get_wk_ptr_3d public function get_wk_ptr_3d (this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:,:,:) procedure, public :: make_lap_1d public subroutine make_lap_1d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) procedure, public :: make_lap_2d public subroutine make_lap_2d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) procedure, public :: make_lap_3d public subroutine make_lap_3d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) procedure, public :: make_deriv_1d public subroutine make_deriv_1d (this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) procedure, public :: make_deriv_2d public subroutine make_deriv_2d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir procedure, public :: make_deriv_3d public subroutine make_deriv_3d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir Source Code type :: pf_fft_t integer :: nx , ny , nz !! grid sizes integer :: dim !! spatial dimension integer :: lensavx , lensavy , lensavz !! workspace lengths real ( pfdp ) :: Lx , Ly , Lz !! domain size real ( pfdp ) :: normfact !! normalization factor real ( pfdp ), allocatable :: wsavex (:) ! work space real ( pfdp ), allocatable :: wsavey (:) ! work space real ( pfdp ), allocatable :: wsavez (:) ! work space complex ( pfdp ), pointer :: workhatx (:) ! work space complex ( pfdp ), pointer :: workhaty (:) ! work space complex ( pfdp ), pointer :: workhatz (:) ! work space complex ( pfdp ), pointer :: wk_1d (:) ! work space complex ( pfdp ), pointer :: wk_2d (:,:) ! work space complex ( pfdp ), pointer :: wk_3d (:,:,:) ! work space contains procedure :: fft_setup procedure :: fft_destroy procedure :: fftf procedure :: fftb procedure , private :: conv_1d , conv_2d , conv_3d generic :: conv => conv_1d , conv_2d , conv_3d procedure :: get_wk_ptr_1d procedure :: get_wk_ptr_2d procedure :: get_wk_ptr_3d procedure :: make_lap_1d procedure :: make_lap_2d procedure :: make_lap_3d procedure :: make_deriv_1d procedure :: make_deriv_2d procedure :: make_deriv_3d end type pf_fft_t","tags":"","loc":"type/pf_fft_t~2.html","title":"pf_fft_t – LibPFASST "},{"text":"type, public, extends( pf_factory_t ) :: zndsysarray_factory Type to create and destroy the arrays Inherits type~~zndsysarray_factory~~InheritsGraph type~zndsysarray_factory zndsysarray_factory type~pf_factory_t pf_factory_t type~zndsysarray_factory->type~pf_factory_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code zndsysarray_factory Type-Bound Procedures procedure, public :: create_single => zndsysarray_create_single public subroutine zndsysarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: create_array => zndsysarray_create_array public subroutine zndsysarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_single => zndsysarray_destroy_single public subroutine zndsysarray_destroy_single (this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_array => zndsysarray_destroy_array public subroutine zndsysarray_destroy_array (this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Source Code type , extends ( pf_factory_t ) :: zndsysarray_factory contains procedure :: create_single => zndsysarray_create_single procedure :: create_array => zndsysarray_create_array procedure :: destroy_single => zndsysarray_destroy_single procedure :: destroy_array => zndsysarray_destroy_array end type zndsysarray_factory","tags":"","loc":"type/zndsysarray_factory.html","title":"zndsysarray_factory – LibPFASST "},{"text":"type, public, extends( pf_encap_t ) :: zndsysarray Type to extend the abstract encap and set procedure pointers Inherits type~~zndsysarray~~InheritsGraph type~zndsysarray zndsysarray type~pf_encap_t pf_encap_t type~zndsysarray->type~pf_encap_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dim ncomp ndof arr_shape flatarray Type-Bound Procedures setval copy norm pack unpack axpy eprint Source Code zndsysarray Components Type Visibility Attributes Name Initial integer, public :: dim integer, public :: ncomp integer, public :: ndof integer, public, allocatable :: arr_shape (:) complex(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => zndsysarray_setval public subroutine zndsysarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure, public :: copy => zndsysarray_copy public subroutine zndsysarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure, public :: norm => zndsysarray_norm public function zndsysarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure, public :: pack => zndsysarray_pack public subroutine zndsysarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure, public :: unpack => zndsysarray_unpack public subroutine zndsysarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure, public :: axpy => zndsysarray_axpy public subroutine zndsysarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure, public :: eprint => zndsysarray_eprint public subroutine zndsysarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags Source Code type , extends ( pf_encap_t ) :: zndsysarray integer :: dim !  The spatial dimension of each component in system integer :: ncomp !  The number of components in the system integer :: ndof !  The number of variables in each component integer , allocatable :: arr_shape (:) complex ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => zndsysarray_setval procedure :: copy => zndsysarray_copy procedure :: norm => zndsysarray_norm procedure :: pack => zndsysarray_pack procedure :: unpack => zndsysarray_unpack procedure :: axpy => zndsysarray_axpy procedure :: eprint => zndsysarray_eprint end type zndsysarray","tags":"","loc":"type/zndsysarray.html","title":"zndsysarray – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_exp_t Inherits type~~pf_exp_t~~InheritsGraph type~pf_exp_t pf_exp_t type~pf_sweeper_t pf_sweeper_t type~pf_exp_t->type~pf_sweeper_t type~pf_encap_t pf_encap_t type~pf_exp_t->type~pf_encap_t b, f_old, newF Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq w nodes eta b f_old newF use_phib Type-Bound Procedures f_eval phib swpPhib resPhib initialize sweep evaluate integrate residual spreadq0 evaluate_all destroy exp_destroy exp_initialize Source Code pf_exp_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: w (:,:,:) real(kind=pfdp), public, allocatable :: nodes (:) real(kind=pfdp), public, allocatable :: eta (:) class( pf_encap_t ), public, allocatable :: b (:) class( pf_encap_t ), public, allocatable :: f_old (:) class( pf_encap_t ), public, allocatable :: newF logical, public :: use_phib = .TRUE. Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level, n) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: n procedure( pf_phib ), public, deferred :: phib subroutine pf_phib(this, t, h, b, y) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y procedure( pf_swpPhib ), public, deferred :: swpPhib subroutine pf_swpPhib(this, j, h, b, y) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y procedure( pf_resPhib ), public, deferred :: resPhib subroutine pf_resPhib(this, j, h, b, y) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y procedure, public :: initialize => exp_initialize public subroutine exp_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: sweep => exp_sweep public subroutine exp_sweep (this, pf, level_index, t0, dt, nsweeps, flags) $              !  Now we have to add in the tauQ\n$ Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: evaluate => exp_evaluate public subroutine exp_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => exp_integrate public subroutine exp_integrate (this, lev, qSDC, fSDC, dt, fintsdc, flags) $        call LocalDerivsAtNode(this, 1, nnodes, fSDC(:,1), this%b(2:nnodes+1)) ! compute derivatives\n$        call this%b(1)%setval(real(0.0, pfdp))\n$        call this%b(1)%axpy(real(1.0, pfdp), qSDC(1))\n$        do i = 1, nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}}\n$            if (this%use_phib) then\n$                call this%phib(this%nodes(i+1), dt, this%b, fintsdc(i))\n$            else\n$                call this%resPhib(i, dt, this%b, fintsdc(i))\n$             end if\n$        end do Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintsdc (:) Integral from t_n to t_m integer, intent(in), optional :: flags procedure, public :: residual => exp_residual public subroutine exp_residual (this, lev, dt, flags) Compute the integral of F from t_n to t_m at each node Read more… Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags procedure, public :: spreadq0 => exp_spreadq0 public subroutine exp_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => exp_evaluate_all public subroutine exp_evaluate_all (this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => exp_destroy public subroutine exp_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level procedure, public :: exp_destroy public subroutine exp_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level procedure, public :: exp_initialize public subroutine exp_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_exp_t real ( pfdp ), allocatable :: w (:,:,:) ! weights real ( pfdp ), allocatable :: nodes (:) ! nodes real ( pfdp ), allocatable :: eta (:) ! normalized substeps (on interval [0, 1]) class ( pf_encap_t ), allocatable :: b (:) ! scratch space for computing nonlinear derivatives class ( pf_encap_t ), allocatable :: f_old (:) ! scratch space for storing nonlinear terms class ( pf_encap_t ), allocatable :: newF ! scratch space for storing new function evaluations LOGICAL :: use_phib = . TRUE . ! if TRUE calls phib otherwise calls swpPhib and resPhib contains ! specialized procedures for exponential integrator procedure ( pf_f_eval_p ), deferred :: f_eval ! computes nonlinear term in equation procedure ( pf_phib ), deferred :: phib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i procedure ( pf_swpPhib ), deferred :: swpPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n,j} for j = 1, ... q - 1 procedure ( pf_resPhib ), deferred :: resPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n} for j = 1, ... q - 1 procedure , private :: weights procedure , private :: LocalDerivsAtNode ! generic functions procedure :: initialize => exp_initialize procedure :: sweep => exp_sweep procedure :: evaluate => exp_evaluate procedure :: integrate => exp_integrate procedure :: residual => exp_residual procedure :: spreadq0 => exp_spreadq0 procedure :: evaluate_all => exp_evaluate_all procedure :: destroy => exp_destroy ! functions that can be accessed directly by types that inherit pf_exp_t procedure :: exp_destroy procedure :: exp_initialize end type pf_exp_t","tags":"","loc":"type/pf_exp_t.html","title":"pf_exp_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_verlet_t Define sweeper type Inherits type~~pf_verlet_t~~InheritsGraph type~pf_verlet_t pf_verlet_t type~pf_sweeper_t pf_sweeper_t type~pf_verlet_t->type~pf_sweeper_t type~pf_encap_t pf_encap_t type~pf_verlet_t->type~pf_encap_t rhs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq whichQQ doLU Htol H0 Qmat QQmat Qver QQver Qtil QQtil DQver DQQver DQtil DQQtil bvec bbarvec dtsdc tsdc iqend rhs Type-Bound Procedures f_eval f_comp hamiltonian sweep initialize evaluate integrate residual spreadq0 evaluate_all destroy verlet_destroy Source Code pf_verlet_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq integer, public :: whichQQ = 3 integer, public :: doLU real(kind=pfdp), public :: Htol real(kind=pfdp), public :: H0 real(kind=pfdp), public, ALLOCATABLE :: Qmat (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQmat (:,:) real(kind=pfdp), public, ALLOCATABLE :: Qver (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: Qtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: bvec (:) real(kind=pfdp), public, ALLOCATABLE :: bbarvec (:) real(kind=pfdp), public, allocatable :: dtsdc (:) real(kind=pfdp), public, allocatable :: tsdc (:) logical, public :: iqend class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval RHS function evaluations subroutine pf_f_eval_p(this, y, t, level_index, f) Prototype This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value procedure( pf_f_comp_p ), public, deferred :: f_comp Implicit solver subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Prototype Solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate procedure( pf_hamiltonian_p ), public, deferred :: hamiltonian Hamiltonian function pf_hamiltonian_p(this, y, t, level_index) result(H) Prototype Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Variable real(kind=pfdp), intent(in) :: t Time of solve integer, intent(in) :: level_index Level index Return Value real(kind=pfdp) procedure, public :: sweep => verlet_sweep Set the generic functions public subroutine verlet_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform one SDC sweep on level lev_index and set qend appropriately\n  Assign level pointer\n  Add the integral term Read more… Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: initialize => verlet_initialize public subroutine verlet_initialize (this, lev) Initialize integration matrices\n  Array of substep sizes\n$       do i = 1,nnodes\n$          do j = 1,nnodes\n$             this%QQmat(i,j) =  this%bvec(j)*(1.0_pfdp-this%Qmat(j,i)/this%bvec(i))\n$          end do\n$       end do\n$       this%QQmat = matmul(this%QQmat,this%Qmat)\n  Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: evaluate => verlet_evaluate public subroutine verlet_evaluate (this, lev, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => verlet_integrate public subroutine verlet_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Integrate (t_n to node) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags procedure, public :: residual => verlet_residual public subroutine verlet_residual (this, lev, dt, flags) Compute residual (t_n to node) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags procedure, public :: spreadq0 => verlet_spreadq0 public subroutine verlet_spreadq0 (this, lev, t0, flags, step) Spread the intial data for Verlet sweepers Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => verlet_evaluate_all public subroutine verlet_evaluate_all (this, lev, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => verlet_destroy public subroutine verlet_destroy (this, lev) Destroy Verlet sweeper matrices Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level procedure, public :: verlet_destroy public subroutine verlet_destroy (this, lev) Destroy Verlet sweeper matrices Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level Source Code type , extends ( pf_sweeper_t ), abstract :: pf_verlet_t integer :: whichQQ = 3 integer :: doLU real ( pfdp ) :: Htol , H0 !  Matrices real ( pfdp ), ALLOCATABLE :: Qmat (:,:) !  Spectral matrix for v real ( pfdp ), ALLOCATABLE :: QQmat (:,:) !  Spectral matrix for x real ( pfdp ), ALLOCATABLE :: Qver (:,:) !  Verlet matrix for v (Trapezoid) real ( pfdp ), ALLOCATABLE :: QQver (:,:) !  Verlet matrix for x real ( pfdp ), ALLOCATABLE :: Qtil (:,:) !  Approximate matrix for v real ( pfdp ), ALLOCATABLE :: QQtil (:,:) !  Approximate matrix for x real ( pfdp ), ALLOCATABLE :: DQver (:,:) !  Qmat-Qver real ( pfdp ), ALLOCATABLE :: DQQver (:,:) !  QQmat-QQver real ( pfdp ), ALLOCATABLE :: DQtil (:,:) !  Qmat-Qtil real ( pfdp ), ALLOCATABLE :: DQQtil (:,:) !  QQmat-QQtil real ( pfdp ), ALLOCATABLE :: bvec (:) !  Quadrature rule for v real ( pfdp ), ALLOCATABLE :: bbarvec (:) !  Quadrature rule for x real ( pfdp ), allocatable :: dtsdc (:) !  SDC step sizes real ( pfdp ), allocatable :: tsdc (:) !  SDC times logical :: iqend !  Decide whether to set qend by another Picard class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver procedure ( pf_hamiltonian_p ), deferred :: hamiltonian !!  Hamiltonian !>  Set the generic functions procedure :: sweep => verlet_sweep procedure :: initialize => verlet_initialize procedure :: evaluate => verlet_evaluate procedure :: integrate => verlet_integrate procedure :: residual => verlet_residual procedure :: spreadq0 => verlet_spreadq0 procedure :: evaluate_all => verlet_evaluate_all procedure :: destroy => verlet_destroy procedure :: verlet_destroy end type pf_verlet_t","tags":"","loc":"type/pf_verlet_t.html","title":"pf_verlet_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_amisdc_t Asynchronous multi-implicit sweeper type (old style) Inherits type~~pf_amisdc_t~~InheritsGraph type~pf_amisdc_t pf_amisdc_t type~pf_sweeper_t pf_sweeper_t type~pf_amisdc_t->type~pf_sweeper_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~pf_amisdc_t~~InheritedByGraph type~pf_amisdc_t pf_amisdc_t type~pf_amisdcq_t pf_amisdcQ_t type~pf_amisdcq_t->type~pf_amisdc_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq SdiffE SdiffI Type-Bound Procedures spreadq0 f1eval f2eval f2comp f3eval f3comp sweep initialize evaluate integrate residual evaluate_all destroy amisdc_destroy Source Code pf_amisdc_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) Type-Bound Procedures procedure( pf_spreadq0_p ), public, deferred :: spreadq0 subroutine pf_spreadq0_p(this, Lev, t0, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_f1eval_p ), public, deferred :: f1eval subroutine pf_f1eval_p(this, y, t, level, f1) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f1 procedure( pf_f2eval_p ), public, deferred :: f2eval subroutine pf_f2eval_p(this, y, t, level, f2) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 procedure( pf_f2comp_p ), public, deferred :: f2comp subroutine pf_f2comp_p(this, y, t, dt, rhs, level, f2) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 procedure( pf_f3eval_p ), public, deferred :: f3eval subroutine pf_f3eval_p(this, y, t, level, f3) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 procedure( pf_f3comp_p ), public, deferred :: f3comp subroutine pf_f3comp_p(this, y, t, dt, rhs, level, f3) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 procedure, public :: sweep => amisdc_sweep public subroutine amisdc_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: initialize => amisdc_initialize public subroutine amisdc_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: evaluate => amisdc_evaluate public subroutine amisdc_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m procedure, public :: integrate => amisdc_integrate public subroutine amisdc_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) procedure, public :: residual => amisdc_residual public subroutine amisdc_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt procedure, public :: evaluate_all => amisdc_evaluate_all public subroutine amisdc_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) procedure, public :: destroy => amisdc_destroy public subroutine amisdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: amisdc_destroy public subroutine amisdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_amisdc_t real ( pfdp ), allocatable :: SdiffE (:,:) real ( pfdp ), allocatable :: SdiffI (:,:) contains procedure ( pf_f1eval_p ), deferred :: f1eval procedure ( pf_f2eval_p ), deferred :: f2eval procedure ( pf_f2comp_p ), deferred :: f2comp procedure ( pf_f3eval_p ), deferred :: f3eval procedure ( pf_f3comp_p ), deferred :: f3comp procedure :: sweep => amisdc_sweep procedure :: initialize => amisdc_initialize procedure :: evaluate => amisdc_evaluate procedure :: integrate => amisdc_integrate procedure :: residual => amisdc_residual procedure :: evaluate_all => amisdc_evaluate_all procedure :: destroy => amisdc_destroy procedure :: amisdc_destroy end type pf_amisdc_t","tags":"","loc":"type/pf_amisdc_t.html","title":"pf_amisdc_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_imexQ_oc_t IMEX SDC sweeper type for optimal control, extends abstract sweeper Inherits type~~pf_imexq_oc_t~~InheritsGraph type~pf_imexq_oc_t pf_imexQ_oc_t type~pf_sweeper_t pf_sweeper_t type~pf_imexq_oc_t->type~pf_sweeper_t type~pf_encap_t pf_encap_t type~pf_imexq_oc_t->type~pf_encap_t rhs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq QtilE QtilI dtsdc QdiffE QdiffI explicit implicit rhs Type-Bound Procedures f_eval f_comp sweep initialize evaluate integrate residual evaluate_all spreadq0 destroy imexQ_oc_destroy Source Code pf_imexQ_oc_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QtilE (:,:) Approximate explcit quadrature rule real(kind=pfdp), public, allocatable :: QtilI (:,:) Approximate implcit quadrature rule real(kind=pfdp), public, allocatable :: dtsdc (:) SDC step sizes real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public, allocatable :: QdiffI (:,:) qmat-QtilI logical, public :: explicit = .true. Is there an explicit piece logical, public :: implicit = .true. Is there an implicit piece class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval RHS function evaluations subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) Prototype Evaluae f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags integer, intent(in), optional :: idx integer, intent(in), optional :: step procedure( pf_f_comp_p ), public, deferred :: f_comp Implicit solver subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Prototype Solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags procedure, public :: sweep => imexQ_oc_sweep Set the generic functions public subroutine imexQ_oc_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Assign level pointer Read more… Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level this is real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: initialize => imexQ_oc_initialize public subroutine imexQ_oc_initialize (this, lev) Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: evaluate => imexQ_oc_evaluate public subroutine imexQ_oc_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => imexQ_oc_integrate public subroutine imexQ_oc_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure, public :: residual => imexQ_oc_residual public subroutine imexQ_oc_residual (this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags procedure, public :: evaluate_all => imexQ_oc_evaluate_all public subroutine imexQ_oc_evaluate_all (this, lev, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: spreadq0 => imexQ_oc_spreadq0 public subroutine imexQ_oc_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => imexQ_oc_destroy public subroutine imexQ_oc_destroy (this, lev) deallocate Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: imexQ_oc_destroy public subroutine imexQ_oc_destroy (this, lev) deallocate Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_imexQ_oc_t real ( pfdp ), allocatable :: QtilE (:,:) !!  Approximate explcit quadrature rule real ( pfdp ), allocatable :: QtilI (:,:) !!  Approximate implcit quadrature rule real ( pfdp ), allocatable :: dtsdc (:) !!  SDC step sizes real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ), allocatable :: QdiffI (:,:) !!  qmat-QtilI logical :: explicit = . true . !!  Is there an explicit piece logical :: implicit = . true . !!  Is there an implicit piece class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver !>  Set the generic functions procedure :: sweep => imexQ_oc_sweep procedure :: initialize => imexQ_oc_initialize procedure :: evaluate => imexQ_oc_evaluate procedure :: integrate => imexQ_oc_integrate procedure :: residual => imexQ_oc_residual procedure :: evaluate_all => imexQ_oc_evaluate_all procedure :: spreadq0 => imexQ_oc_spreadq0 procedure :: destroy => imexQ_oc_destroy procedure :: imexQ_oc_destroy end type pf_imexQ_oc_t","tags":"","loc":"type/pf_imexq_oc_t.html","title":"pf_imexQ_oc_t – LibPFASST "},{"text":"type, public, extends( pf_factory_t ) :: ndarray_oc_factory Type to create and destroy N-dimenstional arrays for optimal control Inherits type~~ndarray_oc_factory~~InheritsGraph type~ndarray_oc_factory ndarray_oc_factory type~pf_factory_t pf_factory_t type~ndarray_oc_factory->type~pf_factory_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code ndarray_oc_factory Type-Bound Procedures procedure, public :: create_single => ndarray_oc_create_single public subroutine ndarray_oc_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: create_array => ndarray_oc_create_array public subroutine ndarray_oc_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_single => ndarray_oc_destroy_single public subroutine ndarray_oc_destroy_single (this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_array => ndarray_oc_destroy_array public subroutine ndarray_oc_destroy_array (this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Source Code type , extends ( pf_factory_t ) :: ndarray_oc_factory contains procedure :: create_single => ndarray_oc_create_single procedure :: create_array => ndarray_oc_create_array procedure :: destroy_single => ndarray_oc_destroy_single procedure :: destroy_array => ndarray_oc_destroy_array end type ndarray_oc_factory","tags":"","loc":"type/ndarray_oc_factory.html","title":"ndarray_oc_factory – LibPFASST "},{"text":"type, public, extends( pf_encap_t ) :: ndarray_oc N-dimensional array type for optimal control,  extends the abstract encap type Inherits type~~ndarray_oc~~InheritsGraph type~ndarray_oc ndarray_oc type~pf_encap_t pf_encap_t type~ndarray_oc->type~pf_encap_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dim shape yflatarray pflatarray Type-Bound Procedures setval copy norm pack unpack axpy eprint Source Code ndarray_oc Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) real(kind=pfdp), public, allocatable :: yflatarray (:) real(kind=pfdp), public, allocatable :: pflatarray (:) Type-Bound Procedures procedure, public :: setval => ndarray_oc_setval public subroutine ndarray_oc_setval (this, val, flags) Subroutine to set array to a scalar  value. Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure, public :: copy => ndarray_oc_copy public subroutine ndarray_oc_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure, public :: norm => ndarray_oc_norm public function ndarray_oc_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure, public :: pack => ndarray_oc_pack public subroutine ndarray_oc_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure, public :: unpack => ndarray_oc_unpack public subroutine ndarray_oc_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure, public :: axpy => ndarray_oc_axpy public subroutine ndarray_oc_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure, public :: eprint => ndarray_oc_eprint public subroutine ndarray_oc_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this integer, intent(in), optional :: flags Source Code type , extends ( pf_encap_t ) :: ndarray_oc integer :: dim integer , allocatable :: shape (:) real ( pfdp ), allocatable :: yflatarray (:) real ( pfdp ), allocatable :: pflatarray (:) contains procedure :: setval => ndarray_oc_setval procedure :: copy => ndarray_oc_copy procedure :: norm => ndarray_oc_norm procedure :: pack => ndarray_oc_pack procedure :: unpack => ndarray_oc_unpack procedure :: axpy => ndarray_oc_axpy procedure :: eprint => ndarray_oc_eprint end type ndarray_oc","tags":"","loc":"type/ndarray_oc.html","title":"ndarray_oc – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_imex_t IMEX SDC sweeper type (old style), extends abstract sweeper Inherits type~~pf_imex_t~~InheritsGraph type~pf_imex_t pf_imex_t type~pf_sweeper_t pf_sweeper_t type~pf_imex_t->type~pf_sweeper_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq SdiffE SdiffI Type-Bound Procedures f_eval f_comp sweep initialize evaluate integrate residual spreadq0 evaluate_all destroy imex_destroy Source Code pf_imex_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level, f, piece) Prototype Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece procedure( pf_f_comp_p ), public, deferred :: f_comp subroutine pf_f_comp_p(this, y, t, dt, rhs, level, f, piece) Prototype Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece procedure, public :: sweep => imex_sweep public subroutine imex_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: initialize => imex_initialize public subroutine imex_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: evaluate => imex_evaluate public subroutine imex_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m procedure, public :: integrate => imex_integrate public subroutine imex_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) procedure, public :: residual => imex_residual public subroutine imex_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt procedure, public :: spreadq0 => imex_spreadq0 public subroutine imex_spreadq0 (this, lev, t0) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 procedure, public :: evaluate_all => imex_evaluate_all public subroutine imex_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) procedure, public :: destroy => imex_destroy public subroutine imex_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: imex_destroy public subroutine imex_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_imex_t real ( pfdp ), allocatable :: SdiffE (:,:) real ( pfdp ), allocatable :: SdiffI (:,:) contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => imex_sweep procedure :: initialize => imex_initialize procedure :: evaluate => imex_evaluate procedure :: integrate => imex_integrate procedure :: residual => imex_residual procedure :: spreadq0 => imex_spreadq0 procedure :: evaluate_all => imex_evaluate_all procedure :: destroy => imex_destroy procedure :: imex_destroy end type pf_imex_t","tags":"","loc":"type/pf_imex_t.html","title":"pf_imex_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_misdc_t Multi-implicit SDC sweeper type (old style), extends abstract sweeper Inherits type~~pf_misdc_t~~InheritsGraph type~pf_misdc_t pf_misdc_t type~pf_sweeper_t pf_sweeper_t type~pf_misdc_t->type~pf_sweeper_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq SdiffE SdiffI Type-Bound Procedures spreadq0 f_eval f_comp sweep initialize evaluate integrate residual evaluate_all destroy misdc_destroy Source Code pf_misdc_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) Type-Bound Procedures procedure( pf_spreadq0_p ), public, deferred :: spreadq0 subroutine pf_spreadq0_p(this, Lev, t0, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level, f, piece) Prototype Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece procedure( pf_f_comp_p ), public, deferred :: f_comp subroutine pf_f_comp_p(this, y, t, dt, rhs, level, f, piece) Prototype Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece procedure, public :: sweep => misdc_sweep public subroutine misdc_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: initialize => misdc_initialize public subroutine misdc_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: evaluate => misdc_evaluate public subroutine misdc_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m procedure, public :: integrate => misdc_integrate public subroutine misdc_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) procedure, public :: residual => misdc_residual public subroutine misdc_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt procedure, public :: evaluate_all => misdc_evaluate_all public subroutine misdc_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) procedure, public :: destroy => misdc_destroy public subroutine misdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: misdc_destroy public subroutine misdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_misdc_t real ( pfdp ), allocatable :: SdiffE (:,:) real ( pfdp ), allocatable :: SdiffI (:,:) contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdc_sweep procedure :: initialize => misdc_initialize procedure :: evaluate => misdc_evaluate procedure :: integrate => misdc_integrate procedure :: residual => misdc_residual procedure :: evaluate_all => misdc_evaluate_all procedure :: destroy => misdc_destroy procedure :: misdc_destroy end type pf_misdc_t","tags":"","loc":"type/pf_misdc_t.html","title":"pf_misdc_t – LibPFASST "},{"text":"type, public, extends( pf_factory_t ) :: ndarray_factory Type to create and destroy N-dimenstional arrays Inherits type~~ndarray_factory~~InheritsGraph type~ndarray_factory ndarray_factory type~pf_factory_t pf_factory_t type~ndarray_factory->type~pf_factory_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code ndarray_factory Type-Bound Procedures procedure, public :: create_single => ndarray_create_single public subroutine ndarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: create_array => ndarray_create_array public subroutine ndarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_single => ndarray_destroy_single public subroutine ndarray_destroy_single (this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_array => ndarray_destroy_array public subroutine ndarray_destroy_array (this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Source Code type , extends ( pf_factory_t ) :: ndarray_factory contains procedure :: create_single => ndarray_create_single procedure :: create_array => ndarray_create_array procedure :: destroy_single => ndarray_destroy_single procedure :: destroy_array => ndarray_destroy_array end type ndarray_factory","tags":"","loc":"type/ndarray_factory.html","title":"ndarray_factory – LibPFASST "},{"text":"type, public, extends( pf_encap_t ) :: ndarray N-dimensional array type,  extends the abstract encap type Inherits type~~ndarray~~InheritsGraph type~ndarray ndarray type~pf_encap_t pf_encap_t type~ndarray->type~pf_encap_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dim shape flatarray Type-Bound Procedures setval copy norm pack unpack axpy eprint Source Code ndarray Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) real(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => ndarray_setval public subroutine ndarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure, public :: copy => ndarray_copy public subroutine ndarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure, public :: norm => ndarray_norm public function ndarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure, public :: pack => ndarray_pack public subroutine ndarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure, public :: unpack => ndarray_unpack public subroutine ndarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure, public :: axpy => ndarray_axpy public subroutine ndarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure, public :: eprint => ndarray_eprint public subroutine ndarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this integer, intent(in), optional :: flags Source Code type , extends ( pf_encap_t ) :: ndarray integer :: dim integer , allocatable :: shape (:) real ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => ndarray_setval procedure :: copy => ndarray_copy procedure :: norm => ndarray_norm procedure :: pack => ndarray_pack procedure :: unpack => ndarray_unpack procedure :: axpy => ndarray_axpy procedure :: eprint => ndarray_eprint end type ndarray","tags":"","loc":"type/ndarray.html","title":"ndarray – LibPFASST "},{"text":"type, public, extends( pf_factory_t ) :: zndarray_factory Inherits type~~zndarray_factory~~InheritsGraph type~zndarray_factory zndarray_factory type~pf_factory_t pf_factory_t type~zndarray_factory->type~pf_factory_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code zndarray_factory Type-Bound Procedures procedure, public :: create_single => zndarray_create_single public subroutine zndarray_create_single (this, x, level, shape) Wrapper routine for allocation of a single zndarray type array Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: create_array => zndarray_create_array public subroutine zndarray_create_array (this, x, n, level, shape) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_single => zndarray_destroy_single public subroutine zndarray_destroy_single (this, x, level, shape) Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure, public :: destroy_array => zndarray_destroy_array public subroutine zndarray_destroy_array (this, x, n, level, shape) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Source Code type , extends ( pf_factory_t ) :: zndarray_factory contains procedure :: create_single => zndarray_create_single procedure :: create_array => zndarray_create_array procedure :: destroy_single => zndarray_destroy_single procedure :: destroy_array => zndarray_destroy_array end type zndarray_factory","tags":"","loc":"type/zndarray_factory.html","title":"zndarray_factory – LibPFASST "},{"text":"type, public, extends( pf_encap_t ) :: zndarray Inherits type~~zndarray~~InheritsGraph type~zndarray zndarray type~pf_encap_t pf_encap_t type~zndarray->type~pf_encap_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dim shape flatarray Type-Bound Procedures setval copy norm pack unpack axpy eprint write_to_disk Source Code zndarray Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) complex(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => zndarray_setval public subroutine zndarray_setval (this, val, flags) Set solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure, public :: copy => zndarray_copy public subroutine zndarray_copy (this, src, flags) Copy solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure, public :: norm => zndarray_norm public function zndarray_norm (this, flags) result(norm) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure, public :: pack => zndarray_pack public subroutine zndarray_pack (this, z, flags) Pack solution q into a flat array. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure, public :: unpack => zndarray_unpack public subroutine zndarray_unpack (this, z, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure, public :: axpy => zndarray_axpy public subroutine zndarray_axpy (this, a, x, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure, public :: eprint => zndarray_eprint public subroutine zndarray_eprint (this, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this integer, intent(in), optional :: flags procedure, public :: write_to_disk public subroutine write_to_disk (this, filename) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this character(len=*), intent(in) :: filename Source Code type , extends ( pf_encap_t ) :: zndarray integer :: dim integer , allocatable :: shape (:) complex ( pfdp ), allocatable :: flatarray (:) contains procedure :: setval => zndarray_setval procedure :: copy => zndarray_copy procedure :: norm => zndarray_norm procedure :: pack => zndarray_pack procedure :: unpack => zndarray_unpack procedure :: axpy => zndarray_axpy procedure :: eprint => zndarray_eprint procedure :: write_to_disk end type zndarray","tags":"","loc":"type/zndarray.html","title":"zndarray – LibPFASST "},{"text":"type, public, abstract, extends( pf_stepper_t ) :: pf_ark_t IMEX or additive or semi-implicit Runge-Kutta stepper  type Inherits type~~pf_ark_t~~InheritsGraph type~pf_ark_t pf_ark_t type~pf_stepper_t pf_stepper_t type~pf_ark_t->type~pf_stepper_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces order AmatI AmatE cvec bvecI bvecE QtilI explicit implicit nstages Type-Bound Procedures f_eval f_comp do_n_steps initialize destroy Source Code pf_ark_t Components Type Visibility Attributes Name Initial integer, public :: npieces integer, public :: order real(kind=pfdp), public, allocatable :: AmatI (:,:) real(kind=pfdp), public, allocatable :: AmatE (:,:) real(kind=pfdp), public, allocatable :: cvec (:) real(kind=pfdp), public, allocatable :: bvecI (:) real(kind=pfdp), public, allocatable :: bvecE (:) real(kind=pfdp), public, allocatable :: QtilI (:,:) logical, public :: explicit = .true. logical, public :: implicit = .true. integer, public :: nstages Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Prototype Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece procedure( pf_f_comp_p ), public, deferred :: f_comp subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Prototype Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dtq class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece procedure, public :: do_n_steps => ark_do_n_steps public subroutine ark_do_n_steps (this, pf, level_index, t0, big_dt, nsteps_rk) Perform N steps of ark on level level_index and set qend appropriately.\n Assign pointer to appropriate level Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Level of the index to step on real(kind=pfdp), intent(in) :: t0 Time at start of time interval real(kind=pfdp), intent(in) :: big_dt Size of time interval to integrato on integer, intent(in) :: nsteps_rk Number of steps to use procedure, public :: initialize => ark_initialize public subroutine ark_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: destroy => ark_destroy public subroutine ark_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_stepper_t ), abstract :: pf_ark_t real ( pfdp ), allocatable :: AmatI (:,:) real ( pfdp ), allocatable :: AmatE (:,:) real ( pfdp ), allocatable :: cvec (:) real ( pfdp ), allocatable :: bvecI (:) real ( pfdp ), allocatable :: bvecE (:) real ( pfdp ), allocatable :: QtilI (:,:) logical :: explicit = . true . logical :: implicit = . true . integer :: nstages contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: do_n_steps => ark_do_n_steps procedure :: initialize => ark_initialize procedure :: destroy => ark_destroy end type pf_ark_t","tags":"","loc":"type/pf_ark_t.html","title":"pf_ark_t – LibPFASST "},{"text":"type, public, bind(c) :: pf_state_t The type that holds the state of the system Inherited by type~~pf_state_t~~InheritedByGraph type~pf_state_t pf_state_t type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_state_t state Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables t0 dt nsteps pfblock iter step level hook proc sweep status pstatus itcnt skippedy mysteps Source Code pf_state_t Components Type Visibility Attributes Name Initial real(kind=pfdp), public :: t0 Time at beginning of this time step real(kind=pfdp), public :: dt Time step size integer, public :: nsteps total number of time steps integer, public :: pfblock pfasst block being worked on integer, public :: iter current iteration number integer, public :: step current time step number assigned to processor integer, public :: level which level is currently being operated on integer, public :: hook which hook integer, public :: proc which processor integer, public :: sweep sweep number integer, public :: status status (iterating, converged etc) integer, public :: pstatus previous rank's status integer, public :: itcnt total iterations by this processor integer, public :: skippedy skipped sweeps for state (for mixed integration) integer, public :: mysteps steps I did Source Code type , bind ( c ) :: pf_state_t real ( pfdp ) :: t0 !!  Time at beginning of this time step real ( pfdp ) :: dt !!  Time step size integer :: nsteps !! total number of time steps integer :: pfblock !! pfasst block being worked on integer :: iter !! current iteration number integer :: step !! current time step number assigned to processor integer :: level !! which level is currently being operated on integer :: hook !! which hook integer :: proc !! which processor integer :: sweep !! sweep number integer :: status !! status (iterating, converged etc) integer :: pstatus !! previous rank's status integer :: itcnt !! total iterations by this processor integer :: skippedy !! skipped sweeps for state (for mixed integration) integer :: mysteps !! steps I did end type pf_state_t","tags":"","loc":"type/pf_state_t.html","title":"pf_state_t – LibPFASST "},{"text":"type, public :: pf_hook_t Abstract hook type: hooks call diagnostic routines from various places in code Inherited by type~~pf_hook_t~~InheritedByGraph type~pf_hook_t pf_hook_t type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_hook_t hooks Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables proc Source Code pf_hook_t Components Type Visibility Attributes Name Initial procedure( pf_hook_p ), public, pointer, nopass :: proc Source Code type :: pf_hook_t procedure ( pf_hook_p ), pointer , nopass :: proc end type pf_hook_t","tags":"","loc":"type/pf_hook_t.html","title":"pf_hook_t – LibPFASST "},{"text":"type, public, abstract :: pf_sweeper_t The abstract SDC sweeper type (must be extended) Inherited by type~~pf_sweeper_t~~InheritedByGraph type~pf_sweeper_t pf_sweeper_t type~pf_verlet_t pf_verlet_t type~pf_verlet_t->type~pf_sweeper_t type~pf_exp_t~2 pf_exp_t type~pf_exp_t~2->type~pf_sweeper_t type~pf_misdcq_oc_t pf_misdcQ_oc_t type~pf_misdcq_oc_t->type~pf_sweeper_t type~pf_imk_t pf_imk_t type~pf_imk_t->type~pf_sweeper_t type~pf_imexq_t pf_imexQ_t type~pf_imexq_t->type~pf_sweeper_t type~pf_misdcq_t pf_misdcQ_t type~pf_misdcq_t->type~pf_sweeper_t type~pf_user_level_t pf_user_level_t type~pf_user_level_t->type~pf_sweeper_t sweeper type~pf_imexq_oc_t pf_imexQ_oc_t type~pf_imexq_oc_t->type~pf_sweeper_t type~pf_exp_t pf_exp_t type~pf_exp_t->type~pf_sweeper_t type~pf_misdc_t pf_misdc_t type~pf_misdc_t->type~pf_sweeper_t type~pf_imex_t pf_imex_t type~pf_imex_t->type~pf_sweeper_t type~pf_amisdc_t pf_amisdc_t type~pf_amisdc_t->type~pf_sweeper_t type~pf_magpicard_t pf_magpicard_t type~pf_magpicard_t->type~pf_sweeper_t type~pf_amisdcq_t pf_amisdcQ_t type~pf_amisdcq_t->type~pf_amisdc_t type~pf_level_t pf_level_t type~pf_level_t->type~pf_user_level_t ulevel type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_level_t levels Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq Type-Bound Procedures sweep initialize evaluate integrate evaluate_all residual spreadq0 destroy Source Code pf_sweeper_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq Type-Bound Procedures procedure( pf_sweep_p ), public, deferred :: sweep subroutine pf_sweep_p(this, pf, level_index, t0, dt, nsweeps, flags) Prototype SDC sweeper subroutines Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags procedure( pf_initialize_p ), public, deferred :: initialize subroutine pf_initialize_p(this, lev) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure( pf_evaluate_p ), public, deferred :: evaluate subroutine pf_evaluate_p(this, lev, t, m, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_integrate_p ), public, deferred :: integrate subroutine pf_integrate_p(this, lev, qSDC, fSDC, dt, fintSDC, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt Time step size class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure( pf_evaluate_all_p ), public, deferred :: evaluate_all subroutine pf_evaluate_all_p(this, lev, t, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_residual_p ), public, deferred :: residual subroutine pf_residual_p(this, Lev, dt, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev real(kind=pfdp), intent(in) :: dt Time step size integer, intent(in), optional :: flags procedure( pf_spreadq0_p ), public, deferred :: spreadq0 subroutine pf_spreadq0_p(this, Lev, t0, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_destroy_p ), public, deferred :: destroy subroutine pf_destroy_p(this, Lev) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev Source Code type , abstract :: pf_sweeper_t integer :: npieces logical :: use_LUq contains procedure ( pf_sweep_p ), deferred :: sweep procedure ( pf_initialize_p ), deferred :: initialize procedure ( pf_evaluate_p ), deferred :: evaluate procedure ( pf_integrate_p ), deferred :: integrate procedure ( pf_evaluate_all_p ), deferred :: evaluate_all procedure ( pf_residual_p ), deferred :: residual procedure ( pf_spreadq0_p ), deferred :: spreadq0 procedure ( pf_destroy_p ), deferred :: destroy end type pf_sweeper_t","tags":"","loc":"type/pf_sweeper_t.html","title":"pf_sweeper_t – LibPFASST "},{"text":"type, public, abstract :: pf_stepper_t The abstract time stepper type (must be extended) Inherited by type~~pf_stepper_t~~InheritedByGraph type~pf_stepper_t pf_stepper_t type~pf_user_level_t pf_user_level_t type~pf_user_level_t->type~pf_stepper_t stepper type~pf_ark_t pf_ark_t type~pf_ark_t->type~pf_stepper_t type~pf_level_t pf_level_t type~pf_level_t->type~pf_user_level_t ulevel type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_level_t levels Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces order Type-Bound Procedures do_n_steps initialize destroy Source Code pf_stepper_t Components Type Visibility Attributes Name Initial integer, public :: npieces integer, public :: order Type-Bound Procedures procedure( pf_do_n_steps_p ), public, deferred :: do_n_steps subroutine pf_do_n_steps_p(this, pf, level_index, t0, big_dt, nsteps_rk) Prototype time stepper interfaces Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: big_dt Time step size integer, intent(in) :: nsteps_rk procedure( pf_initialize_stepper_p ), public, deferred :: initialize subroutine pf_initialize_stepper_p(this, lev) Prototype Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure( pf_destroy_stepper_p ), public, deferred :: destroy subroutine pf_destroy_stepper_p(this, Lev) Prototype Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev Source Code type , abstract :: pf_stepper_t integer :: npieces integer :: order contains procedure ( pf_do_n_steps_p ), deferred :: do_n_steps procedure ( pf_initialize_stepper_p ), deferred :: initialize procedure ( pf_destroy_stepper_p ), deferred :: destroy end type pf_stepper_t","tags":"","loc":"type/pf_stepper_t.html","title":"pf_stepper_t – LibPFASST "},{"text":"type, public, abstract :: pf_encap_t The abstract data type of the solution (must be extended) Inherited by type~~pf_encap_t~~InheritedByGraph type~pf_encap_t pf_encap_t type~pf_verlet_t pf_verlet_t type~pf_verlet_t->type~pf_encap_t rhs type~ndarray ndarray type~ndarray->type~pf_encap_t type~pf_exp_t~2 pf_exp_t type~pf_exp_t~2->type~pf_encap_t b, f_old, newF type~pf_misdcq_oc_t pf_misdcQ_oc_t type~pf_misdcq_oc_t->type~pf_encap_t I3, rhs type~ndsysarray ndsysarray type~ndsysarray->type~pf_encap_t type~pf_imk_t pf_imk_t type~pf_imk_t->type~pf_encap_t A type~pf_imexq_t pf_imexQ_t type~pf_imexq_t->type~pf_encap_t rhs type~pf_misdcq_t pf_misdcQ_t type~pf_misdcq_t->type~pf_encap_t I3, rhs type~pf_imexq_oc_t pf_imexQ_oc_t type~pf_imexq_oc_t->type~pf_encap_t rhs type~pf_exp_t pf_exp_t type~pf_exp_t->type~pf_encap_t b, f_old, newF type~pf_level_t pf_level_t type~pf_level_t->type~pf_encap_t Q, pQ, R, I, Fflt, tauQ, pFflt, q0, qend, F, pF type~zndarray zndarray type~zndarray->type~pf_encap_t type~ndarray_oc ndarray_oc type~ndarray_oc->type~pf_encap_t type~zndsysarray zndsysarray type~zndsysarray->type~pf_encap_t type~pf_magpicard_t pf_magpicard_t type~pf_magpicard_t->type~pf_encap_t omega, time_ev_op type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_level_t levels Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures setval copy norm pack unpack axpy eprint Source Code pf_encap_t Type-Bound Procedures procedure( pf_encap_setval_p ), public, deferred :: setval subroutine pf_encap_setval_p(this, val, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags procedure( pf_encap_copy_p ), public, deferred :: copy subroutine pf_encap_copy_p(this, src, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags procedure( pf_encap_norm_p ), public, deferred :: norm function pf_encap_norm_p(this, flags) result(norm) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) procedure( pf_encap_pack_p ), public, deferred :: pack subroutine pf_encap_pack_p(this, z, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags procedure( pf_encap_unpack_p ), public, deferred :: unpack subroutine pf_encap_unpack_p(this, z, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags procedure( pf_encap_axpy_p ), public, deferred :: axpy subroutine pf_encap_axpy_p(this, a, x, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags procedure( pf_encap_eprint_p ), public, deferred :: eprint subroutine pf_encap_eprint_p(this, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this integer, intent(in), optional :: flags Source Code type , abstract :: pf_encap_t contains procedure ( pf_encap_setval_p ), deferred :: setval procedure ( pf_encap_copy_p ), deferred :: copy procedure ( pf_encap_norm_p ), deferred :: norm procedure ( pf_encap_pack_p ), deferred :: pack procedure ( pf_encap_unpack_p ), deferred :: unpack procedure ( pf_encap_axpy_p ), deferred :: axpy procedure ( pf_encap_eprint_p ), deferred :: eprint end type pf_encap_t","tags":"","loc":"type/pf_encap_t.html","title":"pf_encap_t – LibPFASST "},{"text":"type, public, abstract :: pf_factory_t Abstract type for creation and destruction of objects Inherited by type~~pf_factory_t~~InheritedByGraph type~pf_factory_t pf_factory_t type~zndarray_factory zndarray_factory type~zndarray_factory->type~pf_factory_t type~zndsysarray_factory zndsysarray_factory type~zndsysarray_factory->type~pf_factory_t type~ndarray_factory ndarray_factory type~ndarray_factory->type~pf_factory_t type~pf_user_level_t pf_user_level_t type~pf_user_level_t->type~pf_factory_t factory type~ndsysarray_factory ndsysarray_factory type~ndsysarray_factory->type~pf_factory_t type~ndarray_oc_factory ndarray_oc_factory type~ndarray_oc_factory->type~pf_factory_t type~pf_level_t pf_level_t type~pf_level_t->type~pf_user_level_t ulevel type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_level_t levels Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures create_single create_array destroy_single destroy_array Source Code pf_factory_t Type-Bound Procedures procedure( pf_encap_create_single_p ), public, deferred :: create_single subroutine pf_encap_create_single_p(this, x, level, shape) Prototype encapsulation interfaces Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure( pf_encap_create_array_p ), public, deferred :: create_array subroutine pf_encap_create_array_p(this, x, n, level, shape) Prototype Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) procedure( pf_encap_destroy_single_p ), public, deferred :: destroy_single subroutine pf_encap_destroy_single_p(this, x, level, shape) Prototype Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) procedure( pf_encap_destroy_array_p ), public, deferred :: destroy_array subroutine pf_encap_destroy_array_p(this, x, n, level, shape) Prototype Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Source Code type , abstract :: pf_factory_t contains procedure ( pf_encap_create_single_p ), deferred :: create_single procedure ( pf_encap_create_array_p ), deferred :: create_array procedure ( pf_encap_destroy_single_p ), deferred :: destroy_single procedure ( pf_encap_destroy_array_p ), deferred :: destroy_array end type pf_factory_t","tags":"","loc":"type/pf_factory_t.html","title":"pf_factory_t – LibPFASST "},{"text":"type, public, abstract :: pf_user_level_t The absract definition of level which is inherited  to include problem dependent stuff Inherits type~~pf_user_level_t~~InheritsGraph type~pf_user_level_t pf_user_level_t type~pf_sweeper_t pf_sweeper_t type~pf_user_level_t->type~pf_sweeper_t sweeper type~pf_factory_t pf_factory_t type~pf_user_level_t->type~pf_factory_t factory type~pf_stepper_t pf_stepper_t type~pf_user_level_t->type~pf_stepper_t stepper Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~pf_user_level_t~~InheritedByGraph type~pf_user_level_t pf_user_level_t type~pf_level_t pf_level_t type~pf_level_t->type~pf_user_level_t ulevel type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_level_t levels Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables factory sweeper stepper Type-Bound Procedures restrict interpolate Source Code pf_user_level_t Components Type Visibility Attributes Name Initial class( pf_factory_t ), public, allocatable :: factory class( pf_sweeper_t ), public, allocatable :: sweeper class( pf_stepper_t ), public, allocatable :: stepper Type-Bound Procedures procedure( pf_transfer_p ), public, deferred :: restrict subroutine pf_transfer_p(this, levelF, levelG, qF, qG, t, flags) Prototype transfer interfaces used for restriction and interpolation Arguments Type Intent Optional Attributes Name class( pf_user_level_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: levelF class( pf_level_t ), intent(inout) :: levelG class( pf_encap_t ), intent(inout) :: qF class( pf_encap_t ), intent(inout) :: qG real(kind=pfdp), intent(in) :: t integer, intent(in), optional :: flags procedure( pf_transfer_p ), public, deferred :: interpolate subroutine pf_transfer_p(this, levelF, levelG, qF, qG, t, flags) Prototype transfer interfaces used for restriction and interpolation Arguments Type Intent Optional Attributes Name class( pf_user_level_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: levelF class( pf_level_t ), intent(inout) :: levelG class( pf_encap_t ), intent(inout) :: qF class( pf_encap_t ), intent(inout) :: qG real(kind=pfdp), intent(in) :: t integer, intent(in), optional :: flags Source Code type , abstract :: pf_user_level_t class ( pf_factory_t ), allocatable :: factory class ( pf_sweeper_t ), allocatable :: sweeper class ( pf_stepper_t ), allocatable :: stepper contains procedure ( pf_transfer_p ), deferred :: restrict procedure ( pf_transfer_p ), deferred :: interpolate end type pf_user_level_t","tags":"","loc":"type/pf_user_level_t.html","title":"pf_user_level_t – LibPFASST "},{"text":"type, public :: pf_sdcmats_t The type to store quadrature matrices Inherited by type~~pf_sdcmats_t~~InheritedByGraph type~pf_sdcmats_t pf_sdcmats_t type~pf_level_t pf_level_t type~pf_level_t->type~pf_sdcmats_t sdcmats type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_level_t levels Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nnodes qtype qnodes Qmat QmatFE QmatBE QmatTrap QmatVer QmatLU s0mat use_proper_nodes use_composite_nodes use_no_left_q Source Code pf_sdcmats_t Components Type Visibility Attributes Name Initial integer, public :: nnodes integer, public :: qtype real(kind=pfdp), public, allocatable :: qnodes (:) real(kind=pfdp), public, allocatable :: Qmat (:,:) real(kind=pfdp), public, allocatable :: QmatFE (:,:) real(kind=pfdp), public, allocatable :: QmatBE (:,:) real(kind=pfdp), public, allocatable :: QmatTrap (:,:) real(kind=pfdp), public, allocatable :: QmatVer (:,:) real(kind=pfdp), public, allocatable :: QmatLU (:,:) real(kind=pfdp), public, allocatable :: s0mat (:,:) logical, public :: use_proper_nodes = .false. logical, public :: use_composite_nodes = .false. logical, public :: use_no_left_q = .false. Source Code type :: pf_sdcmats_t integer :: nnodes !  Number of nodes integer :: qtype !  Type of nodes real ( pfdp ), allocatable :: qnodes (:) !  The quadrature nodes real ( pfdp ), allocatable :: Qmat (:,:) !  Collocation matrix real ( pfdp ), allocatable :: QmatFE (:,:) !  Forward Euler matrix real ( pfdp ), allocatable :: QmatBE (:,:) !  Backward Euler matrix real ( pfdp ), allocatable :: QmatTrap (:,:) ! Trapezoid rule matrix real ( pfdp ), allocatable :: QmatVer (:,:) ! Verlet Matrix real ( pfdp ), allocatable :: QmatLU (:,:) !  LU of Wmat real ( pfdp ), allocatable :: s0mat (:,:) !  deprecated logical :: use_proper_nodes = . false . !  If true use gauss nodes in coarsening logical :: use_composite_nodes = . false . ! If true, finer nodes are composite logical :: use_no_left_q = . false . ! If true don't use left endpoint in rule end type pf_sdcmats_t","tags":"","loc":"type/pf_sdcmats_t.html","title":"pf_sdcmats_t – LibPFASST "},{"text":"type, public :: pf_level_t Data type of a PFASST level Inherits type~~pf_level_t~~InheritsGraph type~pf_level_t pf_level_t type~pf_user_level_t pf_user_level_t type~pf_level_t->type~pf_user_level_t ulevel type~pf_encap_t pf_encap_t type~pf_level_t->type~pf_encap_t Q, pQ, R, I, Fflt, tauQ, pFflt, q0, qend, F, pF type~pf_sdcmats_t pf_sdcmats_t type~pf_level_t->type~pf_sdcmats_t sdcmats type~pf_sweeper_t pf_sweeper_t type~pf_user_level_t->type~pf_sweeper_t sweeper type~pf_factory_t pf_factory_t type~pf_user_level_t->type~pf_factory_t factory type~pf_stepper_t pf_stepper_t type~pf_user_level_t->type~pf_stepper_t stepper Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~pf_level_t~~InheritedByGraph type~pf_level_t pf_level_t type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_level_t levels Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables index nnodes nsteps_rk nsweeps nsweeps_pred Finterp mpibuflen error residual residual_rel ulevel send recv nodes rmat tmat nflags Q pQ R I Fflt tauQ pFflt q0 qend F pF shape sdcmats allocated Source Code pf_level_t Components Type Visibility Attributes Name Initial integer, public :: index = -1 level number (1 is the coarsest) integer, public :: nnodes = -1 number of sdc nodes integer, public :: nsteps_rk = -1 number of rk steps to perform integer, public :: nsweeps = -1 number of sdc sweeps to perform integer, public :: nsweeps_pred = -1 number of coarse sdc sweeps to perform predictor in predictor logical, public :: Finterp = .false. interpolate functions instead of solutions integer, public :: mpibuflen = -1 size of solution in pfdp units real(kind=pfdp), public :: error holds the user defined error real(kind=pfdp), public :: residual holds the user defined residual real(kind=pfdp), public :: residual_rel holds the user defined relative residual (scaled by solution magnitude) class( pf_user_level_t ), public, allocatable :: ulevel user customized level info real(kind=pfdp), public, allocatable :: send (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: recv (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: nodes (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: rmat (:,:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: tmat (:,:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix integer, public, allocatable :: nflags (:) sdc node flags class( pf_encap_t ), public, allocatable :: Q (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: pQ (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: R (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: I (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: Fflt (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: tauQ (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: pFflt (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: q0 Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: qend Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, pointer :: F (:,:) Function  storage\n functions values at sdc nodes\n functions at sdc nodes, previous sweep class( pf_encap_t ), public, pointer :: pF (:,:) Function  storage\n functions values at sdc nodes\n functions at sdc nodes, previous sweep integer, public, allocatable :: shape (:) user defined shape array type( pf_sdcmats_t ), public, allocatable :: sdcmats logical, public :: allocated = .false. Source Code type :: pf_level_t !  level parameters set by the pfasst_t values integer :: index = - 1 !! level number (1 is the coarsest) integer :: nnodes = - 1 !! number of sdc nodes integer :: nsteps_rk = - 1 !! number of rk steps to perform integer :: nsweeps = - 1 !! number of sdc sweeps to perform integer :: nsweeps_pred = - 1 !! number of coarse sdc sweeps to perform predictor in predictor logical :: Finterp = . false . !! interpolate functions instead of solutions !  Mandatory level parameter integer :: mpibuflen = - 1 !! size of solution in pfdp units !  Diagnostics real ( pfdp ) :: error !! holds the user defined error real ( pfdp ) :: residual !! holds the user defined residual real ( pfdp ) :: residual_rel !! holds the user defined relative residual (scaled by solution magnitude) class ( pf_user_level_t ), allocatable :: ulevel !!  user customized level info !>  Simple data storage at each level real ( pfdp ), allocatable :: & send (:), & !! send buffer recv (:), & !! recv buffer nodes (:), & !! list of SDC nodes rmat (:,:), & !! time restriction matrix tmat (:,:) !! time interpolation matrix integer , allocatable :: & nflags (:) !! sdc node flags !>  Solution variable storage class ( pf_encap_t ), allocatable :: & Q (:), & !! solution at sdc nodes pQ (:), & !! unknowns at sdc nodes, previous sweep R (:), & !! full residuals I (:), & !! 0 to node integrals Fflt (:), & !! functions values at sdc nodes (flat) tauQ (:), & !! fas correction in Q form pFflt (:), & !! functions at sdc nodes, previous sweep (flat) q0 , & !! initial condition qend !! solution at end time !>  Function  storage class ( pf_encap_t ), pointer :: & F (:,:), & !! functions values at sdc nodes pF (:,:) !! functions at sdc nodes, previous sweep integer , allocatable :: shape (:) !! user defined shape array type ( pf_sdcmats_t ), allocatable :: sdcmats logical :: allocated = . false . end type pf_level_t","tags":"","loc":"type/pf_level_t.html","title":"pf_level_t – LibPFASST "},{"text":"type, public :: pf_comm_t Data type to define the communicator Inherits type~~pf_comm_t~~InheritsGraph type~pf_comm_t pf_comm_t c_ptr c_ptr type~pf_comm_t->c_ptr pfs, pfpth Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~pf_comm_t~~InheritedByGraph type~pf_comm_t pf_comm_t type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_comm_t comm Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nproc comm recvreq sendreq statreq pfs pfpth post recv recv_status send send_status wait broadcast Source Code pf_comm_t Components Type Visibility Attributes Name Initial integer, public :: nproc = -1 integer, public :: comm = -1 integer, public, pointer :: recvreq (:) integer, public, pointer :: sendreq (:) integer, public :: statreq type(c_ptr), public, pointer :: pfs (:) type(c_ptr), public, pointer :: pfpth (:,:) procedure( pf_post_p ), public, pointer, nopass :: post Procedure interfaces procedure( pf_recv_p ), public, pointer, nopass :: recv procedure( pf_recv_status_p ), public, pointer, nopass :: recv_status procedure( pf_send_p ), public, pointer, nopass :: send procedure( pf_send_status_p ), public, pointer, nopass :: send_status procedure( pf_wait_p ), public, pointer, nopass :: wait procedure( pf_broadcast_p ), public, pointer, nopass :: broadcast Source Code type :: pf_comm_t integer :: nproc = - 1 ! total number of processors integer :: comm = - 1 ! communicator integer , pointer :: & recvreq (:), & ! receive requests (indexed by level) sendreq (:) ! send requests (indexed by level) integer :: statreq ! status send request ! fakie, needs modernization type ( c_ptr ), pointer :: pfs (:) ! pfasst objects (indexed by rank) type ( c_ptr ), pointer :: pfpth (:,:) !> Procedure interfaces procedure ( pf_post_p ), pointer , nopass :: post procedure ( pf_recv_p ), pointer , nopass :: recv procedure ( pf_recv_status_p ), pointer , nopass :: recv_status procedure ( pf_send_p ), pointer , nopass :: send procedure ( pf_send_status_p ), pointer , nopass :: send_status procedure ( pf_wait_p ), pointer , nopass :: wait procedure ( pf_broadcast_p ), pointer , nopass :: broadcast end type pf_comm_t","tags":"","loc":"type/pf_comm_t.html","title":"pf_comm_t – LibPFASST "},{"text":"type, public :: pf_results_t Type for storing results for later output Inherited by type~~pf_results_t~~InheritedByGraph type~pf_results_t pf_results_t type~pf_pfasst_t pf_pfasst_t type~pf_pfasst_t->type~pf_results_t results Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables errors residuals nsteps niters nprocs p_index nblocks nsweeps rank level dump destroy Source Code pf_results_t Components Type Visibility Attributes Name Initial real(kind=pfdp), public, allocatable :: errors (:,:,:) real(kind=pfdp), public, allocatable :: residuals (:,:,:) integer, public :: nsteps integer, public :: niters integer, public :: nprocs integer, public :: p_index integer, public :: nblocks integer, public :: nsweeps integer, public :: rank integer, public :: level procedure( pf_results_p ), public, pointer, nopass :: dump procedure( pf_results_p ), public, pointer, nopass :: destroy Source Code type :: pf_results_t real ( pfdp ), allocatable :: errors (:,:,:) real ( pfdp ), allocatable :: residuals (:,:,:) integer :: nsteps integer :: niters integer :: nprocs integer :: p_index integer :: nblocks integer :: nsweeps integer :: rank integer :: level procedure ( pf_results_p ), pointer , nopass :: dump procedure ( pf_results_p ), pointer , nopass :: destroy end type pf_results_t","tags":"","loc":"type/pf_results_t.html","title":"pf_results_t – LibPFASST "},{"text":"type, public :: pf_pfasst_t The main PFASST data type which includes pretty much everythingl Inherits type~~pf_pfasst_t~~InheritsGraph type~pf_pfasst_t pf_pfasst_t type~pf_state_t pf_state_t type~pf_pfasst_t->type~pf_state_t state type~pf_comm_t pf_comm_t type~pf_pfasst_t->type~pf_comm_t comm type~pf_results_t pf_results_t type~pf_pfasst_t->type~pf_results_t results type~pf_level_t pf_level_t type~pf_pfasst_t->type~pf_level_t levels type~pf_hook_t pf_hook_t type~pf_pfasst_t->type~pf_hook_t hooks c_ptr c_ptr type~pf_comm_t->c_ptr pfs, pfpth type~pf_user_level_t pf_user_level_t type~pf_level_t->type~pf_user_level_t ulevel type~pf_sdcmats_t pf_sdcmats_t type~pf_level_t->type~pf_sdcmats_t sdcmats type~pf_encap_t pf_encap_t type~pf_level_t->type~pf_encap_t Q, pQ, R, I, Fflt, tauQ, pFflt, q0, qend, F, pF type~pf_sweeper_t pf_sweeper_t type~pf_user_level_t->type~pf_sweeper_t sweeper type~pf_factory_t pf_factory_t type~pf_user_level_t->type~pf_factory_t factory type~pf_stepper_t pf_stepper_t type~pf_user_level_t->type~pf_stepper_t stepper var pantypepf_pfasst_tInheritsGraph = svgPanZoom('#typepf_pfasst_tInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nlevels niters qtype use_proper_nodes use_composite_nodes use_no_left_q nsweeps nsweeps_pred nnodes abs_res_tol rel_res_tol PFASST_pred pipeline_pred nsweeps_burn q0_style Vcycle Finterp use_LUq taui0 use_rk_stepper nsteps_rk RK_pred debug save_residuals save_timings echo_timings save_errors rank state levels comm results hooks nhooks timers runtimes outdir Source Code pf_pfasst_t Components Type Visibility Attributes Name Initial integer, public :: nlevels = -1 Mandatory parameters (must be set on command line or input file)\n number of pfasst levels integer, public :: niters = 5 Optional parameters\n number of PFASST iterations to do integer, public :: qtype = SDC_GAUSS_LOBATTO type of nodes logical, public :: use_proper_nodes = .false. logical, public :: use_composite_nodes = .false. logical, public :: use_no_left_q = .false. integer, public :: nsweeps (PF_MAXLEVS) = 1 number of sweeps at each levels integer, public :: nsweeps_pred (PF_MAXLEVS) = 1 number of sweeps during predictor integer, public :: nnodes (PF_MAXLEVS) = 3 number of nodes real(kind=pfdp), public :: abs_res_tol = 0.d0 absolute convergence tolerance real(kind=pfdp), public :: rel_res_tol = 0.d0 relative convergence tolerance logical, public :: PFASST_pred = .true. true if the PFASST type predictor is used logical, public :: pipeline_pred = .false. true if coarse sweeps after burn in are pipelined  (if nsweeps_pred>1 on coarse level) integer, public :: nsweeps_burn = 1 number of sdc sweeps to perform during coarse level burn in integer, public :: q0_style = 0 q0 can take 3 values\n  0:  Only the q0 at t=0 is valid  (default)\n  1:  The q0 at each processor is valid\n  2:  q0 and all nodes at each processor is valid logical, public :: Vcycle = .true. decides if Vcycles are done logical, public :: Finterp = .false. True if transfer functions operate on rhs logical, public :: use_LUq = .true. True if LU type implicit matrix is used integer, public :: taui0 = -999999 iteration cutoff for tau inclusion logical, public :: use_rk_stepper = .false. RK and Parareal options\n decides if RK steps are used instead of the sweeps integer, public :: nsteps_rk (PF_MAXLEVS) = 3 number of runge-kutta nodes logical, public :: RK_pred = .false. true if the coarse level is initialized with Runge-Kutta instead of PFASST logical, public :: debug = .false. If true, debug diagnostics are printed logical, public :: save_residuals = .false. If true, residuals are saved and output logical, public :: save_timings = .false. If true, timings are saved and  output logical, public :: echo_timings = .false. If true, timings are  output to screen logical, public :: save_errors = .false. If true, errors  are saved and output integer, public :: rank = -1 rank of current processor type( pf_state_t ), public, allocatable :: state pf objects\n  Describes where in the algorithm proc is type( pf_level_t ), public, allocatable :: levels (:) Holds the levels type( pf_comm_t ), public, pointer :: comm Points to communicator type( pf_results_t ), public, allocatable :: results (:) Hold results for each level type( pf_hook_t ), public, allocatable :: hooks (:,:,:) hooks variables\n  Holds the hooks integer, public, allocatable :: nhooks (:,:) Holds the number hooks double precision, public :: timers (100) = 0.0d0 timing variables double precision, public :: runtimes (100) = 0.0d0 character(len=512), public :: outdir output directory Source Code type :: pf_pfasst_t !>  Mandatory parameters (must be set on command line or input file) integer :: nlevels = - 1 !! number of pfasst levels !>  Optional parameters integer :: niters = 5 !! number of PFASST iterations to do integer :: qtype = SDC_GAUSS_LOBATTO !! type of nodes logical :: use_proper_nodes = . false . logical :: use_composite_nodes = . false . logical :: use_no_left_q = . false . ! --  level dependent parameters integer :: nsweeps ( PF_MAXLEVS ) = 1 !!  number of sweeps at each levels integer :: nsweeps_pred ( PF_MAXLEVS ) = 1 !!  number of sweeps during predictor integer :: nnodes ( PF_MAXLEVS ) = 3 !! number of nodes ! --  tolerances real ( pfdp ) :: abs_res_tol = 0.d0 !!  absolute convergence tolerance real ( pfdp ) :: rel_res_tol = 0.d0 !!  relative convergence tolerance ! --  predictor options  (should be set before pfasst_run is called) logical :: PFASST_pred = . true . !!  true if the PFASST type predictor is used logical :: pipeline_pred = . false . !!  true if coarse sweeps after burn in are pipelined  (if nsweeps_pred>1 on coarse level) integer :: nsweeps_burn = 1 !!  number of sdc sweeps to perform during coarse level burn in integer :: q0_style = 0 !!  q0 can take 3 values !!  0:  Only the q0 at t=0 is valid  (default) !!  1:  The q0 at each processor is valid !!  2:  q0 and all nodes at each processor is valid ! --  run options  (should be set before pfasst_run is called) logical :: Vcycle = . true . !!  decides if Vcycles are done logical :: Finterp = . false . !!  True if transfer functions operate on rhs logical :: use_LUq = . true . !!  True if LU type implicit matrix is used integer :: taui0 = - 999999 !! iteration cutoff for tau inclusion !> RK and Parareal options logical :: use_rk_stepper = . false . !! decides if RK steps are used instead of the sweeps integer :: nsteps_rk ( PF_MAXLEVS ) = 3 !! number of runge-kutta nodes logical :: RK_pred = . false . !!  true if the coarse level is initialized with Runge-Kutta instead of PFASST ! -- misc logical :: debug = . false . !!  If true, debug diagnostics are printed logical :: save_residuals = . false . !!  If true, residuals are saved and output logical :: save_timings = . false . !!  If true, timings are saved and  output logical :: echo_timings = . false . !!  If true, timings are  output to screen logical :: save_errors = . false . !!  If true, errors  are saved and output integer :: rank = - 1 !! rank of current processor !> pf objects type ( pf_state_t ), allocatable :: state !!  Describes where in the algorithm proc is type ( pf_level_t ), allocatable :: levels (:) !! Holds the levels type ( pf_comm_t ), pointer :: comm !! Points to communicator type ( pf_results_t ), allocatable :: results (:) !!  Hold results for each level !> hooks variables type ( pf_hook_t ), allocatable :: hooks (:,:,:) !!  Holds the hooks integer , allocatable :: nhooks (:,:) !!  Holds the number hooks !> timing variables double precision :: timers ( 100 ) = 0.0d0 double precision :: runtimes ( 100 ) = 0.0d0 !> output directory character ( 512 ) :: outdir end type pf_pfasst_t","tags":"","loc":"type/pf_pfasst_t.html","title":"pf_pfasst_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_misdcQ_t Multi-implicit SDC sweeper type, extends abstract sweeper Inherits type~~pf_misdcq_t~~InheritsGraph type~pf_misdcq_t pf_misdcQ_t type~pf_sweeper_t pf_sweeper_t type~pf_misdcq_t->type~pf_sweeper_t type~pf_encap_t pf_encap_t type~pf_misdcq_t->type~pf_encap_t I3, rhs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq QdiffE QdiffI QtilE QtilI dtsdc I3 rhs Type-Bound Procedures f_eval f_comp sweep initialize integrate residual spreadq0 evaluate_all evaluate destroy misdcQ_destroy Source Code pf_misdcQ_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) real(kind=pfdp), public, allocatable :: dtsdc (:) class( pf_encap_t ), public, allocatable :: I3 (:) class( pf_encap_t ), public, allocatable :: rhs Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Prototype This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate procedure( pf_f_comp_p ), public, deferred :: f_comp subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Prototype Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate procedure, public :: sweep => misdcQ_sweep public subroutine misdcQ_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Assign level pointer Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: initialize => misdcQ_initialize public subroutine misdcQ_initialize (this, lev) Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: integrate => misdcQ_integrate public subroutine misdcQ_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure, public :: residual => misdcQ_residual public subroutine misdcQ_residual (this, lev, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags procedure, public :: spreadq0 => misdcQ_spreadq0 public subroutine misdcQ_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => misdcQ_evaluate_all public subroutine misdcQ_evaluate_all (this, lev, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate => misdcQ_evaluate public subroutine misdcQ_evaluate (this, lev, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => misdcQ_destroy public subroutine misdcQ_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: misdcQ_destroy public subroutine misdcQ_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_misdcQ_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) real ( pfdp ), allocatable :: dtsdc (:) class ( pf_encap_t ), allocatable :: I3 (:) class ( pf_encap_t ), allocatable :: rhs contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdcQ_sweep procedure :: initialize => misdcQ_initialize procedure :: integrate => misdcQ_integrate procedure :: residual => misdcQ_residual procedure :: spreadq0 => misdcQ_spreadq0 procedure :: evaluate_all => misdcQ_evaluate_all procedure :: evaluate => misdcQ_evaluate procedure :: destroy => misdcQ_destroy procedure :: misdcQ_destroy end type pf_misdcQ_t","tags":"","loc":"type/pf_misdcq_t.html","title":"pf_misdcQ_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_imexQ_t IMEX SDC sweeper type, extends abstract sweeper Inherits type~~pf_imexq_t~~InheritsGraph type~pf_imexq_t pf_imexQ_t type~pf_sweeper_t pf_sweeper_t type~pf_imexq_t->type~pf_sweeper_t type~pf_encap_t pf_encap_t type~pf_imexq_t->type~pf_encap_t rhs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq QtilE QtilI dtsdc QdiffE QdiffI explicit implicit rhs Type-Bound Procedures f_eval f_comp sweep initialize evaluate integrate residual spreadq0 evaluate_all destroy imexQ_destroy Source Code pf_imexQ_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QtilE (:,:) Approximate explicit quadrature rule real(kind=pfdp), public, allocatable :: QtilI (:,:) Approximate implicit quadrature rule real(kind=pfdp), public, allocatable :: dtsdc (:) SDC step sizes real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public, allocatable :: QdiffI (:,:) qmat-QtilI logical, public :: explicit = .true. True if there is an explicit piece logical, public :: implicit = .true. True if there an implicit piece class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval RHS function evaluations subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Prototype This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate procedure( pf_f_comp_p ), public, deferred :: f_comp Implicit solver subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Prototype Solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate procedure, public :: sweep => imexQ_sweep Set the generic functions public subroutine imexQ_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform nsweep SDC sweeps on level level_index and set qend appropriately.\n  Assign level pointer Read more… Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: initialize => imexQ_initialize public subroutine imexQ_initialize (this, lev) Subroutine to initialize matrices and space for sweeper\n  Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level procedure, public :: evaluate => imexQ_evaluate public subroutine imexQ_evaluate (this, lev, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => imexQ_integrate public subroutine imexQ_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Subroutine to compute  Picard integral of function values Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags procedure, public :: residual => imexQ_residual public subroutine imexQ_residual (this, lev, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags procedure, public :: spreadq0 => imexQ_spreadq0 public subroutine imexQ_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => imexQ_evaluate_all public subroutine imexQ_evaluate_all (this, lev, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => imexQ_destroy public subroutine imexQ_destroy (this, lev) Subroutine to deallocate sweeper Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level procedure, public :: imexQ_destroy public subroutine imexQ_destroy (this, lev) Subroutine to deallocate sweeper Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level Source Code type , extends ( pf_sweeper_t ), abstract :: pf_imexQ_t real ( pfdp ), allocatable :: QtilE (:,:) !!  Approximate explicit quadrature rule real ( pfdp ), allocatable :: QtilI (:,:) !!  Approximate implicit quadrature rule real ( pfdp ), allocatable :: dtsdc (:) !!  SDC step sizes real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ), allocatable :: QdiffI (:,:) !!  qmat-QtilI logical :: explicit = . true . !!  True if there is an explicit piece logical :: implicit = . true . !!  True if there an implicit piece class ( pf_encap_t ), allocatable :: rhs !! holds rhs for implicit solve contains procedure ( pf_f_eval_p ), deferred :: f_eval !!  RHS function evaluations procedure ( pf_f_comp_p ), deferred :: f_comp !!  Implicit solver !>  Set the generic functions procedure :: sweep => imexQ_sweep procedure :: initialize => imexQ_initialize procedure :: evaluate => imexQ_evaluate procedure :: integrate => imexQ_integrate procedure :: residual => imexQ_residual procedure :: spreadq0 => imexQ_spreadq0 procedure :: evaluate_all => imexQ_evaluate_all procedure :: destroy => imexQ_destroy procedure :: imexQ_destroy end type pf_imexQ_t","tags":"","loc":"type/pf_imexq_t.html","title":"pf_imexQ_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_exp_t Inherits type~~pf_exp_t~2~~InheritsGraph type~pf_exp_t~2 pf_exp_t type~pf_sweeper_t pf_sweeper_t type~pf_exp_t~2->type~pf_sweeper_t type~pf_encap_t pf_encap_t type~pf_exp_t~2->type~pf_encap_t b, f_old, newF Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq w nodes eta b f_old newF use_phib Type-Bound Procedures f_eval phib swpPhib resPhib initialize sweep evaluate integrate residual spreadq0 evaluate_all destroy exp_destroy exp_initialize Source Code pf_exp_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: w (:,:,:) real(kind=pfdp), public, allocatable :: nodes (:) real(kind=pfdp), public, allocatable :: eta (:) class( pf_encap_t ), public, allocatable :: b (:) class( pf_encap_t ), public, allocatable :: f_old (:) class( pf_encap_t ), public, allocatable :: newF logical, public :: use_phib = .TRUE. Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level, n) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: n procedure( pf_phib ), public, deferred :: phib subroutine pf_phib(this, t, h, b, y) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y procedure( pf_swpPhib ), public, deferred :: swpPhib subroutine pf_swpPhib(this, j, h, b, y) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y procedure( pf_resPhib ), public, deferred :: resPhib subroutine pf_resPhib(this, j, h, b, y) Prototype Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y procedure, public :: initialize => exp_initialize public subroutine exp_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: sweep => exp_sweep public subroutine exp_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: evaluate => exp_evaluate public subroutine exp_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => exp_integrate public subroutine exp_integrate (this, lev, qSDC, fSDC, dt, fintsdc, flags) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintsdc (:) Integral from t_n to t_m integer, intent(in), optional :: flags procedure, public :: residual => exp_residual public subroutine exp_residual (this, lev, dt, flags) Compute the integral of F from t_n to t_m at each node Read more… Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags procedure, public :: spreadq0 => exp_spreadq0 public subroutine exp_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => exp_evaluate_all public subroutine exp_evaluate_all (this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => exp_destroy public subroutine exp_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level procedure, public :: exp_destroy public subroutine exp_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level procedure, public :: exp_initialize public subroutine exp_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_exp_t real ( pfdp ), allocatable :: w (:,:,:) ! weights real ( pfdp ), allocatable :: nodes (:) ! nodes real ( pfdp ), allocatable :: eta (:) ! normalized substeps (on interval [0, 1]) class ( pf_encap_t ), allocatable :: b (:) ! scratch space for computing nonlinear derivatives class ( pf_encap_t ), allocatable :: f_old (:) ! scratch space for storing nonlinear terms class ( pf_encap_t ), allocatable :: newF ! scratch space for storing new function evaluations LOGICAL :: use_phib = . TRUE . ! if TRUE calls phib otherwise calls swpPhib and resPhib contains ! specialized procedures for exponential integrator procedure ( pf_f_eval_p ), deferred :: f_eval ! computes nonlinear term in equation procedure ( pf_phib ), deferred :: phib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i procedure ( pf_swpPhib ), deferred :: swpPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n,j} for j = 1, ... q - 1 procedure ( pf_resPhib ), deferred :: resPhib ! computes x(t) = \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i where t = t_{n,j+1} - t_{n} for j = 1, ... q - 1 procedure , private :: weights procedure , private :: LocalDerivsAtNode ! generic functions procedure :: initialize => exp_initialize procedure :: sweep => exp_sweep procedure :: evaluate => exp_evaluate procedure :: integrate => exp_integrate procedure :: residual => exp_residual procedure :: spreadq0 => exp_spreadq0 procedure :: evaluate_all => exp_evaluate_all procedure :: destroy => exp_destroy ! functions that can be accessed directly by types that inherit pf_exp_t procedure :: exp_destroy procedure :: exp_initialize end type pf_exp_t","tags":"","loc":"type/pf_exp_t~2.html","title":"pf_exp_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_amisdc_t ) :: pf_amisdcQ_t Asynchronous multi-implicit sweeper type Inherits type~~pf_amisdcq_t~~InheritsGraph type~pf_amisdcq_t pf_amisdcQ_t type~pf_amisdc_t pf_amisdc_t type~pf_amisdcq_t->type~pf_amisdc_t type~pf_sweeper_t pf_sweeper_t type~pf_amisdc_t->type~pf_sweeper_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq SdiffE SdiffI QdiffE QdiffI QtilE QtilI use_LUq_ Type-Bound Procedures spreadq0 f1eval f2eval f2comp f3eval f3comp evaluate residual evaluate_all amisdc_destroy sweep initialize integrate destroy sweep_coupled_implicit_terms sweep_decoupled_implicit_terms amisdcQ_destroy Source Code pf_amisdcQ_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) logical, public :: use_LUq_ = .true. Type-Bound Procedures procedure( pf_spreadq0_p ), public, deferred :: spreadq0 subroutine pf_spreadq0_p(this, Lev, t0, flags, step) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_f1eval_p ), public, deferred :: f1eval subroutine pf_f1eval_p(this, y, t, level, f1) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f1 procedure( pf_f2eval_p ), public, deferred :: f2eval subroutine pf_f2eval_p(this, y, t, level, f2) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 procedure( pf_f2comp_p ), public, deferred :: f2comp subroutine pf_f2comp_p(this, y, t, dt, rhs, level, f2) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 procedure( pf_f3eval_p ), public, deferred :: f3eval subroutine pf_f3eval_p(this, y, t, level, f3) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 procedure( pf_f3comp_p ), public, deferred :: f3comp subroutine pf_f3comp_p(this, y, t, dt, rhs, level, f3) Prototype Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 procedure, public :: evaluate => amisdc_evaluate public subroutine amisdc_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m procedure, public :: residual => amisdc_residual public subroutine amisdc_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt procedure, public :: evaluate_all => amisdc_evaluate_all public subroutine amisdc_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) procedure, public :: amisdc_destroy public subroutine amisdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: sweep => amisdcQ_sweep public subroutine amisdcQ_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: initialize => amisdcQ_initialize public subroutine amisdcQ_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev procedure, public :: integrate => amisdcQ_integrate public subroutine amisdcQ_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(in) :: lev class(pf_encap_t), intent(in) :: qSDC (:) class(pf_encap_t), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class(pf_encap_t), intent(inout) :: fintSDC (:) procedure, public :: destroy => amisdcQ_destroy public subroutine amisdcQ_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev procedure, public :: sweep_coupled_implicit_terms public subroutine sweep_coupled_implicit_terms (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: sweep_decoupled_implicit_terms public subroutine sweep_decoupled_implicit_terms (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt procedure, public :: amisdcQ_destroy public subroutine amisdcQ_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev Source Code type , extends ( pf_amisdc_t ), abstract :: pf_amisdcQ_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) logical :: use_LUq_ = . true . contains procedure :: sweep => amisdcQ_sweep procedure :: initialize => amisdcQ_initialize procedure :: integrate => amisdcQ_integrate procedure :: destroy => amisdcQ_destroy procedure :: sweep_coupled_implicit_terms procedure :: sweep_decoupled_implicit_terms procedure :: amisdcQ_destroy end type pf_amisdcQ_t","tags":"","loc":"type/pf_amisdcq_t.html","title":"pf_amisdcQ_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_imk_t Implicit Munthe-Kaas Runge-Kutta sweeper type, extends abstract sweeper Inherits type~~pf_imk_t~~InheritsGraph type~pf_imk_t pf_imk_t type~pf_sweeper_t pf_sweeper_t type~pf_imk_t->type~pf_sweeper_t type~pf_encap_t pf_encap_t type~pf_imk_t->type~pf_encap_t A Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq A QtilE dtsdc tsdc QdiffE bernoullis t0 dt qtype nterms Lax_pair use_SDC debug mkrk rk Type-Bound Procedures destroy sweep initialize evaluate integrate residual spreadq0 evaluate_all imk_destroy f_eval dexpinv propagate commutator_p Source Code pf_imk_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq class( pf_encap_t ), public, allocatable :: A (:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: dtsdc (:) real(kind=pfdp), public, allocatable :: tsdc (:) real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public :: bernoullis (20) real(kind=pfdp), public :: t0 real(kind=pfdp), public :: dt integer, public :: qtype integer, public :: nterms logical, public :: Lax_pair logical, public :: use_SDC logical, public :: debug logical, public :: mkrk logical, public :: rk Type-Bound Procedures procedure( pf_destroy_p ), public, deferred :: destroy subroutine pf_destroy_p(this, Lev) Prototype Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev procedure, public :: sweep => imk_sweep public subroutine imk_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform nsweep  sweeps on level  and set qend appropriately. Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags procedure, public :: initialize => imk_initialize public subroutine imk_initialize (this, lev) Assign explicit approximate quadrature rule\n  Make space for temporary variables Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: evaluate => imk_evaluate public subroutine imk_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => imk_integrate public subroutine imk_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure, public :: residual => imk_residual public subroutine imk_residual (this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags procedure, public :: spreadq0 => imk_spreadq0 public subroutine imk_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => imk_evaluate_all public subroutine imk_evaluate_all (this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: imk_destroy public subroutine imk_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level, f) Prototype Subroutine f_eval computes A(y,t) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer(kind=c_int), intent(in) :: level class( pf_encap_t ), intent(inout) :: f procedure( pf_dexpinv_p ), public, deferred :: dexpinv subroutine pf_dexpinv_p(this, a, omega, f) Prototype Subroutine dexpinv computes Om'=F=dexpinv_Om(A) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: f The resultign-level procedure( pf_propagate_p ), public, deferred :: propagate subroutine pf_propagate_p(this, q0, q) Prototype Subroutine propagate   computes y_m=expm(Om_m)y_0(expm(Om_m))-1 or (expm(Om_m))y_0 or Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: q0 class( pf_encap_t ), intent(inout) :: q procedure( pf_commutator_p ), public, deferred :: commutator_p subroutine pf_commutator_p(this, a, b, out, flags) Prototype Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: b class( pf_encap_t ), intent(inout) :: out integer, intent(in), optional :: flags Source Code type , extends ( pf_sweeper_t ), abstract :: pf_imk_t class ( pf_encap_t ), allocatable :: A (:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: dtsdc (:) real ( pfdp ), allocatable :: tsdc (:) real ( pfdp ), allocatable :: QdiffE (:,:) !!  qmat-QtilE real ( pfdp ) :: bernoullis ( 20 ), t0 , dt integer :: qtype , nterms logical :: Lax_pair , use_SDC , debug , mkrk , rk contains procedure :: sweep => imk_sweep procedure :: initialize => imk_initialize procedure :: evaluate => imk_evaluate procedure :: integrate => imk_integrate procedure :: residual => imk_residual procedure :: spreadq0 => imk_spreadq0 procedure :: evaluate_all => imk_evaluate_all procedure :: imk_destroy procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_dexpinv_p ), deferred :: dexpinv procedure ( pf_propagate_p ), deferred :: propagate procedure ( pf_commutator_p ), deferred :: commutator_p end type pf_imk_t","tags":"","loc":"type/pf_imk_t.html","title":"pf_imk_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_magpicard_t Magnus Picard sweeper type, extends abstract sweeper Inherits type~~pf_magpicard_t~~InheritsGraph type~pf_magpicard_t pf_magpicard_t type~pf_sweeper_t pf_sweeper_t type~pf_magpicard_t->type~pf_sweeper_t type~pf_encap_t pf_encap_t type~pf_magpicard_t->type~pf_encap_t omega, time_ev_op Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq dtsdc magnus_order qtype dt commutator_coefs commutators omega time_ev_op Type-Bound Procedures sweep initialize evaluate integrate residual spreadq0 evaluate_all f_eval compute_single_commutators compute_omega propagate_solution destroy magpicard_destroy Source Code pf_magpicard_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: dtsdc (:) integer, public :: magnus_order integer, public :: qtype real(kind=pfdp), public :: dt real(kind=pfdp), public :: commutator_coefs (9,3,4) complex(kind=pfdp), public, allocatable :: commutators (:,:,:) class( pf_encap_t ), public, allocatable :: omega (:) class( pf_encap_t ), public, allocatable :: time_ev_op (:) Type-Bound Procedures procedure, public :: sweep => magpicard_sweep public subroutine magpicard_sweep (this, pf, level_index, t0, dt, nsweeps, flags) this loop not OMP'd because the deferred procs are OMP'd Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags procedure, public :: initialize => magpicard_initialize public subroutine magpicard_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: evaluate => magpicard_evaluate public subroutine magpicard_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: integrate => magpicard_integrate public subroutine magpicard_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Compute SDC integral\n  fintSDC = \\int_{t_n}&#94;{t_m} fSDC dt Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure, public :: residual => magpicard_residual public subroutine magpicard_residual (this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags procedure, public :: spreadq0 => magpicard_spreadq0 public subroutine magpicard_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => magpicard_evaluate_all public subroutine magpicard_evaluate_all (this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level, f) Prototype Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f procedure( pf_compute_single_commutators_p ), public, deferred :: compute_single_commutators subroutine pf_compute_single_commutators_p(this, f) Prototype Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: f (:,:) procedure( pf_compute_omega_p ), public, deferred :: compute_omega subroutine pf_compute_omega_p(this, omega, integrals, f, nodes, qmat, dt, this_node, coefs) Prototype Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: integrals (:) class( pf_encap_t ), intent(inout) :: f (:,:) real(kind=pfdp), intent(in) :: nodes (:) real(kind=pfdp), intent(in) :: qmat (:,:) real(kind=pfdp), intent(in) :: dt integer, intent(in) :: this_node real(kind=pfdp), intent(in) :: coefs (:,:) procedure( pf_propagate_solution_p ), public, deferred :: propagate_solution subroutine pf_propagate_solution_p(this, sol_t0, sol_tn, omega, level) Prototype Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: sol_t0 class( pf_encap_t ), intent(inout) :: sol_tn class( pf_encap_t ), intent(inout) :: omega integer, intent(in) :: level procedure( pf_destroy_magpicard_p ), public, deferred :: destroy subroutine pf_destroy_magpicard_p(this, Lev) Prototype Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev procedure, public :: magpicard_destroy public subroutine magpicard_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_magpicard_t real ( pfdp ), allocatable :: dtsdc (:) integer :: magnus_order , qtype real ( pfdp ) :: dt , commutator_coefs ( 9 , 3 , 4 ) complex ( pfdp ), allocatable :: commutators (:,:,:) class ( pf_encap_t ), allocatable :: omega (:), time_ev_op (:) contains procedure :: sweep => magpicard_sweep procedure :: initialize => magpicard_initialize procedure :: evaluate => magpicard_evaluate procedure :: integrate => magpicard_integrate procedure :: residual => magpicard_residual procedure :: spreadq0 => magpicard_spreadq0 procedure :: evaluate_all => magpicard_evaluate_all procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_compute_single_commutators_p ), deferred :: compute_single_commutators procedure ( pf_compute_omega_p ), deferred :: compute_omega procedure ( pf_propagate_solution_p ), deferred :: propagate_solution procedure ( pf_destroy_magpicard_p ), deferred :: destroy procedure :: magpicard_destroy end type pf_magpicard_t","tags":"","loc":"type/pf_magpicard_t.html","title":"pf_magpicard_t – LibPFASST "},{"text":"type, public, abstract, extends( pf_sweeper_t ) :: pf_misdcQ_oc_t Multi-implicit SDC sweeper type for optimal control, extends abstract sweeper Inherits type~~pf_misdcq_oc_t~~InheritsGraph type~pf_misdcq_oc_t pf_misdcQ_oc_t type~pf_sweeper_t pf_sweeper_t type~pf_misdcq_oc_t->type~pf_sweeper_t type~pf_encap_t pf_encap_t type~pf_misdcq_oc_t->type~pf_encap_t I3, rhs Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables npieces use_LUq QdiffE QdiffI QtilE QtilI dtsdc I3 rhs Type-Bound Procedures f_eval f_comp sweep initialize integrate residual spreadq0 evaluate_all evaluate destroy misdcQ_oc_destroy Source Code pf_misdcQ_oc_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) real(kind=pfdp), public, allocatable :: dtsdc (:) class( pf_encap_t ), public, allocatable :: I3 (:) class( pf_encap_t ), public, allocatable :: rhs Type-Bound Procedures procedure( pf_f_eval_p ), public, deferred :: f_eval subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) Prototype This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two\n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward integer, intent(in), optional :: idx index of quadrature node integer, intent(in), optional :: step time step for sequential version procedure( pf_f_comp_p ), public, deferred :: f_comp subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Prototype Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward procedure, public :: sweep => misdcQ_oc_sweep public subroutine misdcQ_oc_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags procedure, public :: initialize => misdcQ_oc_initialize public subroutine misdcQ_oc_initialize (this, lev) Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: integrate => misdcQ_oc_integrate public subroutine misdcQ_oc_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags procedure, public :: residual => misdcQ_oc_residual public subroutine misdcQ_oc_residual (this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags procedure, public :: spreadq0 => misdcQ_oc_spreadq0 public subroutine misdcQ_oc_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate_all => misdcQ_oc_evaluate_all public subroutine misdcQ_oc_evaluate_all (this, lev, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: evaluate => misdcQ_oc_evaluate public subroutine misdcQ_oc_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step procedure, public :: destroy => misdcQ_oc_destroy public subroutine misdcQ_oc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev procedure, public :: misdcQ_oc_destroy public subroutine misdcQ_oc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Source Code type , extends ( pf_sweeper_t ), abstract :: pf_misdcQ_oc_t real ( pfdp ), allocatable :: QdiffE (:,:) real ( pfdp ), allocatable :: QdiffI (:,:) real ( pfdp ), allocatable :: QtilE (:,:) real ( pfdp ), allocatable :: QtilI (:,:) real ( pfdp ), allocatable :: dtsdc (:) class ( pf_encap_t ), allocatable :: I3 (:) class ( pf_encap_t ), allocatable :: rhs contains procedure ( pf_f_eval_p ), deferred :: f_eval procedure ( pf_f_comp_p ), deferred :: f_comp procedure :: sweep => misdcQ_oc_sweep procedure :: initialize => misdcQ_oc_initialize procedure :: integrate => misdcQ_oc_integrate procedure :: residual => misdcQ_oc_residual procedure :: spreadq0 => misdcQ_oc_spreadq0 procedure :: evaluate_all => misdcQ_oc_evaluate_all procedure :: evaluate => misdcQ_oc_evaluate procedure :: destroy => misdcQ_oc_destroy procedure :: misdcQ_oc_destroy end type pf_misdcQ_oc_t","tags":"","loc":"type/pf_misdcq_oc_t.html","title":"pf_misdcQ_oc_t – LibPFASST "},{"text":"subroutine CFFTB1(N, C, CH, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: CH real :: WA integer :: IFAC Contents None","tags":"","loc":"proc/cfftb1.html","title":"CFFTB1 – LibPFASST"},{"text":"subroutine CFFTF1(N, C, CH, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: CH real :: WA integer :: IFAC Contents None","tags":"","loc":"proc/cfftf1.html","title":"CFFTF1 – LibPFASST"},{"text":"subroutine CFFTI1(N, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: WA integer :: IFAC Calls proc~~cffti1~~CallsGraph proc~cffti1 CFFTI1 float float proc~cffti1->float ntryh ntryh proc~cffti1->ntryh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cffti1.html","title":"CFFTI1 – LibPFASST"},{"text":"subroutine PASSB2(IDO, L1, CC, CH, WA1) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 Contents None","tags":"","loc":"proc/passb2.html","title":"PASSB2 – LibPFASST"},{"text":"subroutine PASSB3(IDO, L1, CC, CH, WA1, WA2) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 Contents None","tags":"","loc":"proc/passb3.html","title":"PASSB3 – LibPFASST"},{"text":"subroutine PASSB4(IDO, L1, CC, CH, WA1, WA2, WA3) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 Contents None","tags":"","loc":"proc/passb4.html","title":"PASSB4 – LibPFASST"},{"text":"subroutine PASSB5(IDO, L1, CC, CH, WA1, WA2, WA3, WA4) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 real :: WA4 Contents None","tags":"","loc":"proc/passb5.html","title":"PASSB5 – LibPFASST"},{"text":"subroutine PASSB(NAC, IDO, IP, L1, IDL1, CC, C1, C2, CH, CH2, WA) Arguments Type Intent Optional Attributes Name integer :: NAC integer :: IDO integer :: IP integer :: L1 integer :: IDL1 real :: CC real :: C1 real :: C2 real :: CH real :: CH2 real :: WA Contents None","tags":"","loc":"proc/passb.html","title":"PASSB – LibPFASST"},{"text":"subroutine PASSF2(IDO, L1, CC, CH, WA1) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 Contents None","tags":"","loc":"proc/passf2.html","title":"PASSF2 – LibPFASST"},{"text":"subroutine PASSF3(IDO, L1, CC, CH, WA1, WA2) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 Contents None","tags":"","loc":"proc/passf3.html","title":"PASSF3 – LibPFASST"},{"text":"subroutine PASSF4(IDO, L1, CC, CH, WA1, WA2, WA3) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 Contents None","tags":"","loc":"proc/passf4.html","title":"PASSF4 – LibPFASST"},{"text":"subroutine PASSF5(IDO, L1, CC, CH, WA1, WA2, WA3, WA4) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 real :: WA4 Contents None","tags":"","loc":"proc/passf5.html","title":"PASSF5 – LibPFASST"},{"text":"subroutine PASSF(NAC, IDO, IP, L1, IDL1, CC, C1, C2, CH, CH2, WA) Arguments Type Intent Optional Attributes Name integer :: NAC integer :: IDO integer :: IP integer :: L1 integer :: IDL1 real :: CC real :: C1 real :: C2 real :: CH real :: CH2 real :: WA Contents None","tags":"","loc":"proc/passf.html","title":"PASSF – LibPFASST"},{"text":"subroutine RADB2(IDO, L1, CC, CH, WA1) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 Contents None","tags":"","loc":"proc/radb2.html","title":"RADB2 – LibPFASST"},{"text":"subroutine RADB3(IDO, L1, CC, CH, WA1, WA2) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 Contents None","tags":"","loc":"proc/radb3.html","title":"RADB3 – LibPFASST"},{"text":"subroutine RADB4(IDO, L1, CC, CH, WA1, WA2, WA3) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 Contents None","tags":"","loc":"proc/radb4.html","title":"RADB4 – LibPFASST"},{"text":"subroutine RADB5(IDO, L1, CC, CH, WA1, WA2, WA3, WA4) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 real :: WA4 Contents None","tags":"","loc":"proc/radb5.html","title":"RADB5 – LibPFASST"},{"text":"subroutine RADBG(IDO, IP, L1, IDL1, CC, C1, C2, CH, CH2, WA) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: IP integer :: L1 integer :: IDL1 real :: CC real :: C1 real :: C2 real :: CH real :: CH2 real :: WA Calls proc~~radbg~~CallsGraph proc~radbg RADBG float float proc~radbg->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/radbg.html","title":"RADBG – LibPFASST"},{"text":"subroutine RADF2(IDO, L1, CC, CH, WA1) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 Contents None","tags":"","loc":"proc/radf2.html","title":"RADF2 – LibPFASST"},{"text":"subroutine RADF3(IDO, L1, CC, CH, WA1, WA2) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 Contents None","tags":"","loc":"proc/radf3.html","title":"RADF3 – LibPFASST"},{"text":"subroutine RADF4(IDO, L1, CC, CH, WA1, WA2, WA3) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 Contents None","tags":"","loc":"proc/radf4.html","title":"RADF4 – LibPFASST"},{"text":"subroutine RADF5(IDO, L1, CC, CH, WA1, WA2, WA3, WA4) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: L1 real :: CC real :: CH real :: WA1 real :: WA2 real :: WA3 real :: WA4 Contents None","tags":"","loc":"proc/radf5.html","title":"RADF5 – LibPFASST"},{"text":"subroutine RADFG(IDO, IP, L1, IDL1, CC, C1, C2, CH, CH2, WA) Arguments Type Intent Optional Attributes Name integer :: IDO integer :: IP integer :: L1 integer :: IDL1 real :: CC real :: C1 real :: C2 real :: CH real :: CH2 real :: WA Calls proc~~radfg~~CallsGraph proc~radfg RADFG float float proc~radfg->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/radfg.html","title":"RADFG – LibPFASST"},{"text":"subroutine RFFTB1(N, C, CH, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: CH real :: WA integer :: IFAC Contents None","tags":"","loc":"proc/rfftb1.html","title":"RFFTB1 – LibPFASST"},{"text":"subroutine RFFTF1(N, C, CH, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: CH real :: WA integer :: IFAC Contents None","tags":"","loc":"proc/rfftf1.html","title":"RFFTF1 – LibPFASST"},{"text":"subroutine RFFTI1(N, WA, IFAC) Arguments Type Intent Optional Attributes Name integer :: N real :: WA integer :: IFAC Calls proc~~rffti1~~CallsGraph proc~rffti1 RFFTI1 float float proc~rffti1->float ntryh ntryh proc~rffti1->ntryh Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rffti1.html","title":"RFFTI1 – LibPFASST"},{"text":"subroutine ZFFTB(N, C, WSAVE) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: WSAVE Called by proc~~zfftb~~CalledByGraph proc~zfftb ZFFTB proc~fftb~2 fftb proc~fftb~2->proc~zfftb proc~conv_3d~2 conv_3d proc~conv_3d~2->proc~fftb~2 proc~conv_2d~2 conv_2d proc~conv_2d~2->proc~fftb~2 proc~conv_1d~2 conv_1d proc~conv_1d~2->proc~fftb~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/zfftb.html","title":"ZFFTB – LibPFASST"},{"text":"subroutine ZFFTF(N, C, WSAVE) Arguments Type Intent Optional Attributes Name integer :: N real :: C real :: WSAVE Called by proc~~zfftf~~CalledByGraph proc~zfftf ZFFTF proc~fftf~2 fftf proc~fftf~2->proc~zfftf proc~conv_3d~2 conv_3d proc~conv_3d~2->proc~fftf~2 proc~conv_2d~2 conv_2d proc~conv_2d~2->proc~fftf~2 proc~conv_1d~2 conv_1d proc~conv_1d~2->proc~fftf~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/zfftf.html","title":"ZFFTF – LibPFASST"},{"text":"subroutine ZFFTI(N, WSAVE) Arguments Type Intent Optional Attributes Name integer :: N real :: WSAVE Called by proc~~zffti~~CalledByGraph proc~zffti ZFFTI proc~fft_setup~2 fft_setup proc~fft_setup~2->proc~zffti Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/zffti.html","title":"ZFFTI – LibPFASST"},{"text":"public subroutine restrict_time_space_fas(pf, t0, dt, level_index, flags, mystep) Restrict (in time and space) fine level to coarse and set coarse level FAS correction. The coarse function values are re-evaluated after restriction.\n Note that even if the number of variables and nodes is the same,\n we should still compute the FAS correction since the function\n evaluations may be different.\n create workspaces\n restrict q's and recompute f's\n  Recompute the functions Compute  FAS correction\n  Clean up Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf real(kind=pfdp), intent(in) :: t0 time at beginning of step real(kind=pfdp), intent(in) :: dt time step integer, intent(in) :: level_index defines which level to restrict integer, intent(in), optional :: flags integer, intent(in), optional :: mystep Calls proc~~restrict_time_space_fas~~CallsGraph proc~restrict_time_space_fas restrict_time_space_fas proc~call_hooks call_hooks proc~restrict_time_space_fas->proc~call_hooks proc~restrict_sdc restrict_sdc proc~restrict_time_space_fas->proc~restrict_sdc proc~start_timer start_timer proc~restrict_time_space_fas->proc~start_timer proc~end_timer end_timer proc~restrict_time_space_fas->proc~end_timer proc~call_hooks->proc~start_timer proc~call_hooks->proc~end_timer proc~pf_apply_mat pf_apply_mat proc~restrict_sdc->proc~pf_apply_mat mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~restrict_time_space_fas~~CalledByGraph proc~restrict_time_space_fas restrict_time_space_fas proc~pf_predictor_oc pf_predictor_oc proc~pf_predictor_oc->proc~restrict_time_space_fas proc~pf_v_cycle pf_v_cycle proc~pf_v_cycle->proc~restrict_time_space_fas proc~pf_predictor pf_predictor proc~pf_predictor->proc~restrict_time_space_fas proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_v_cycle_oc->proc~restrict_time_space_fas proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_v_cycle proc~pf_block_run->proc~pf_predictor proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code restrict_time_space_fas Source Code subroutine restrict_time_space_fas ( pf , t0 , dt , level_index , flags , mystep ) !! Restrict (in time and space) fine level to coarse and set coarse level FAS correction. !! !! The coarse function values are re-evaluated after restriction. !! Note that even if the number of variables and nodes is the same, !! we should still compute the FAS correction since the function !! evaluations may be different. type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 !!  time at beginning of step real ( pfdp ), intent ( in ) :: dt !!  time step integer , intent ( in ) :: level_index !! defines which level to restrict integer , optional , intent ( in ) :: flags , mystep !>  Local variables class ( pf_level_t ), pointer :: c_lev_ptr class ( pf_level_t ), pointer :: f_lev_ptr integer :: m , step real ( pfdp ), allocatable :: c_times (:) !!  Simulation time at coarse nodes real ( pfdp ), allocatable :: f_times (:) !!  Simulation time at fine nodes class ( pf_encap_t ), allocatable :: & c_tmp_array (:), & ! coarse integral of coarse function values f_int_array (:), & ! fine integral of fine function values f_int_arrayr (:) ! coarse integral of restricted fine function values f_lev_ptr => pf % levels ( level_index ); c_lev_ptr => pf % levels ( level_index - 1 ) step = pf % state % step + 1 if ( present ( mystep )) step = mystep call call_hooks ( pf , level_index , PF_PRE_RESTRICT_ALL ) call start_timer ( pf , TRESTRICT + level_index - 1 ) !> create workspaces call c_lev_ptr % ulevel % factory % create_array ( c_tmp_array , c_lev_ptr % nnodes , & c_lev_ptr % index , c_lev_ptr % shape ) call c_lev_ptr % ulevel % factory % create_array ( f_int_arrayr , c_lev_ptr % nnodes , & c_lev_ptr % index , c_lev_ptr % shape ) call c_lev_ptr % ulevel % factory % create_array ( f_int_array , f_lev_ptr % nnodes , & f_lev_ptr % index , f_lev_ptr % shape ) allocate ( c_times ( c_lev_ptr % nnodes )) allocate ( f_times ( f_lev_ptr % nnodes )) !> restrict q's and recompute f's c_times = t0 + dt * c_lev_ptr % nodes f_times = t0 + dt * f_lev_ptr % nodes call restrict_sdc ( f_lev_ptr , c_lev_ptr , f_lev_ptr % Q , c_lev_ptr % Q , . false ., f_times , flags ) !>  Recompute the functions call c_lev_ptr % ulevel % sweeper % evaluate_all ( c_lev_ptr , c_times , flags = flags , step = step ) !>  Compute  FAS correction do m = 1 , c_lev_ptr % nnodes - 1 call c_lev_ptr % tauQ ( m )% setval ( 0.0_pfdp , flags ) end do if ( pf % state % iter >= pf % taui0 ) then ! compute '0 to node' integral on the coarse level call c_lev_ptr % ulevel % sweeper % integrate ( c_lev_ptr , c_lev_ptr % Q , & c_lev_ptr % F , dt , c_tmp_array , flags ) ! compute '0 to node' integral on the fine level call f_lev_ptr % ulevel % sweeper % integrate ( f_lev_ptr , f_lev_ptr % Q , & f_lev_ptr % F , dt , f_lev_ptr % I , flags ) !  put tau in on fine level if ( allocated ( f_lev_ptr % tauQ )) then do m = 1 , f_lev_ptr % nnodes - 1 call f_lev_ptr % I ( m )% axpy ( 1.0_pfdp , f_lev_ptr % tauQ ( m ), flags ) end do end if ! restrict '0 to node' integral on the fine level  in time and space call restrict_sdc ( f_lev_ptr , c_lev_ptr , f_lev_ptr % I , f_int_arrayr , . true ., f_times , flags ) ! compute '0 to node' tau correction do m = 1 , c_lev_ptr % nnodes - 1 call c_lev_ptr % tauQ ( m )% axpy ( 1.0_pfdp , f_int_arrayr ( m ), flags ) call c_lev_ptr % tauQ ( m )% axpy ( - 1.0_pfdp , c_tmp_array ( m ), flags ) end do end if call end_timer ( pf , TRESTRICT + level_index - 1 ) call call_hooks ( pf , level_index , PF_POST_RESTRICT_ALL ) !>  Clean up call c_lev_ptr % ulevel % factory % destroy_array ( c_tmp_array , c_lev_ptr % nnodes , & c_lev_ptr % index , c_lev_ptr % shape ) call c_lev_ptr % ulevel % factory % destroy_array ( f_int_arrayr , c_lev_ptr % nnodes , & c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % destroy_array ( f_int_array , f_lev_ptr % nnodes , & f_lev_ptr % index , f_lev_ptr % shape ) deallocate ( c_times ) deallocate ( f_times ) end subroutine restrict_time_space_fas","tags":"","loc":"proc/restrict_time_space_fas.html","title":"restrict_time_space_fas – LibPFASST"},{"text":"public subroutine restrict_sdc(f_lev_ptr, c_lev_ptr, f_encap_array, c_encap_array, IS_INTEGRAL, f_time, flags) Restrict (in time and space) f_sol_array  to c_sol_array\n Depending on the flag INTEGRAL, we may be restricting solutions, or integrals of F do the restriction Arguments Type Intent Optional Attributes Name class( pf_level_t ), intent(inout) :: f_lev_ptr pointer to fine level class( pf_level_t ), intent(inout) :: c_lev_ptr pointer to coarse level class( pf_encap_t ), intent(inout) :: f_encap_array (:) array of fine level data to be restricted class( pf_encap_t ), intent(inout) :: c_encap_array (:) array of coarse level data to be computed logical, intent(in) :: IS_INTEGRAL flag determines if it is integral data being restricted real(kind=pfdp), intent(in) :: f_time (:) time at the fine nodes integer, intent(in), optional :: flags Calls proc~~restrict_sdc~~CallsGraph proc~restrict_sdc restrict_sdc proc~pf_apply_mat pf_apply_mat proc~restrict_sdc->proc~pf_apply_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~restrict_sdc~~CalledByGraph proc~restrict_sdc restrict_sdc proc~restrict_time_space_fas restrict_time_space_fas proc~restrict_time_space_fas->proc~restrict_sdc proc~pf_predictor_oc pf_predictor_oc proc~pf_predictor_oc->proc~restrict_time_space_fas proc~pf_v_cycle pf_v_cycle proc~pf_v_cycle->proc~restrict_time_space_fas proc~pf_predictor pf_predictor proc~pf_predictor->proc~restrict_time_space_fas proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_v_cycle_oc->proc~restrict_time_space_fas proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_v_cycle proc~pf_block_run->proc~pf_predictor proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code restrict_sdc Source Code subroutine restrict_sdc ( f_lev_ptr , c_lev_ptr , f_encap_array , c_encap_array , IS_INTEGRAL , f_time , flags ) !! Restrict (in time and space) f_sol_array  to c_sol_array !! Depending on the flag INTEGRAL, we may be restricting solutions, or integrals of F class ( pf_level_t ), intent ( inout ) :: f_lev_ptr !!   pointer to fine level class ( pf_level_t ), intent ( inout ) :: c_lev_ptr !!   pointer to coarse level class ( pf_encap_t ), intent ( inout ) :: f_encap_array (:) !! array of fine level data to be restricted class ( pf_encap_t ), intent ( inout ) :: c_encap_array (:) !! array of coarse level data to be computed logical , intent ( in ) :: IS_INTEGRAL !! flag determines if it is integral data being restricted real ( pfdp ), intent ( in ) :: f_time (:) !! time at the fine nodes integer , optional , intent ( in ) :: flags class ( pf_encap_t ), allocatable :: f_encap_array_c (:) !!  fine solution restricted in space only integer :: m , j integer :: f_nnodes , c_nnodes f_nnodes = f_lev_ptr % nnodes c_nnodes = c_lev_ptr % nnodes !!  do the restriction if ( IS_INTEGRAL ) then ! Restriction of integrals call c_lev_ptr % ulevel % factory % create_array ( f_encap_array_c , f_nnodes - 1 , c_lev_ptr % index , c_lev_ptr % shape ) !  spatial restriction do m = 1 , f_nnodes - 1 call f_lev_ptr % ulevel % restrict ( f_lev_ptr , c_lev_ptr , f_encap_array ( m ), f_encap_array_c ( m ), f_time ( m ), flags ) end do ! temporal restriction ! when restricting '0 to node' integral terms, skip the first entry since it is zero if ( present ( flags )) then if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) & call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat ( 2 :, 2 :), f_encap_array_c , . true ., flags = 1 ) if (( flags . eq . 0 ) . or . ( flags . eq . 2 )) & call pf_apply_mat_backward ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat ( 2 :, 2 :), f_encap_array_c , . true ., flags = 2 ) else call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat ( 2 :, 2 :), f_encap_array_c , . true .) end if call c_lev_ptr % ulevel % factory % destroy_array ( f_encap_array_c , f_nnodes - 1 , c_lev_ptr % index , c_lev_ptr % shape ) else call c_lev_ptr % ulevel % factory % create_array ( f_encap_array_c , f_nnodes , c_lev_ptr % index , c_lev_ptr % shape ) !  spatial restriction do m = 1 , f_nnodes call f_lev_ptr % ulevel % restrict ( f_lev_ptr , c_lev_ptr , f_encap_array ( m ), f_encap_array_c ( m ), f_time ( m ), flags ) end do ! temporal restriction if ( present ( flags )) then if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) & call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat , f_encap_array_c , . true ., flags ) if (( flags . eq . 0 ) . or . ( flags . eq . 2 )) & call pf_apply_mat_backward ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat , f_encap_array_c , . true ., flags = 2 ) else call pf_apply_mat ( c_encap_array , 1.0_pfdp , f_lev_ptr % rmat , f_encap_array_c , . true .) end if call c_lev_ptr % ulevel % factory % destroy_array ( f_encap_array_c , f_nnodes , c_lev_ptr % index , c_lev_ptr % shape ) end if end subroutine restrict_sdc","tags":"","loc":"proc/restrict_sdc.html","title":"restrict_sdc – LibPFASST"},{"text":"public subroutine pf_apply_mat(dst, a, mat, src, zero, flags) Apply a matrix (tmat or rmat) to src and add to dst.\n Mathematically this is \n     dst= dst + a mat src\n  Where dst and src are vectors, mat is a matrix, and a is a scalar\n  If the optional variable \"zero\" is provided and is true, then we compute\n     dst=  a mat src Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: dst (:) destination vector real(kind=pfdp), intent(in) :: a scalar real(kind=pfdp), intent(in) :: mat (:,:) matrix class( pf_encap_t ), intent(in) :: src (:) src vector logical, intent(in), optional :: zero If false, don't zero out the the dst variable before computing integer, intent(in), optional :: flags Used for choosing which variable to operate on Local variables Called by proc~~pf_apply_mat~~CalledByGraph proc~pf_apply_mat pf_apply_mat proc~restrict_sdc restrict_sdc proc~restrict_sdc->proc~pf_apply_mat proc~interpolate_time_space interpolate_time_space proc~interpolate_time_space->proc~pf_apply_mat proc~pf_predictor_oc pf_predictor_oc proc~pf_predictor_oc->proc~interpolate_time_space proc~restrict_time_space_fas restrict_time_space_fas proc~pf_predictor_oc->proc~restrict_time_space_fas proc~pf_v_cycle pf_v_cycle proc~pf_v_cycle->proc~interpolate_time_space proc~pf_v_cycle->proc~restrict_time_space_fas proc~pf_predictor pf_predictor proc~pf_predictor->proc~interpolate_time_space proc~pf_predictor->proc~restrict_time_space_fas proc~restrict_time_space_fas->proc~restrict_sdc proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_v_cycle_oc->proc~interpolate_time_space proc~pf_v_cycle_oc->proc~restrict_time_space_fas proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_v_cycle proc~pf_block_run->proc~pf_predictor proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run var panprocpf_apply_matCalledByGraph = svgPanZoom('#procpf_apply_matCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_apply_mat Source Code subroutine pf_apply_mat ( dst , a , mat , src , zero , flags ) !! Apply a matrix (tmat or rmat) to src and add to dst. !! Mathematically this is !!     dst= dst + a*mat*src !!  Where dst and src are vectors, mat is a matrix, and a is a scalar !!  If the optional variable \"zero\" is provided and is true, then we compute !!     dst=  a*mat*src class ( pf_encap_t ), intent ( inout ) :: dst (:) !!  destination vector real ( pfdp ), intent ( in ) :: a !!  scalar real ( pfdp ), intent ( in ) :: mat (:, :) !!  matrix class ( pf_encap_t ), intent ( in ) :: src (:) !!  src vector logical , intent ( in ), optional :: zero !! If false, don't zero out the the dst variable before computing integer , intent ( in ), optional :: flags !! Used for choosing which variable to operate on !!  Local variables logical :: lzero !!  local version of input parameter zero integer :: which !!  local version of flags integer :: n , m !!  size of mat integer :: i , j !!  loop variables lzero = . true .; if ( present ( zero )) lzero = zero which = 1 ; if ( present ( flags )) which = flags n = size ( mat , dim = 1 ) m = size ( mat , dim = 2 ) do i = 1 , n if ( lzero ) call dst ( i )% setval ( 0.0_pfdp , flags ) do j = 1 , m if ( a * mat ( i , j ) /= 0.0_pfdp ) call dst ( i )% axpy ( a * mat ( i , j ), src ( j ), flags ) end do end do end subroutine pf_apply_mat","tags":"","loc":"proc/pf_apply_mat.html","title":"pf_apply_mat – LibPFASST"},{"text":"public subroutine pf_apply_mat_backward(dst, a, mat, src, zero, flags) Apply a matrix (tmat or rmat) to src and add to dst. Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: dst (:) destination vector real(kind=pfdp), intent(in) :: a scalar real(kind=pfdp), intent(in) :: mat (:,:) matrix class( pf_encap_t ), intent(in) :: src (:) src vector logical, intent(in), optional :: zero If false, don't zero out the the dst variable before computing integer, intent(in), optional :: flags Used for choosing which variable to operate on Local variables Contents Source Code pf_apply_mat_backward Source Code subroutine pf_apply_mat_backward ( dst , a , mat , src , zero , flags ) !! Apply a matrix (tmat or rmat) to src and add to dst. class ( pf_encap_t ), intent ( inout ) :: dst (:) !!  destination vector real ( pfdp ), intent ( in ) :: a !!  scalar real ( pfdp ), intent ( in ) :: mat (:, :) !!  matrix class ( pf_encap_t ), intent ( in ) :: src (:) !!  src vector logical , intent ( in ), optional :: zero !! If false, don't zero out the the dst variable before computing integer , intent ( in ), optional :: flags !! Used for choosing which variable to operate on !!  Local variables logical :: lzero !!  local version of input parameter zero integer :: which !!  local version of flags integer :: n , m !!  size of mat integer :: i , j !!  loop variables lzero = . true .; if ( present ( zero )) lzero = zero which = 2 ; if ( present ( flags )) which = flags if ( which /= 2 ) & stop \"pf_apply_mat_backward can only be used for restricting the backward integrals with which==2\" n = size ( mat , dim = 1 ) m = size ( mat , dim = 2 ) do i = 1 , n if ( lzero ) call dst ( n + 1 - i )% setval ( 0.0_pfdp , 2 ) do j = 1 , m if ( a * mat ( i , j ) /= 0.0_pfdp ) call dst ( n + 1 - i )% axpy ( a * mat ( i , j ), src ( m + 1 - j ), 2 ) end do end do end subroutine pf_apply_mat_backward","tags":"","loc":"proc/pf_apply_mat_backward.html","title":"pf_apply_mat_backward – LibPFASST"},{"text":"public function not_proper(flags, node) Function to decide if the restriction of the nodes is pointwise, e.g. coarse nodes are every other fine node Arguments Type Intent Optional Attributes Name integer, intent(in) :: flags (:) integer, intent(in) :: node Return Value logical Called by proc~~not_proper~~CalledByGraph proc~not_proper not_proper proc~sdc_qmats sdc_qmats proc~sdc_qmats->proc~not_proper proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~sdc_qmats proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup var panprocnot_properCalledByGraph = svgPanZoom('#procnot_properCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code not_proper Source Code logical function not_proper ( flags , node ) integer , intent ( in ) :: flags (:) integer , intent ( in ) :: node not_proper = . not . btest ( flags ( node ), 0 ) end function not_proper","tags":"","loc":"proc/not_proper.html","title":"not_proper – LibPFASST"},{"text":"public function poly_eval(p, n, x) result(v) Polynomial manipulation routines. A polynomial p p(x) = a_n x&#94;n + ... + a_2 x&#94;2 + a_1 x + a_0 is stored as a Fortran array p(0:n) according to p = [ a_0, a_1, ..., a_n ]. Function to evaluate real polynomial Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n real(kind=pfqp), intent(in) :: x Return Value real(kind=pfqp) Contents None","tags":"","loc":"proc/poly_eval.html","title":"poly_eval – LibPFASST"},{"text":"public function poly_eval_complex(p, n, x) result(v) Function to evaluate complex polynomial Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n complex(kind=pfqp), intent(in) :: x Return Value complex(kind=pfqp) Called by proc~~poly_eval_complex~~CalledByGraph proc~poly_eval_complex poly_eval_complex interface~poly_eval poly_eval interface~poly_eval->proc~poly_eval_complex interface~poly_eval->interface~poly_eval proc~poly_roots poly_roots proc~poly_roots->proc~poly_eval_complex proc~sdc_qnodes sdc_qnodes proc~sdc_qnodes->proc~poly_roots proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~sdc_qnodes proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup var panprocpoly_eval_complexCalledByGraph = svgPanZoom('#procpoly_eval_complexCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/poly_eval_complex.html","title":"poly_eval_complex – LibPFASST"},{"text":"public subroutine pf_init_sdcmats(pf, SDCmats, nnodes, nflags) Uses pf_mod_utils proc~~pf_init_sdcmats~~UsesGraph proc~pf_init_sdcmats pf_init_sdcmats module~pf_mod_utils pf_mod_utils proc~pf_init_sdcmats->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Initialize the sdcmats type with the correct nodes and quadrature matrices\n Decide what the base integration type is Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf PFASST structure type( pf_sdcmats_t ), intent(inout) :: SDCmats integer, intent(in) :: nnodes integer, intent(inout) :: nflags (nnodes) Calls proc~~pf_init_sdcmats~~CallsGraph proc~pf_init_sdcmats pf_init_sdcmats proc~pf_make_matrices pf_make_matrices proc~pf_init_sdcmats->proc~pf_make_matrices proc~pf_quadrature pf_quadrature proc~pf_init_sdcmats->proc~pf_quadrature proc~myluq myLUq proc~pf_make_matrices->proc~myluq proc~sdc_qnodes sdc_qnodes proc~pf_quadrature->proc~sdc_qnodes proc~pf_stop pf_stop proc~pf_quadrature->proc~pf_stop proc~sdc_qmats sdc_qmats proc~pf_quadrature->proc~sdc_qmats proc~sdc_qnodes->proc~pf_stop proc~poly_legendre poly_legendre proc~sdc_qnodes->proc~poly_legendre proc~poly_diff poly_diff proc~sdc_qnodes->proc~poly_diff proc~poly_roots poly_roots proc~sdc_qnodes->proc~poly_roots proc~myluq->proc~pf_stop proc~poly_int poly_int proc~sdc_qmats->proc~poly_int proc~not_proper not_proper proc~sdc_qmats->proc~not_proper interface~poly_eval poly_eval proc~sdc_qmats->interface~poly_eval proc~qsort qsort proc~poly_roots->proc~qsort proc~poly_eval_complex poly_eval_complex proc~poly_roots->proc~poly_eval_complex interface~poly_eval->interface~poly_eval interface~poly_eval->proc~poly_eval_complex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_init_sdcmats~~CalledByGraph proc~pf_init_sdcmats pf_init_sdcmats proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_init_sdcmats Source Code subroutine pf_init_sdcmats ( pf , SDCmats , nnodes , nflags ) use pf_mod_utils type ( pf_pfasst_t ), intent ( in ) :: pf !!  PFASST structure type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats integer , intent ( in ) :: nnodes ! Number of ndoes integer , intent ( inout ) :: nflags ( nnodes ) integer :: ierr integer :: nnodes0 !  Copy some info SDCmats % nnodes = nnodes SDCmats % qtype = pf % qtype SDCmats % use_proper_nodes = pf % use_proper_nodes SDCmats % use_composite_nodes = pf % use_composite_nodes SDCmats % use_no_left_q = pf % use_no_left_q !> Decide what the base integration type is if ( SDCmats % use_composite_nodes ) then nnodes0 = pf % levels ( 1 )% nnodes !  Will use the coarsest quadrature rule in composite else nnodes0 = pf % levels ( pf % nlevels )% nnodes ! Will use the end if !  Allocate nodes and collocation matrices allocate ( SDCmats % qnodes ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , & __ LINE__ , \"allocate error qnodes\" ) allocate ( SDCmats % qmat ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmat\" ) allocate ( SDCmats % s0mat ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error s0mat\" ) !  Make the nodes and collocation matrices call pf_quadrature ( SDCmats % qtype , nnodes , nnodes0 , & SDCmats % qnodes , nflags , SDCmats % s0mat , SDCmats % qmat , & SDCmats % use_proper_nodes , SDCmats % use_composite_nodes , SDCmats % use_no_left_q ) !  Make the substepping matrices call pf_make_matrices ( SDCmats ) end subroutine pf_init_sdcmats","tags":"","loc":"proc/pf_init_sdcmats.html","title":"pf_init_sdcmats – LibPFASST"},{"text":"public subroutine pf_destroy_sdcmats(SDCmats) Destroy the sdcmats structure Arguments Type Intent Optional Attributes Name type( pf_sdcmats_t ), intent(inout) :: SDCmats Called by proc~~pf_destroy_sdcmats~~CalledByGraph proc~pf_destroy_sdcmats pf_destroy_sdcmats proc~pf_level_destroy pf_level_destroy proc~pf_level_destroy->proc~pf_destroy_sdcmats proc~pf_pfasst_destroy pf_pfasst_destroy proc~pf_pfasst_destroy->proc~pf_level_destroy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_destroy_sdcmats Source Code subroutine pf_destroy_sdcmats ( SDCmats ) type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats deallocate ( SDCmats % qmat ) deallocate ( SDCmats % qmatFE ) deallocate ( SDCmats % qmatBE ) deallocate ( SDCmats % qmatTrap ) deallocate ( SDCmats % qmatVer ) deallocate ( SDCmats % qmatLU ) deallocate ( SDCmats % s0mat ) deallocate ( SDCmats % qnodes ) end subroutine pf_destroy_sdcmats","tags":"","loc":"proc/pf_destroy_sdcmats.html","title":"pf_destroy_sdcmats – LibPFASST"},{"text":"public subroutine myLUq(Q, QLU, Nnodes, fillq) Routine to compute the LU decomposition of spectral integration matrix Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: Q (Nnodes-1,Nnodes) real(kind=pfdp), intent(inout) :: QLU (Nnodes-1,Nnodes) integer, intent(in) :: Nnodes integer, intent(in) :: fillq Calls proc~~myluq~~CallsGraph proc~myluq myLUq proc~pf_stop pf_stop proc~myluq->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~myluq~~CalledByGraph proc~myluq myLUq proc~pf_make_matrices pf_make_matrices proc~pf_make_matrices->proc~myluq proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_make_matrices proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code myLUq Source Code subroutine myLUq ( Q , QLU , Nnodes , fillq ) integer , intent ( in ) :: Nnodes real ( pfdp ), intent ( in ) :: Q ( Nnodes - 1 , Nnodes ) real ( pfdp ), intent ( inout ) :: QLU ( Nnodes - 1 , Nnodes ) integer , intent ( in ) :: fillq ! Return the QLU=U&#94;T where U is the LU decomposition of Q without pivoting ! if fillq is positive, then the first row of QLU is filled to make ! the matrix consistent integer :: i , j , N real ( pfdp ) :: c real ( pfdp ) :: U ( Nnodes - 1 , Nnodes - 1 ) real ( pfdp ) :: L ( Nnodes - 1 , Nnodes - 1 ) real ( pfdp ) :: LUerror L = 0.0_pfdp U = 0.0_pfdp N = Nnodes - 1 U = transpose ( Q ( 1 : Nnodes - 1 , 2 : Nnodes )) do i = 1 , N if ( abs ( U ( i , i )) . gt . 1.0e-15_pfdp ) then do j = i + 1 , N c = U ( j , i ) / U ( i , i ) U ( j , i : N ) = U ( j , i : N ) - c * U ( i , i : N ) L ( j , i ) = c end do end if L ( i , i ) = 1.0_pfdp end do !  Check LUerror = maxval ( abs ( matmul ( L , U ) - transpose ( Q ( 1 : Nnodes - 1 , 2 : Nnodes )))) if ( LUerror . gt . 1 e - 14 ) then call pf_stop ( __ FILE__ , __ LINE__ , 'error in LU too high' ) end if QLU = 0.0_pfdp QLU ( 1 : Nnodes - 1 , 2 : Nnodes ) = transpose ( U ) !  Now scale the columns of U to match the sum of A if ( fillq . eq . 1 ) then do j = 1 , Nnodes - 1 QLU ( j , 1 ) = sum ( Q ( j , 1 : Nnodes )) - sum ( U ( j , 1 : Nnodes - 1 )) end do end if end subroutine myLUq","tags":"","loc":"proc/myluq.html","title":"myLUq – LibPFASST"},{"text":"public subroutine pf_quadrature(qtype, nnodes, nnodes0, nodes, nflags, smat, qmat, proper, composite, no_left) Subroutine to create quadrature nodes and matrices Arguments Type Intent Optional Attributes Name integer, intent(in) :: qtype integer, intent(in) :: nnodes integer, intent(in) :: nnodes0 real(kind=pfdp), intent(out) :: nodes (nnodes) integer, intent(out) :: nflags (nnodes) real(kind=pfdp), intent(out) :: smat (nnodes-1,nnodes) real(kind=pfdp), intent(out) :: qmat (nnodes-1,nnodes) logical, intent(in) :: proper logical, intent(in) :: composite logical, intent(in) :: no_left Calls proc~~pf_quadrature~~CallsGraph proc~pf_quadrature pf_quadrature proc~sdc_qnodes sdc_qnodes proc~pf_quadrature->proc~sdc_qnodes proc~pf_stop pf_stop proc~pf_quadrature->proc~pf_stop proc~sdc_qmats sdc_qmats proc~pf_quadrature->proc~sdc_qmats proc~sdc_qnodes->proc~pf_stop proc~poly_legendre poly_legendre proc~sdc_qnodes->proc~poly_legendre proc~poly_diff poly_diff proc~sdc_qnodes->proc~poly_diff proc~poly_roots poly_roots proc~sdc_qnodes->proc~poly_roots proc~poly_int poly_int proc~sdc_qmats->proc~poly_int proc~not_proper not_proper proc~sdc_qmats->proc~not_proper interface~poly_eval poly_eval proc~sdc_qmats->interface~poly_eval proc~qsort qsort proc~poly_roots->proc~qsort proc~poly_eval_complex poly_eval_complex proc~poly_roots->proc~poly_eval_complex interface~poly_eval->interface~poly_eval interface~poly_eval->proc~poly_eval_complex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_quadrature~~CalledByGraph proc~pf_quadrature pf_quadrature proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_quadrature Source Code subroutine pf_quadrature ( qtype , nnodes , nnodes0 , nodes , nflags , smat , qmat , proper , composite , no_left ) integer , intent ( in ) :: qtype ! Type of nodes integer , intent ( in ) :: nnodes ! Number of nodes on this level integer , intent ( in ) :: nnodes0 ! Number of node on base level (either finest or coarsest) real ( pfdp ), intent ( out ) :: nodes ( nnodes ) !  The nodes real ( pfdp ), intent ( out ) :: smat ( nnodes - 1 , nnodes ) !  node to node integration matrix real ( pfdp ), intent ( out ) :: qmat ( nnodes - 1 , nnodes ) !  O to node collocation matrix integer , intent ( out ) :: nflags ( nnodes ) !  Flags logical , intent ( in ) :: composite !  Use composite nodes logical , intent ( in ) :: proper !  Use proper nodes instead of node restriction logical , intent ( in ) :: no_left !  Don't use left hand end point real ( pfdp ) :: dt !  The size of the composite base rule real ( pfqp ) :: qnodes0 ( nnodes0 ) ! quad precision base nodes real ( pfqp ) :: qnodes ( nnodes ) ! quad precision nodes real ( pfdp ) :: qmat0 ( nnodes0 - 1 , nnodes0 ), smat0 ( nnodes0 - 1 , nnodes0 ), qcomp0 ( nnodes0 - 1 , nnodes0 ) integer :: flags0 ( nnodes0 ) integer :: i , j , ri , rj , refine , m qmat = 0 smat = 0 flags0 = 0 nflags = 0 if ( composite ) then ! nodes are given by repeating the coarsest set of nodes.  note ! that in this case nnodes0 corresponds to the coarsest number ! of nodes. refine = ( nnodes - 1 ) / ( nnodes0 - 1 ) call sdc_qnodes ( qnodes0 , flags0 , qtype , nnodes0 ) !  Make coarsest level nodes call sdc_qmats ( qmat0 , smat0 , qnodes0 , qnodes0 , flags0 , nnodes0 , nnodes0 ) !  Make coarsest level qmat !  This block matrix will be used to fill in composite qmat do m = 1 , nnodes0 - 1 qcomp0 ( m ,:) = qmat0 ( nnodes0 - 1 ,:) !  load each row with the integral over the whole composite step end do !  Build big block matrix dt = 1.0_pfdp / refine do i = 1 , refine ri = ( i - 1 ) * ( nnodes0 - 1 ) + 1 !  beginning of ith composite rule qnodes ( ri : ri + nnodes0 - 1 ) = dt * (( i - 1 ) + qnodes0 ) !  Assigns endpoints of composites twice, but no biggie smat ( ri : ri + nnodes0 - 2 , ri : ri + nnodes0 - 1 ) = dt * smat0 ! Make block diagonal smat qmat ( ri : ri + nnodes0 - 2 , ri : ri + nnodes0 - 1 ) = dt * qmat0 ! Make block diagonal qmat do j = 1 , i - 1 !   column blocks to left of diag rj = ( j - 1 ) * ( nnodes0 - 1 ) + 1 qmat ( ri : ri + nnodes0 - 2 , rj : rj + nnodes0 - 1 ) = qmat ( ri : ri + nnodes0 - 2 , rj : rj + nnodes0 - 1 ) + dt * qcomp0 end do end do else if ( proper ) then ! nodes are given by proper quadrature rules call sdc_qnodes ( qnodes , nflags , qtype , nnodes ) call sdc_qmats ( qmat , smat , qnodes , qnodes , nflags , nnodes , nnodes ) else ! nodes are given by refining the finest set of nodes.  note ! that in this case nnodes0 corresponds to the finest number of ! nodes. refine = ( nnodes0 - 1 ) / ( nnodes - 1 ) call sdc_qnodes ( qnodes0 , flags0 , qtype , nnodes0 ) !  Make finest nodes qnodes = qnodes0 ( :: refine ) nflags = flags0 ( :: refine ) if ( no_left ) nflags ( 1 ) = 0 call sdc_qmats ( qmat , smat , qnodes , qnodes , nflags , nnodes , nnodes ) end if nodes = real ( qnodes , pfdp ) if ( all ( nodes == 0.0d0 )) then call pf_stop ( __ FILE__ , __ LINE__ ,& 'ERROR: pf_quadrature: invalid SDC nnodes.' ) end if end subroutine pf_quadrature","tags":"","loc":"proc/pf_quadrature.html","title":"pf_quadrature – LibPFASST"},{"text":"public subroutine pf_make_matrices(SDCmats) Arguments Type Intent Optional Attributes Name type( pf_sdcmats_t ), intent(inout) :: SDCmats Calls proc~~pf_make_matrices~~CallsGraph proc~pf_make_matrices pf_make_matrices proc~myluq myLUq proc~pf_make_matrices->proc~myluq proc~pf_stop pf_stop proc~myluq->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_make_matrices~~CalledByGraph proc~pf_make_matrices pf_make_matrices proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_make_matrices proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_make_matrices Source Code subroutine pf_make_matrices ( SDCmats ) type ( pf_sdcmats_t ), intent ( inout ) :: SDCmats integer :: nnodes integer :: ierr , m , n nnodes = SDCmats % nnodes allocate ( SDCmats % qmatFE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmatFE\" ) allocate ( SDCmats % qmatBE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmatBE\" ) allocate ( SDCmats % qmatTrap ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmatBE\" ) allocate ( SDCmats % qmatVer ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmatBE\" ) allocate ( SDCmats % qmatLU ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error qmatLU\" ) !  Make implicit Euler matrices SDCmats % qmatBE = 0.0_pfdp do m = 1 , nnodes - 1 do n = 1 , m SDCmats % qmatBE ( m , n + 1 ) = SDCmats % qnodes ( n + 1 ) - SDCmats % qnodes ( n ) end do end do ! Make explicit matrix SDCmats % qmatFE = 0.0_pfdp do m = 1 , nnodes - 1 do n = 1 , m SDCmats % qmatFE ( m , n ) = SDCmats % qnodes ( n + 1 ) - SDCmats % qnodes ( n ) end do end do !  Trapezoid matrix SDCmats % qmatTrap = 0.5_pfdp * ( SDCmats % qmatFE + SDCmats % qmatBE ) !  Get the LU call myLUq ( SDCmats % qmat , SDCmats % qmatLU , nnodes , 0 ) end subroutine pf_make_matrices","tags":"","loc":"proc/pf_make_matrices.html","title":"pf_make_matrices – LibPFASST"},{"text":"public subroutine sdc_qnodes(qnodes, flags, qtype, nnodes) Subroutine to compute high precision quadrature nodes. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: qnodes (nnodes) The computed quadrature nodes integer, intent(out) :: flags (nnodes) integer, intent(in), value :: qtype Type of nodes (see pf_dtype) integer, intent(in), value :: nnodes Number of nodes Calls proc~~sdc_qnodes~~CallsGraph proc~sdc_qnodes sdc_qnodes proc~poly_legendre poly_legendre proc~sdc_qnodes->proc~poly_legendre proc~pf_stop pf_stop proc~sdc_qnodes->proc~pf_stop proc~poly_diff poly_diff proc~sdc_qnodes->proc~poly_diff proc~poly_roots poly_roots proc~sdc_qnodes->proc~poly_roots proc~qsort qsort proc~poly_roots->proc~qsort proc~poly_eval_complex poly_eval_complex proc~poly_roots->proc~poly_eval_complex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~sdc_qnodes~~CalledByGraph proc~sdc_qnodes sdc_qnodes proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~sdc_qnodes proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sdc_qnodes Source Code subroutine sdc_qnodes ( qnodes , flags , qtype , nnodes ) integer , intent ( in ), value :: nnodes !!  Number of nodes integer , intent ( in ), value :: qtype !!  Type of nodes (see pf_dtype) real ( pfqp ), intent ( out ) :: qnodes ( nnodes ) !!  The computed quadrature nodes integer , intent ( out ) :: flags ( nnodes ) !! integer :: j , degree real ( pfqp ), allocatable :: roots (:) real ( pfqp ), allocatable :: coeffs (:), coeffs2 (:) real ( pfqp ), parameter :: pi = 3.141592653589793115997963468544185161590576171875_pfdp flags = 0 select case ( qtype ) case ( SDC_GAUSS_LEGENDRE ) degree = nnodes - 2 allocate ( roots ( degree )) allocate ( coeffs ( degree + 1 )) call poly_legendre ( coeffs , degree ) call poly_roots ( roots , coeffs , degree ) qnodes ( 1 ) = 0.0_pfqp qnodes ( 2 : nnodes - 1 ) = 0.5_pfqp * ( 1.0_pfqp + roots ) qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs ) deallocate ( roots ) do j = 2 , nnodes - 1 flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_GAUSS_LOBATTO ) degree = nnodes - 1 allocate ( roots ( degree - 1 )) allocate ( coeffs ( degree + 1 )) call poly_legendre ( coeffs , degree ) call poly_diff ( coeffs , degree ) call poly_roots ( roots , coeffs (: degree ), degree - 1 ) qnodes ( 1 ) = 0.0_pfqp qnodes ( 2 : nnodes - 1 ) = 0.5_pfqp * ( 1.0_pfqp + roots ) qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs ) deallocate ( roots ) do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_GAUSS_RADAU ) degree = nnodes - 1 allocate ( roots ( degree )) allocate ( coeffs ( degree + 1 )) allocate ( coeffs2 ( degree )) call poly_legendre ( coeffs , degree ) call poly_legendre ( coeffs2 , degree - 1 ) coeffs (: degree ) = coeffs (: degree ) + coeffs2 call poly_roots ( roots , coeffs , degree ) qnodes ( 1 ) = 0.0_pfqp do j = 2 , nnodes - 1 qnodes ( j ) = 0.5_pfqp * ( 1.0_pfqp - roots ( nnodes + 1 - j )) end do qnodes ( nnodes ) = 1.0_pfqp deallocate ( coeffs2 ) deallocate ( coeffs ) deallocate ( roots ) do j = 2 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_CLENSHAW_CURTIS ) do j = 0 , nnodes - 1 qnodes ( j + 1 ) = 0.5_pfqp * ( 1.0_pfqp - cos ( j * pi / ( nnodes - 1 ))) end do do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_UNIFORM ) do j = 0 , nnodes - 1 qnodes ( j + 1 ) = j * ( 1.0_pfqp / ( nnodes - 1 )) end do do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case ( SDC_CHEBYSHEV ) qnodes ( 1 ) = 0.0_pfqp do j = 1 , nnodes - 2 qnodes ( j + 1 ) = 0.5_pfqp * ( 1.0_pfqp - cos (( j - 1 / 2 ) * pi / ( nnodes - 2 ))) end do qnodes ( nnodes ) = 0.0_pfqp do j = 1 , nnodes flags ( j ) = ibset ( flags ( j ), 0 ) end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , qtype ) end select end subroutine sdc_qnodes","tags":"","loc":"proc/sdc_qnodes.html","title":"sdc_qnodes – LibPFASST"},{"text":"public subroutine sdc_qmats(qmat, smat, dst, src, flags, ndst, nsrc) Subroutine to compute the quadrature matrices Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(out) :: qmat (ndst-1,nsrc) O to dst quadrature weights real(kind=pfdp), intent(out) :: smat (ndst-1,nsrc) dst(m) to dst(m+1) quadrature weights real(kind=pfqp), intent(in) :: dst (ndst) Destination points real(kind=pfqp), intent(in) :: src (nsrc) Source points integer, intent(in) :: flags (nsrc) integer, intent(in), value :: ndst Number of destination points integer, intent(in), value :: nsrc Number of source points Calls proc~~sdc_qmats~~CallsGraph proc~sdc_qmats sdc_qmats proc~not_proper not_proper proc~sdc_qmats->proc~not_proper interface~poly_eval poly_eval proc~sdc_qmats->interface~poly_eval proc~poly_int poly_int proc~sdc_qmats->proc~poly_int interface~poly_eval->interface~poly_eval proc~poly_eval_complex poly_eval_complex interface~poly_eval->proc~poly_eval_complex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~sdc_qmats~~CalledByGraph proc~sdc_qmats sdc_qmats proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~sdc_qmats proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sdc_qmats Source Code subroutine sdc_qmats ( qmat , smat , dst , src , flags , ndst , nsrc ) integer , intent ( in ), value :: ndst !!  Number of destination points integer , intent ( in ), value :: nsrc !!  Number of source points real ( pfqp ), intent ( in ) :: dst ( ndst ) !!  Destination points real ( pfqp ), intent ( in ) :: src ( nsrc ) !!  Source points real ( pfdp ), intent ( out ) :: qmat ( ndst - 1 , nsrc ) !!  O to dst quadrature weights real ( pfdp ), intent ( out ) :: smat ( ndst - 1 , nsrc ) !! dst(m) to dst(m+1) quadrature weights integer , intent ( in ) :: flags ( nsrc ) integer :: i , j , m real ( pfqp ) :: q , s , den , p ( 0 : nsrc ) qmat = 0.0_pfdp smat = 0.0_pfdp ! construct qmat and smat do i = 1 , nsrc if ( not_proper ( flags , i )) cycle ! construct interpolating polynomial coefficients p = 0.0_pfdp p ( 0 ) = 1.0_pfdp do m = 1 , nsrc if ( not_proper ( flags , m ) . or . m == i ) cycle p = eoshift ( p , - 1 ) - src ( m ) * p end do den = poly_eval ( p , nsrc , src ( i )) call poly_int ( p , nsrc ) ! evaluate integrals do j = 2 , ndst q = poly_eval ( p , nsrc , dst ( j )) - poly_eval ( p , nsrc , 0.0_pfqp ) s = poly_eval ( p , nsrc , dst ( j )) - poly_eval ( p , nsrc , dst ( j - 1 )) qmat ( j - 1 , i ) = real ( q / den , pfdp ) smat ( j - 1 , i ) = real ( s / den , pfdp ) end do end do end subroutine sdc_qmats","tags":"","loc":"proc/sdc_qmats.html","title":"sdc_qmats – LibPFASST"},{"text":"public subroutine poly_diff(p, n) Subroutine to differentiate polynomial (in place) Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: p (0:n) integer, intent(in), value :: n Called by proc~~poly_diff~~CalledByGraph proc~poly_diff poly_diff proc~sdc_qnodes sdc_qnodes proc~sdc_qnodes->proc~poly_diff proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~sdc_qnodes proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup var panprocpoly_diffCalledByGraph = svgPanZoom('#procpoly_diffCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code poly_diff Source Code subroutine poly_diff ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( inout ) :: p ( 0 : n ) integer :: j real ( pfqp ) :: pp ( 0 : n ) pp = 0.0_pfqp do j = 1 , n pp ( j - 1 ) = j * p ( j ) end do p = pp end subroutine poly_diff","tags":"","loc":"proc/poly_diff.html","title":"poly_diff – LibPFASST"},{"text":"public subroutine poly_int(p, n) Subroutine to integrate polynomial (in place) Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: p (0:n) integer, intent(in), value :: n Called by proc~~poly_int~~CalledByGraph proc~poly_int poly_int proc~sdc_qmats sdc_qmats proc~sdc_qmats->proc~poly_int proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~sdc_qmats proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup var panprocpoly_intCalledByGraph = svgPanZoom('#procpoly_intCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code poly_int Source Code subroutine poly_int ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( inout ) :: p ( 0 : n ) integer :: j real ( pfqp ) :: pp ( 0 : n ) pp = 0.0_pfqp do j = 0 , n - 1 pp ( j + 1 ) = p ( j ) / ( j + 1 ) end do p = pp end subroutine poly_int","tags":"","loc":"proc/poly_int.html","title":"poly_int – LibPFASST"},{"text":"public subroutine poly_legendre(p, n) Subroutine to compute Legendre polynomial coefficients using Bonnet's recursion formula. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: p (0:n) integer, intent(in), value :: n Called by proc~~poly_legendre~~CalledByGraph proc~poly_legendre poly_legendre proc~sdc_qnodes sdc_qnodes proc~sdc_qnodes->proc~poly_legendre proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~sdc_qnodes proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup var panprocpoly_legendreCalledByGraph = svgPanZoom('#procpoly_legendreCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code poly_legendre Source Code subroutine poly_legendre ( p , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( out ) :: p ( 0 : n ) real ( pfqp ), dimension ( 0 : n ) :: p0 , p1 , p2 integer :: j , m if ( n == 0 ) then p = [ 1.0_pfqp ] return end if if ( n == 1 ) then p = [ 0.0_pfqp , 1.0_pfqp ] return end if p0 = 0.0_pfqp ; p1 = 0.0_pfqp ; p2 = 0.0_pfqp p0 ( 0 ) = 1.0_pfqp p1 ( 1 ) = 1.0_pfqp ! (n + 1) P_{n+1} = (2n + 1) x P_{n} - n P_{n-1} do m = 1 , n - 1 do j = 1 , n p2 ( j ) = ( ( 2 * m + 1 ) * p1 ( j - 1 ) - m * p0 ( j ) ) / ( m + 1 ) end do p2 ( 0 ) = - m * p0 ( 0 ) / ( m + 1 ) p0 = p1 p1 = p2 end do p = p2 end subroutine poly_legendre","tags":"","loc":"proc/poly_legendre.html","title":"poly_legendre – LibPFASST"},{"text":"public subroutine poly_roots(roots, p0, n) Subroutine to compute polynomial roots using the Durand-Kerner algorithm.\n The roots are assumed to be real. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: roots (n) real(kind=pfqp), intent(in) :: p0 (0:n) integer, intent(in), value :: n Calls proc~~poly_roots~~CallsGraph proc~poly_roots poly_roots proc~qsort qsort proc~poly_roots->proc~qsort proc~poly_eval_complex poly_eval_complex proc~poly_roots->proc~poly_eval_complex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~poly_roots~~CalledByGraph proc~poly_roots poly_roots proc~sdc_qnodes sdc_qnodes proc~sdc_qnodes->proc~poly_roots proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~sdc_qnodes proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup var panprocpoly_rootsCalledByGraph = svgPanZoom('#procpoly_rootsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code poly_roots Source Code subroutine poly_roots ( roots , p0 , n ) integer , intent ( in ), value :: n real ( pfqp ), intent ( out ) :: roots ( n ) real ( pfqp ), intent ( in ) :: p0 ( 0 : n ) integer :: i , j , k complex ( pfqp ) :: num , den , z0 ( n ), z1 ( n ) real ( pfqp ) :: p ( 0 : n ) real ( pfqp ) :: eps eps = epsilon ( 1.0_pfqp ) * 10 0.0_pfqp p = p0 / p0 ( n ) ! initial guess do i = 1 , n z0 ( i ) = ( 0.4_pfqp , 0.9_pfqp ) ** i end do ! durand-kerner-weierstrass iterations z1 = z0 do k = 1 , 100 do i = 1 , n ! evaluate poly at z0(i) num = poly_eval_complex ( p , n , z0 ( i )) ! evaluate denominator den = 1.0_pfqp do j = 1 , n if ( j == i ) cycle den = den * ( z0 ( i ) - z0 ( j )) end do ! update z0 ( i ) = z0 ( i ) - num / den end do ! converged? if ( sum ( abs ( z0 - z1 )) < eps ) exit z1 = z0 end do roots = real ( z0 ) where ( abs ( roots ) < eps ) roots = 0.0_pfqp call qsort ( roots ) end subroutine poly_roots","tags":"","loc":"proc/poly_roots.html","title":"poly_roots – LibPFASST"},{"text":"public recursive subroutine qsort(a) Subroutine to sort (inplace) using the quick sort algorithm.\n Adapted from http://www.fortran.com/qsort_c.f95. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: a (:) Called by proc~~qsort~~CalledByGraph proc~qsort qsort proc~poly_roots poly_roots proc~poly_roots->proc~qsort proc~sdc_qnodes sdc_qnodes proc~sdc_qnodes->proc~poly_roots proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~sdc_qnodes proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup var panprocqsortCalledByGraph = svgPanZoom('#procqsortCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code qsort Source Code recursive subroutine qsort ( a ) real ( pfqp ), intent ( inout ) :: a (:) integer :: iq if ( size ( a ) > 1 ) then call qsort_partition ( a , iq ) call qsort ( a (: iq - 1 )) call qsort ( a ( iq :)) end if end subroutine qsort","tags":"","loc":"proc/qsort.html","title":"qsort – LibPFASST"},{"text":"public interface poly_eval Calls interface~~poly_eval~~CallsGraph interface~poly_eval poly_eval interface~poly_eval->interface~poly_eval proc~poly_eval_complex poly_eval_complex interface~poly_eval->proc~poly_eval_complex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~poly_eval~~CalledByGraph interface~poly_eval poly_eval interface~poly_eval->interface~poly_eval proc~sdc_qmats sdc_qmats proc~sdc_qmats->interface~poly_eval proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~sdc_qmats proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup var paninterfacepoly_evalCalledByGraph = svgPanZoom('#interfacepoly_evalCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures poly_eval poly_eval_complex Module Procedures public interface poly_eval () Arguments None public function poly_eval_complex (p, n, x) result(v) Function to evaluate complex polynomial Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n complex(kind=pfqp), intent(in) :: x Return Value complex(kind=pfqp)","tags":"","loc":"interface/poly_eval.html","title":"poly_eval – LibPFASST"},{"text":"public function ndsysarray_norm(this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) Contents Source Code ndsysarray_norm Source Code function ndsysarray_norm ( this , flags ) result ( norm ) class ( ndsysarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function ndsysarray_norm","tags":"","loc":"proc/ndsysarray_norm.html","title":"ndsysarray_norm – LibPFASST"},{"text":"public function cast_as_ndsysarray(encap_polymorph) result(ndsysarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndsysarray ),\n  pointer Called by proc~~cast_as_ndsysarray~~CalledByGraph proc~cast_as_ndsysarray cast_as_ndsysarray proc~ndsysarray_destroy ndsysarray_destroy proc~ndsysarray_destroy->proc~cast_as_ndsysarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cast_as_ndsysarray Source Code function cast_as_ndsysarray ( encap_polymorph ) result ( ndsysarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndsysarray ), pointer :: ndsysarray_obj select type ( encap_polymorph ) type is ( ndsysarray ) ndsysarray_obj => encap_polymorph end select end function cast_as_ndsysarray","tags":"","loc":"proc/cast_as_ndsysarray.html","title":"cast_as_ndsysarray – LibPFASST"},{"text":"public function get_array1d(x, n, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:) Contents Source Code get_array1d Source Code function get_array1d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) select type ( x ) type is ( ndsysarray ) r => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array1d","tags":"","loc":"proc/get_array1d.html","title":"get_array1d – LibPFASST"},{"text":"public function get_array2d(x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_array2d Source Code function get_array2d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( ndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array2d","tags":"","loc":"proc/get_array2d.html","title":"get_array2d – LibPFASST"},{"text":"public function get_array3d(x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_array3d Source Code function get_array3d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( ndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 ), 1 : x % arr_shape ( 3 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array3d","tags":"","loc":"proc/get_array3d.html","title":"get_array3d – LibPFASST"},{"text":"public subroutine ndsysarray_build(q, arr_shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: arr_shape (:) Called by proc~~ndsysarray_build~~CalledByGraph proc~ndsysarray_build ndsysarray_build proc~ndsysarray_create_single ndsysarray_create_single proc~ndsysarray_create_single->proc~ndsysarray_build Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndsysarray_build Source Code subroutine ndsysarray_build ( q , arr_shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: arr_shape (:) select type ( q ) class is ( ndsysarray ) allocate ( q % arr_shape ( size ( arr_shape ))) q % dim = size ( arr_shape ) - 1 q % ncomp = arr_shape ( q % dim + 1 ) q % ndof = product ( arr_shape ( 1 : q % dim )) q % arr_shape = arr_shape allocate ( q % flatarray ( product ( arr_shape ))) end select end subroutine ndsysarray_build","tags":"","loc":"proc/ndsysarray_build.html","title":"ndsysarray_build – LibPFASST"},{"text":"public subroutine ndsysarray_create_single(this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Calls proc~~ndsysarray_create_single~~CallsGraph proc~ndsysarray_create_single ndsysarray_create_single proc~ndsysarray_build ndsysarray_build proc~ndsysarray_create_single->proc~ndsysarray_build Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndsysarray_create_single Source Code subroutine ndsysarray_create_single ( this , x , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( ndsysarray :: x ) call ndsysarray_build ( x , shape ) end subroutine ndsysarray_create_single","tags":"","loc":"proc/ndsysarray_create_single.html","title":"ndsysarray_create_single – LibPFASST"},{"text":"public subroutine ndsysarray_create_array(this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndsysarray_create_array Source Code subroutine ndsysarray_create_array ( this , x , n , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndsysarray :: x ( n )) do i = 1 , n call ndsysarray_build ( x ( i ), shape ) end do end subroutine ndsysarray_create_array","tags":"","loc":"proc/ndsysarray_create_array.html","title":"ndsysarray_create_array – LibPFASST"},{"text":"public subroutine ndsysarray_destroy(encap) Subroutine to destroy array (simple) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap Calls proc~~ndsysarray_destroy~~CallsGraph proc~ndsysarray_destroy ndsysarray_destroy proc~cast_as_ndsysarray cast_as_ndsysarray proc~ndsysarray_destroy->proc~cast_as_ndsysarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndsysarray_destroy Source Code subroutine ndsysarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndsysarray ), pointer :: ndsysarray_obj ndsysarray_obj => cast_as_ndsysarray ( encap ) deallocate ( ndsysarray_obj % arr_shape ) deallocate ( ndsysarray_obj % flatarray ) nullify ( ndsysarray_obj ) end subroutine ndsysarray_destroy","tags":"","loc":"proc/ndsysarray_destroy.html","title":"ndsysarray_destroy – LibPFASST"},{"text":"public subroutine ndsysarray_destroy_single(this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndsysarray_destroy_single Source Code subroutine ndsysarray_destroy_single ( this , x , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) select type ( x ) class is ( ndsysarray ) deallocate ( x % arr_shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine ndsysarray_destroy_single","tags":"","loc":"proc/ndsysarray_destroy_single.html","title":"ndsysarray_destroy_single – LibPFASST"},{"text":"public subroutine ndsysarray_destroy_array(this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndsysarray_destroy_array Source Code subroutine ndsysarray_destroy_array ( this , x , n , level , shape ) class ( ndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i select type ( x ) class is ( ndsysarray ) do i = 1 , n deallocate ( x ( i )% arr_shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine ndsysarray_destroy_array","tags":"","loc":"proc/ndsysarray_destroy_array.html","title":"ndsysarray_destroy_array – LibPFASST"},{"text":"public subroutine ndsysarray_setval(this, val, flags) The following are the base subroutines that all encapsulations must provide Subroutine to set array to a scalare  value. Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags Contents Source Code ndsysarray_setval Source Code subroutine ndsysarray_setval ( this , val , flags ) class ( ndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine ndsysarray_setval","tags":"","loc":"proc/ndsysarray_setval.html","title":"ndsysarray_setval – LibPFASST"},{"text":"public subroutine ndsysarray_copy(this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags Contents Source Code ndsysarray_copy Source Code subroutine ndsysarray_copy ( this , src , flags ) class ( ndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( ndsysarray ) this % flatarray = src % flatarray class default stop \"TYPE ERROR\" end select end subroutine ndsysarray_copy","tags":"","loc":"proc/ndsysarray_copy.html","title":"ndsysarray_copy – LibPFASST"},{"text":"public subroutine ndsysarray_pack(this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags Contents Source Code ndsysarray_pack Source Code subroutine ndsysarray_pack ( this , z , flags ) class ( ndsysarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags z = this % flatarray end subroutine ndsysarray_pack","tags":"","loc":"proc/ndsysarray_pack.html","title":"ndsysarray_pack – LibPFASST"},{"text":"public subroutine ndsysarray_unpack(this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags Contents Source Code ndsysarray_unpack Source Code subroutine ndsysarray_unpack ( this , z , flags ) class ( ndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags this % flatarray = z end subroutine ndsysarray_unpack","tags":"","loc":"proc/ndsysarray_unpack.html","title":"ndsysarray_unpack – LibPFASST"},{"text":"public subroutine ndsysarray_axpy(this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Contents Source Code ndsysarray_axpy Source Code subroutine ndsysarray_axpy ( this , a , x , flags ) class ( ndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( ndsysarray ) this % flatarray = a * x % flatarray + this % flatarray class default stop \"TYPE ERROR\" end select end subroutine ndsysarray_axpy","tags":"","loc":"proc/ndsysarray_axpy.html","title":"ndsysarray_axpy – LibPFASST"},{"text":"public subroutine ndsysarray_eprint(this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags Contents Source Code ndsysarray_eprint Source Code subroutine ndsysarray_eprint ( this , flags ) class ( ndsysarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % flatarray ( 1 : 10 ) !print *, this%flatarray end subroutine ndsysarray_eprint","tags":"","loc":"proc/ndsysarray_eprint.html","title":"ndsysarray_eprint – LibPFASST"},{"text":"interface Interfaces to output routines in pf_numpy.c public subroutine ndsysarray_mkdir(dname, dlen) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname integer, intent(in), value :: dlen Description Subroutine to make a directory for output","tags":"","loc":"interface/ndsysarray_mkdir.html","title":"ndsysarray_mkdir – LibPFASST"},{"text":"interface Interfaces to output routines in pf_numpy.c public subroutine ndsysarray_dump_numpy(dname, fname, endian, dim, mpibuflen, arr_shape, array) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: arr_shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Description Subroutine to write an the array to a file","tags":"","loc":"interface/ndsysarray_dump_numpy.html","title":"ndsysarray_dump_numpy – LibPFASST"},{"text":"public function get_wk_ptr_1d(this) result(wk) Routines to return the pointer to the work variable Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer,(:) Contents Source Code get_wk_ptr_1d Source Code function get_wk_ptr_1d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:) ! work space wk => this % wk_1d end function get_wk_ptr_1d","tags":"","loc":"proc/get_wk_ptr_1d.html","title":"get_wk_ptr_1d – LibPFASST"},{"text":"public function get_wk_ptr_2d(this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_wk_ptr_2d Source Code function get_wk_ptr_2d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:,:) ! work space wk => this % wk_2d end function get_wk_ptr_2d","tags":"","loc":"proc/get_wk_ptr_2d.html","title":"get_wk_ptr_2d – LibPFASST"},{"text":"public function get_wk_ptr_3d(this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_wk_ptr_3d Source Code function get_wk_ptr_3d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:,:,:) ! work space wk => this % wk_3d end function get_wk_ptr_3d","tags":"","loc":"proc/get_wk_ptr_3d.html","title":"get_wk_ptr_3d – LibPFASST"},{"text":"public subroutine fft_setup(this, grid_shape, dim, grid_size) Initialize the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) Calls proc~~fft_setup~~CallsGraph proc~fft_setup fft_setup fftw_plan_dft_3d fftw_plan_dft_3d proc~fft_setup->fftw_plan_dft_3d proc~pf_stop pf_stop proc~fft_setup->proc~pf_stop fftw_plan_dft_1d fftw_plan_dft_1d proc~fft_setup->fftw_plan_dft_1d fftw_plan_dft_2d fftw_plan_dft_2d proc~fft_setup->fftw_plan_dft_2d fftw_alloc_complex fftw_alloc_complex proc~fft_setup->fftw_alloc_complex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fft_setup Source Code subroutine fft_setup ( this , grid_shape , dim , grid_size ) class ( pf_fft_t ), intent ( inout ) :: this integer , intent ( in ) :: dim integer , intent ( in ) :: grid_shape ( dim ) real ( pfdp ), optional , intent ( in ) :: grid_size ( dim ) integer :: nx , ny , nz real ( pfdp ) :: kx , ky type ( c_ptr ) :: wk this % dim = dim nx = grid_shape ( 1 ) this % nx = nx ! Defaults for grid_size this % Lx = 1.0_pfdp this % Ly = 1.0_pfdp this % Lz = 1.0_pfdp if ( present ( grid_size )) this % Lx = grid_size ( 1 ) if ( present ( grid_size )) this % Ly = grid_size ( 2 ) if ( present ( grid_size )) this % Lz = grid_size ( 3 ) select case ( dim ) case ( 1 ) this % normfact = real ( nx , pfdp ) wk = fftw_alloc_complex ( int ( nx , c_size_t )) call c_f_pointer ( wk , this % wk_1d , [ nx ]) this % ffft = fftw_plan_dft_1d ( nx , & this % wk_1d , this % wk_1d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifft = fftw_plan_dft_1d ( nx , & this % wk_1d , this % wk_1d , FFTW_BACKWARD , FFTW_ESTIMATE ) case ( 2 ) ny = grid_shape ( 2 ) this % ny = ny this % normfact = real ( nx * ny , pfdp ) ! create in-place, complex fft plans wk = fftw_alloc_complex ( int ( nx * ny , c_size_t )) call c_f_pointer ( wk , this % wk_2d , [ nx , ny ]) this % ffft = fftw_plan_dft_2d ( nx , ny , & this % wk_2d , this % wk_2d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifft = fftw_plan_dft_2d ( nx , ny , & this % wk_2d , this % wk_2d , FFTW_BACKWARD , FFTW_ESTIMATE ) case ( 3 ) ny = grid_shape ( 2 ) nz = grid_shape ( 3 ) this % ny = ny this % nz = nz this % normfact = real ( nx * ny * nz , pfdp ) wk = fftw_alloc_complex ( int ( nx * ny * nz , c_size_t )) call c_f_pointer ( wk , this % wk_3d , [ nx , ny , nz ]) this % ffft = fftw_plan_dft_3d ( nx , ny , nz , & this % wk_3d , this % wk_3d , FFTW_FORWARD , FFTW_ESTIMATE ) this % ifft = fftw_plan_dft_3d ( nx , ny , nz , & this % wk_3d , this % wk_3d , FFTW_BACKWARD , FFTW_ESTIMATE ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_setup","tags":"","loc":"proc/fft_setup.html","title":"fft_setup – LibPFASST"},{"text":"public subroutine fft_destroy(this) Destroy the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Calls proc~~fft_destroy~~CallsGraph proc~fft_destroy fft_destroy proc~pf_stop pf_stop proc~fft_destroy->proc~pf_stop fftw_destroy_plan fftw_destroy_plan proc~fft_destroy->fftw_destroy_plan Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fft_destroy Source Code subroutine fft_destroy ( this ) class ( pf_fft_t ), intent ( inout ) :: this call fftw_destroy_plan ( this % ffft ) call fftw_destroy_plan ( this % ifft ) select case ( this % dim ) case ( 1 ) deallocate ( this % wk_1d ) case ( 2 ) deallocate ( this % wk_2d ) case ( 3 ) deallocate ( this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_destroy","tags":"","loc":"proc/fft_destroy.html","title":"fft_destroy – LibPFASST"},{"text":"public subroutine fftf(this) Routine to take foreward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Calls proc~~fftf~~CallsGraph proc~fftf fftf proc~pf_stop pf_stop proc~fftf->proc~pf_stop fftw_execute_dft fftw_execute_dft proc~fftf->fftw_execute_dft Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fftf~~CalledByGraph proc~fftf fftf proc~conv_3d conv_3d proc~conv_3d->proc~fftf proc~conv_1d conv_1d proc~conv_1d->proc~fftf proc~conv_2d conv_2d proc~conv_2d->proc~fftf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fftf Source Code subroutine fftf ( this ) class ( pf_fft_t ), intent ( inout ) :: this select case ( this % dim ) case ( 1 ) call fftw_execute_dft ( this % ffft , this % wk_1d , this % wk_1d ) case ( 2 ) call fftw_execute_dft ( this % ffft , this % wk_2d , this % wk_2d ) case ( 3 ) call fftw_execute_dft ( this % ffft , this % wk_3d , this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftf","tags":"","loc":"proc/fftf.html","title":"fftf – LibPFASST"},{"text":"public subroutine fftb(this) Routine to take inverse or backward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Calls proc~~fftb~~CallsGraph proc~fftb fftb proc~pf_stop pf_stop proc~fftb->proc~pf_stop fftw_execute_dft fftw_execute_dft proc~fftb->fftw_execute_dft Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fftb~~CalledByGraph proc~fftb fftb proc~conv_3d conv_3d proc~conv_3d->proc~fftb proc~conv_1d conv_1d proc~conv_1d->proc~fftb proc~conv_2d conv_2d proc~conv_2d->proc~fftb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fftb Source Code subroutine fftb ( this ) class ( pf_fft_t ), intent ( inout ) :: this !  Normalize the fft select case ( this % dim ) case ( 1 ) this % wk_1d = this % wk_1d / this % normfact call fftw_execute_dft ( this % ifft , this % wk_1d , this % wk_1d ) case ( 2 ) this % wk_2d = this % wk_2d / this % normfact call fftw_execute_dft ( this % ifft , this % wk_2d , this % wk_2d ) case ( 3 ) this % wk_3d = this % wk_3d / this % normfact call fftw_execute_dft ( this % ifft , this % wk_3d , this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftb","tags":"","loc":"proc/fftb.html","title":"fftb – LibPFASST"},{"text":"public subroutine conv_1d(this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) Calls proc~~conv_1d~~CallsGraph proc~conv_1d conv_1d proc~fftf fftf proc~conv_1d->proc~fftf proc~fftb fftb proc~conv_1d->proc~fftb proc~pf_stop pf_stop proc~fftf->proc~pf_stop fftw_execute_dft fftw_execute_dft proc~fftf->fftw_execute_dft proc~fftb->proc~pf_stop proc~fftb->fftw_execute_dft Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code conv_1d Source Code subroutine conv_1d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:) ! Compute Convolution call fftf ( this ) this % wk_1d = this % wk_1d * g call fftb ( this ) end subroutine conv_1d","tags":"","loc":"proc/conv_1d.html","title":"conv_1d – LibPFASST"},{"text":"public subroutine conv_2d(this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) Calls proc~~conv_2d~~CallsGraph proc~conv_2d conv_2d proc~fftf fftf proc~conv_2d->proc~fftf proc~fftb fftb proc~conv_2d->proc~fftb proc~pf_stop pf_stop proc~fftf->proc~pf_stop fftw_execute_dft fftw_execute_dft proc~fftf->fftw_execute_dft proc~fftb->proc~pf_stop proc~fftb->fftw_execute_dft Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code conv_2d Source Code subroutine conv_2d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:) ! Compute Convolution call fftf ( this ) this % wk_2d = this % wk_2d * g call fftb ( this ) end subroutine conv_2d","tags":"","loc":"proc/conv_2d.html","title":"conv_2d – LibPFASST"},{"text":"public subroutine conv_3d(this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) Calls proc~~conv_3d~~CallsGraph proc~conv_3d conv_3d proc~fftf fftf proc~conv_3d->proc~fftf proc~fftb fftb proc~conv_3d->proc~fftb proc~pf_stop pf_stop proc~fftf->proc~pf_stop fftw_execute_dft fftw_execute_dft proc~fftf->fftw_execute_dft proc~fftb->proc~pf_stop proc~fftb->fftw_execute_dft Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code conv_3d Source Code subroutine conv_3d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:,:) ! Compute Convolution call fftf ( this ) this % wk_3d = this % wk_3d * g call fftb ( this ) end subroutine conv_3d","tags":"","loc":"proc/conv_3d.html","title":"conv_3d – LibPFASST"},{"text":"public subroutine make_lap_1d(this, lap) Routines to construct spectral differential operators Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) Contents Source Code make_lap_1d Source Code subroutine make_lap_1d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:) integer :: i , nx real ( pfdp ) :: kx nx = this % nx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if lap ( i ) = - kx ** 2 end do end subroutine make_lap_1d","tags":"","loc":"proc/make_lap_1d.html","title":"make_lap_1d – LibPFASST"},{"text":"public subroutine make_deriv_1d(this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) Contents Source Code make_deriv_1d Source Code subroutine make_deriv_1d ( this , ddx ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: ddx (:) integer :: i , nx real ( pfdp ) :: kx nx = this % nx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if ddx ( i ) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do end subroutine make_deriv_1d","tags":"","loc":"proc/make_deriv_1d.html","title":"make_deriv_1d – LibPFASST"},{"text":"public subroutine make_lap_2d(this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) Contents Source Code make_lap_2d Source Code subroutine make_lap_2d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:) integer :: i , j , nx , ny real ( pfdp ) :: kx , ky nx = this % nx ny = this % ny do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / this % Ly * dble ( j - 1 ) else ky = two_pi / this % Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if lap ( i , j ) = - ( kx ** 2 + ky ** 2 ) end do end do end subroutine make_lap_2d","tags":"","loc":"proc/make_lap_2d.html","title":"make_lap_2d – LibPFASST"},{"text":"public subroutine make_deriv_2d(this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir Contents Source Code make_deriv_2d Source Code subroutine make_deriv_2d ( this , deriv , dir ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:) integer , intent ( in ) :: dir integer :: i , j , nx , ny real ( pfdp ) :: kx , ky nx = this % nx ny = this % ny do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / this % Ly * dble ( j - 1 ) else ky = two_pi / this % Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if if ( dir . eq . 1 ) then deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * kx else deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * ky endif end do end do end subroutine make_deriv_2d","tags":"","loc":"proc/make_deriv_2d.html","title":"make_deriv_2d – LibPFASST"},{"text":"public subroutine make_lap_3d(this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) Contents Source Code make_lap_3d Source Code subroutine make_lap_3d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:,:) integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz nx = this % nx ny = this % ny nz = this % nz do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / this % Lz * dble ( k - 1 ) else kz = two_pi / this % Lz * dble ( - nz + k - 1 ) end if do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / this % Ly * dble ( j - 1 ) else ky = two_pi / this % Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if lap ( i , j , k ) = - ( kx ** 2 + ky ** 2 + kz ** 2 ) end do end do end do end subroutine make_lap_3d","tags":"","loc":"proc/make_lap_3d.html","title":"make_lap_3d – LibPFASST"},{"text":"public subroutine make_deriv_3d(this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir Calls proc~~make_deriv_3d~~CallsGraph proc~make_deriv_3d make_deriv_3d proc~pf_stop pf_stop proc~make_deriv_3d->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code make_deriv_3d Source Code subroutine make_deriv_3d ( this , deriv , dir ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:,:) integer , intent ( in ) :: dir integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz nx = this % nx ny = this % ny nz = this % nz select case ( dir ) case ( 1 ) do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / this % Lx * dble ( i - 1 ) else kx = two_pi / this % Lx * dble ( - nx + i - 1 ) end if deriv ( i ,:,:) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do case ( 2 ) do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / this % Ly * dble ( j - 1 ) else ky = two_pi / this % Ly * dble ( - ny + j - 1 ) end if deriv (:, j ,:) = ( 0.0_pfdp , 1.0_pfdp ) * ky end do case ( 3 ) do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / this % Lz * dble ( k - 1 ) else kz = two_pi / this % Lz * dble ( - nz + k - 1 ) end if deriv (:,:, k ) = ( 0.0_pfdp , 1.0_pfdp ) * kz end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , dir ) end select end subroutine make_deriv_3d","tags":"","loc":"proc/make_deriv_3d.html","title":"make_deriv_3d – LibPFASST"},{"text":"public function get_wk_ptr_1d(this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer,(:) Contents Source Code get_wk_ptr_1d Source Code function get_wk_ptr_1d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:) ! work space wk => this % wk_1d end function get_wk_ptr_1d","tags":"","loc":"proc/get_wk_ptr_1d~2.html","title":"get_wk_ptr_1d – LibPFASST"},{"text":"public function get_wk_ptr_2d(this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_wk_ptr_2d Source Code function get_wk_ptr_2d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:,:) ! work space wk => this % wk_2d end function get_wk_ptr_2d","tags":"","loc":"proc/get_wk_ptr_2d~2.html","title":"get_wk_ptr_2d – LibPFASST"},{"text":"public function get_wk_ptr_3d(this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_wk_ptr_3d Source Code function get_wk_ptr_3d ( this ) result ( wk ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), pointer :: wk (:,:,:) ! work space wk => this % wk_3d end function get_wk_ptr_3d","tags":"","loc":"proc/get_wk_ptr_3d~2.html","title":"get_wk_ptr_3d – LibPFASST"},{"text":"public subroutine fft_setup(this, grid_shape, dim, grid_size) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) Calls proc~~fft_setup~2~~CallsGraph proc~fft_setup~2 fft_setup proc~zffti ZFFTI proc~fft_setup~2->proc~zffti proc~pf_stop pf_stop proc~fft_setup~2->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fft_setup Source Code subroutine fft_setup ( this , grid_shape , dim , grid_size ) class ( pf_fft_t ), intent ( inout ) :: this integer , intent ( in ) :: dim integer , intent ( in ) :: grid_shape ( dim ) real ( pfdp ), optional , intent ( in ) :: grid_size ( dim ) integer :: nx , ny , nz this % dim = dim !  FFT Storage parameters nx = grid_shape ( 1 ) this % nx = nx this % lensavx = 4 * nx + 15 this % normfact = nx allocate ( this % workhatx ( nx )) !  complex transform allocate ( this % wsavex ( this % lensavx )) this % Lx = 1.0_pfdp if ( present ( grid_size )) this % Lx = grid_size ( 1 ) !  Initialize FFT call ZFFTI ( nx , this % wsavex ) if ( dim > 1 ) then !  FFT Storage ny = grid_shape ( 2 ) this % ny = ny this % lensavy = 4 * ny + 15 this % normfact = nx * ny allocate ( this % workhaty ( ny )) !  complex transform allocate ( this % wsavey ( this % lensavy )) this % Ly = 1.0_pfdp if ( present ( grid_size )) this % Ly = grid_size ( 2 ) !  Initialize FFT call ZFFTI ( ny , this % wsavey ) if ( dim > 2 ) then !  FFT Storage nz = grid_shape ( 3 ) this % nz = nz this % lensavz = 4 * nz + 15 this % normfact = nx * ny * nz allocate ( this % workhatz ( nz )) !  complex transform allocate ( this % wsavez ( this % lensavz )) this % Lz = 1.0_pfdp if ( present ( grid_size )) this % Lz = grid_size ( 3 ) !  Initialize FFT call ZFFTI ( nz , this % wsavez ) endif endif select case ( this % dim ) case ( 1 ) allocate ( this % wk_1d ( nx )) case ( 2 ) allocate ( this % wk_2d ( nx , ny )) case ( 3 ) allocate ( this % wk_3d ( nx , ny , nz )) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_setup","tags":"","loc":"proc/fft_setup~2.html","title":"fft_setup – LibPFASST"},{"text":"public subroutine fft_destroy(this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Calls proc~~fft_destroy~2~~CallsGraph proc~fft_destroy~2 fft_destroy proc~pf_stop pf_stop proc~fft_destroy~2->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fft_destroy Source Code subroutine fft_destroy ( this ) class ( pf_fft_t ), intent ( inout ) :: this deallocate ( this % workhatx ) deallocate ( this % wsavex ) if ( this % dim > 1 ) then deallocate ( this % workhaty ) deallocate ( this % wsavey ) if ( this % dim > 2 ) then deallocate ( this % workhatz ) deallocate ( this % wsavez ) end if end if select case ( this % dim ) case ( 1 ) deallocate ( this % wk_1d ) case ( 2 ) deallocate ( this % wk_2d ) case ( 3 ) deallocate ( this % wk_3d ) case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fft_destroy","tags":"","loc":"proc/fft_destroy~2.html","title":"fft_destroy – LibPFASST"},{"text":"public subroutine fftf(this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Calls proc~~fftf~2~~CallsGraph proc~fftf~2 fftf proc~pf_stop pf_stop proc~fftf~2->proc~pf_stop proc~zfftf ZFFTF proc~fftf~2->proc~zfftf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fftf~2~~CalledByGraph proc~fftf~2 fftf proc~conv_3d~2 conv_3d proc~conv_3d~2->proc~fftf~2 proc~conv_2d~2 conv_2d proc~conv_2d~2->proc~fftf~2 proc~conv_1d~2 conv_1d proc~conv_1d~2->proc~fftf~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fftf Source Code subroutine fftf ( this ) class ( pf_fft_t ), intent ( inout ) :: this integer i , j , k select case ( this % dim ) case ( 1 ) call zfftf ( this % nx , this % wk_1d , this % wsavex ) case ( 2 ) do j = 1 , this % ny this % workhatx = this % wk_2d (:, j ) call zfftf ( this % nx , this % workhatx , this % wsavex ) this % wk_2d (:, j ) = this % workhatx end do do i = 1 , this % nx this % workhaty = this % wk_2d ( i ,:) call zfftf ( this % ny , this % workhaty , this % wsavey ) this % wk_2d ( i ,:) = this % workhaty end do case ( 3 ) do k = 1 , this % nz do j = 1 , this % ny this % workhatx = this % wk_3d (:, j , k ) call zfftf ( this % nx , this % workhatx , this % wsavex ) this % wk_3d (:, j , k ) = this % workhatx end do end do do k = 1 , this % nz do i = 1 , this % nx this % workhaty = this % wk_3d ( i ,:, k ) call zfftf ( this % ny , this % workhaty , this % wsavey ) this % wk_3d ( i ,:, k ) = this % workhaty end do end do do j = 1 , this % ny do i = 1 , this % nx this % workhatz = this % wk_3d ( i , j ,:) call zfftf ( this % nz , this % workhatz , this % wsavez ) this % wk_3d ( i , j ,:) = this % workhatz end do end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftf","tags":"","loc":"proc/fftf~2.html","title":"fftf – LibPFASST"},{"text":"public subroutine fftb(this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Calls proc~~fftb~2~~CallsGraph proc~fftb~2 fftb proc~zfftb ZFFTB proc~fftb~2->proc~zfftb proc~pf_stop pf_stop proc~fftb~2->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fftb~2~~CalledByGraph proc~fftb~2 fftb proc~conv_3d~2 conv_3d proc~conv_3d~2->proc~fftb~2 proc~conv_2d~2 conv_2d proc~conv_2d~2->proc~fftb~2 proc~conv_1d~2 conv_1d proc~conv_1d~2->proc~fftb~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fftb Source Code subroutine fftb ( this ) class ( pf_fft_t ), intent ( inout ) :: this integer i , j , k select case ( this % dim ) case ( 1 ) this % wk_1d = this % wk_1d / this % normfact call zfftb ( this % nx , this % wk_1d , this % wsavex ) case ( 2 ) this % wk_2d = this % wk_2d / this % normfact do j = 1 , this % ny this % workhatx = this % wk_2d (:, j ) call zfftb ( this % nx , this % workhatx , this % wsavex ) this % wk_2d (:, j ) = this % workhatx end do do i = 1 , this % nx this % workhaty = this % wk_2d ( i ,:) call zfftb ( this % ny , this % workhaty , this % wsavey ) this % wk_2d ( i ,:) = this % workhaty end do case ( 3 ) this % wk_3d = this % wk_3d / this % normfact do k = 1 , this % nz do j = 1 , this % ny this % workhatx = this % wk_3d (:, j , k ) call zfftb ( this % nx , this % workhatx , this % wsavex ) this % wk_3d (:, j , k ) = this % workhatx end do end do do k = 1 , this % nz do i = 1 , this % nx this % workhaty = this % wk_3d ( i ,:, k ) call zfftb ( this % ny , this % workhaty , this % wsavey ) this % wk_3d ( i ,:, k ) = this % workhaty end do end do do j = 1 , this % ny do i = 1 , this % nx this % workhatz = this % wk_3d ( i , j ,:) call zfftb ( this % nz , this % workhatz , this % wsavez ) this % wk_3d ( i , j ,:) = this % workhatz end do end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % dim ) end select end subroutine fftb","tags":"","loc":"proc/fftb~2.html","title":"fftb – LibPFASST"},{"text":"public subroutine conv_1d(this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) Calls proc~~conv_1d~2~~CallsGraph proc~conv_1d~2 conv_1d proc~fftf~2 fftf proc~conv_1d~2->proc~fftf~2 proc~fftb~2 fftb proc~conv_1d~2->proc~fftb~2 proc~pf_stop pf_stop proc~fftf~2->proc~pf_stop proc~zfftf ZFFTF proc~fftf~2->proc~zfftf proc~zfftb ZFFTB proc~fftb~2->proc~zfftb proc~fftb~2->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code conv_1d Source Code subroutine conv_1d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:) ! Compute Convolution call fftf ( this ) this % wk_1d = this % wk_1d * g call fftb ( this ) end subroutine conv_1d","tags":"","loc":"proc/conv_1d~2.html","title":"conv_1d – LibPFASST"},{"text":"public subroutine conv_2d(this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) Calls proc~~conv_2d~2~~CallsGraph proc~conv_2d~2 conv_2d proc~fftf~2 fftf proc~conv_2d~2->proc~fftf~2 proc~fftb~2 fftb proc~conv_2d~2->proc~fftb~2 proc~pf_stop pf_stop proc~fftf~2->proc~pf_stop proc~zfftf ZFFTF proc~fftf~2->proc~zfftf proc~zfftb ZFFTB proc~fftb~2->proc~zfftb proc~fftb~2->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code conv_2d Source Code subroutine conv_2d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:) ! Compute Convolution call fftf ( this ) this % wk_2d = this % wk_2d * g call fftb ( this ) end subroutine conv_2d","tags":"","loc":"proc/conv_2d~2.html","title":"conv_2d – LibPFASST"},{"text":"public subroutine conv_3d(this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) Calls proc~~conv_3d~2~~CallsGraph proc~conv_3d~2 conv_3d proc~fftf~2 fftf proc~conv_3d~2->proc~fftf~2 proc~fftb~2 fftb proc~conv_3d~2->proc~fftb~2 proc~pf_stop pf_stop proc~fftf~2->proc~pf_stop proc~zfftf ZFFTF proc~fftf~2->proc~zfftf proc~zfftb ZFFTB proc~fftb~2->proc~zfftb proc~fftb~2->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code conv_3d Source Code subroutine conv_3d ( this , g ) ! Variable Types class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( in ) :: g (:,:,:) ! Compute Convolution call fftf ( this ) this % wk_3d = this % wk_3d * g call fftb ( this ) end subroutine conv_3d","tags":"","loc":"proc/conv_3d~2.html","title":"conv_3d – LibPFASST"},{"text":"public subroutine make_lap_1d(this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) Contents Source Code make_lap_1d Source Code subroutine make_lap_1d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:) integer :: i , nx real ( pfdp ) :: kx , Lx nx = this % nx Lx = this % Lx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i ) = - kx ** 2 end do end subroutine make_lap_1d","tags":"","loc":"proc/make_lap_1d~2.html","title":"make_lap_1d – LibPFASST"},{"text":"public subroutine make_deriv_1d(this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) Contents Source Code make_deriv_1d Source Code subroutine make_deriv_1d ( this , ddx ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: ddx (:) integer :: i , nx real ( pfdp ) :: kx , Lx nx = this % nx Lx = this % Lx do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if ddx ( i ) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do end subroutine make_deriv_1d","tags":"","loc":"proc/make_deriv_1d~2.html","title":"make_deriv_1d – LibPFASST"},{"text":"public subroutine make_lap_2d(this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) Contents Source Code make_lap_2d Source Code subroutine make_lap_2d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:) integer :: i , j , nx , ny real ( pfdp ) :: kx , ky , Lx , Ly nx = this % nx ny = this % ny Lx = this % Lx Ly = this % Ly do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i , j ) = - ( kx ** 2 + ky ** 2 ) end do end do end subroutine make_lap_2d","tags":"","loc":"proc/make_lap_2d~2.html","title":"make_lap_2d – LibPFASST"},{"text":"public subroutine make_deriv_2d(this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir Contents Source Code make_deriv_2d Source Code subroutine make_deriv_2d ( this , deriv , dir ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:) integer , intent ( in ) :: dir integer :: i , j , nx , ny real ( pfdp ) :: kx , ky , Lx , Ly nx = this % nx ny = this % ny Lx = this % Lx Ly = this % Ly do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if if ( dir . eq . 1 ) then deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * kx else deriv ( i , j ) = ( 0.0_pfdp , 1.0_pfdp ) * ky endif end do end do end subroutine make_deriv_2d","tags":"","loc":"proc/make_deriv_2d~2.html","title":"make_deriv_2d – LibPFASST"},{"text":"public subroutine make_lap_3d(this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) Contents Source Code make_lap_3d Source Code subroutine make_lap_3d ( this , lap ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: lap (:,:,:) integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz , Lx , Ly , Lz nx = this % nx ny = this % ny nz = this % nz Lx = this % Lx Ly = this % Ly Lz = this % Lz do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / Lz * dble ( k - 1 ) else kz = two_pi / Ly * dble ( - nz + k - 1 ) end if do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if lap ( i , j , k ) = - ( kx ** 2 + ky ** 2 + kz ** 2 ) end do end do end do end subroutine make_lap_3d","tags":"","loc":"proc/make_lap_3d~2.html","title":"make_lap_3d – LibPFASST"},{"text":"public subroutine make_deriv_3d(this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir Calls proc~~make_deriv_3d~2~~CallsGraph proc~make_deriv_3d~2 make_deriv_3d proc~pf_stop pf_stop proc~make_deriv_3d~2->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code make_deriv_3d Source Code subroutine make_deriv_3d ( this , deriv , dir ) class ( pf_fft_t ), intent ( inout ) :: this complex ( pfdp ), intent ( inout ) :: deriv (:,:,:) integer , intent ( in ) :: dir integer :: i , j , k , nx , ny , nz real ( pfdp ) :: kx , ky , kz , Lx , Ly , Lz nx = this % nx ny = this % ny nz = this % nz Lx = this % Lx Ly = this % Ly Lz = this % Lz select case ( dir ) case ( 1 ) do i = 1 , nx if ( i <= nx / 2 + 1 ) then kx = two_pi / Lx * dble ( i - 1 ) else kx = two_pi / Lx * dble ( - nx + i - 1 ) end if deriv ( i ,:,:) = ( 0.0_pfdp , 1.0_pfdp ) * kx end do case ( 2 ) do j = 1 , ny if ( j <= ny / 2 + 1 ) then ky = two_pi / Ly * dble ( j - 1 ) else ky = two_pi / Ly * dble ( - ny + j - 1 ) end if deriv (:, j ,:) = ( 0.0_pfdp , 1.0_pfdp ) * ky end do case ( 3 ) do k = 1 , nz if ( k <= nz / 2 + 1 ) then kz = two_pi / Lz * dble ( k - 1 ) else kz = two_pi / Ly * dble ( - nz + k - 1 ) end if deriv (:,:, k ) = ( 0.0_pfdp , 1.0_pfdp ) * kz end do case DEFAULT call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , dir ) end select end subroutine make_deriv_3d","tags":"","loc":"proc/make_deriv_3d~2.html","title":"make_deriv_3d – LibPFASST"},{"text":"public function zndsysarray_norm(this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) Contents Source Code zndsysarray_norm Source Code function zndsysarray_norm ( this , flags ) result ( norm ) class ( zndsysarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function zndsysarray_norm","tags":"","loc":"proc/zndsysarray_norm.html","title":"zndsysarray_norm – LibPFASST"},{"text":"public function cast_as_zndsysarray(encap_polymorph) result(zndsysarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( zndsysarray ),\n  pointer Called by proc~~cast_as_zndsysarray~~CalledByGraph proc~cast_as_zndsysarray cast_as_zndsysarray proc~zndsysarray_destroy zndsysarray_destroy proc~zndsysarray_destroy->proc~cast_as_zndsysarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cast_as_zndsysarray Source Code function cast_as_zndsysarray ( encap_polymorph ) result ( zndsysarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( zndsysarray ), pointer :: zndsysarray_obj select type ( encap_polymorph ) type is ( zndsysarray ) zndsysarray_obj => encap_polymorph end select end function cast_as_zndsysarray","tags":"","loc":"proc/cast_as_zndsysarray.html","title":"cast_as_zndsysarray – LibPFASST"},{"text":"public function get_array1d(x, n, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:) Contents Source Code get_array1d Source Code function get_array1d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:) select type ( x ) type is ( zndsysarray ) r => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array1d","tags":"","loc":"proc/get_array1d~2.html","title":"get_array1d – LibPFASST"},{"text":"public function get_array2d(x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_array2d Source Code function get_array2d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( zndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array2d","tags":"","loc":"proc/get_array2d~2.html","title":"get_array2d – LibPFASST"},{"text":"public function get_array3d(x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_array3d Source Code function get_array3d ( x , n , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ) :: n integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( zndsysarray ) r ( 1 : x % arr_shape ( 1 ), 1 : x % arr_shape ( 2 ), 1 : x % arr_shape ( 3 )) => x % flatarray ( x % ndof * ( n - 1 ) + 1 : x % ndof * n ) end select end function get_array3d","tags":"","loc":"proc/get_array3d~2.html","title":"get_array3d – LibPFASST"},{"text":"public subroutine zndsysarray_build(q, arr_shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: arr_shape (:) Called by proc~~zndsysarray_build~~CalledByGraph proc~zndsysarray_build zndsysarray_build proc~zndsysarray_create_single zndsysarray_create_single proc~zndsysarray_create_single->proc~zndsysarray_build Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code zndsysarray_build Source Code subroutine zndsysarray_build ( q , arr_shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: arr_shape (:) select type ( q ) class is ( zndsysarray ) allocate ( q % arr_shape ( size ( arr_shape ))) q % dim = size ( arr_shape ) - 1 q % ncomp = arr_shape ( q % dim + 1 ) q % ndof = product ( arr_shape ( 1 : q % dim )) q % arr_shape = arr_shape allocate ( q % flatarray ( product ( arr_shape ))) end select end subroutine zndsysarray_build","tags":"","loc":"proc/zndsysarray_build.html","title":"zndsysarray_build – LibPFASST"},{"text":"public subroutine zndsysarray_create_single(this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Calls proc~~zndsysarray_create_single~~CallsGraph proc~zndsysarray_create_single zndsysarray_create_single proc~zndsysarray_build zndsysarray_build proc~zndsysarray_create_single->proc~zndsysarray_build Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code zndsysarray_create_single Source Code subroutine zndsysarray_create_single ( this , x , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) integer :: i allocate ( zndsysarray :: x ) call zndsysarray_build ( x , shape ) end subroutine zndsysarray_create_single","tags":"","loc":"proc/zndsysarray_create_single.html","title":"zndsysarray_create_single – LibPFASST"},{"text":"public subroutine zndsysarray_create_array(this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code zndsysarray_create_array Source Code subroutine zndsysarray_create_array ( this , x , n , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( zndsysarray :: x ( n )) do i = 1 , n call zndsysarray_build ( x ( i ), shape ) end do end subroutine zndsysarray_create_array","tags":"","loc":"proc/zndsysarray_create_array.html","title":"zndsysarray_create_array – LibPFASST"},{"text":"public subroutine zndsysarray_destroy(encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap Calls proc~~zndsysarray_destroy~~CallsGraph proc~zndsysarray_destroy zndsysarray_destroy proc~cast_as_zndsysarray cast_as_zndsysarray proc~zndsysarray_destroy->proc~cast_as_zndsysarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code zndsysarray_destroy Source Code subroutine zndsysarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( zndsysarray ), pointer :: zndsysarray_obj zndsysarray_obj => cast_as_zndsysarray ( encap ) deallocate ( zndsysarray_obj % arr_shape ) deallocate ( zndsysarray_obj % flatarray ) nullify ( zndsysarray_obj ) end subroutine zndsysarray_destroy","tags":"","loc":"proc/zndsysarray_destroy.html","title":"zndsysarray_destroy – LibPFASST"},{"text":"public subroutine zndsysarray_destroy_single(this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code zndsysarray_destroy_single Source Code subroutine zndsysarray_destroy_single ( this , x , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) select type ( x ) class is ( zndsysarray ) deallocate ( x % arr_shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine zndsysarray_destroy_single","tags":"","loc":"proc/zndsysarray_destroy_single.html","title":"zndsysarray_destroy_single – LibPFASST"},{"text":"public subroutine zndsysarray_destroy_array(this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code zndsysarray_destroy_array Source Code subroutine zndsysarray_destroy_array ( this , x , n , level , shape ) class ( zndsysarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i select type ( x ) class is ( zndsysarray ) do i = 1 , n deallocate ( x ( i )% arr_shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine zndsysarray_destroy_array","tags":"","loc":"proc/zndsysarray_destroy_array.html","title":"zndsysarray_destroy_array – LibPFASST"},{"text":"public subroutine zndsysarray_setval(this, val, flags) The following are the base subroutines that all encapsulations must provide Subroutine to set array to a scalare  value. Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags Contents Source Code zndsysarray_setval Source Code subroutine zndsysarray_setval ( this , val , flags ) class ( zndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine zndsysarray_setval","tags":"","loc":"proc/zndsysarray_setval.html","title":"zndsysarray_setval – LibPFASST"},{"text":"public subroutine zndsysarray_copy(this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags Contents Source Code zndsysarray_copy Source Code subroutine zndsysarray_copy ( this , src , flags ) class ( zndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( zndsysarray ) this % flatarray = src % flatarray class default stop \"TYPE ERROR\" end select end subroutine zndsysarray_copy","tags":"","loc":"proc/zndsysarray_copy.html","title":"zndsysarray_copy – LibPFASST"},{"text":"public subroutine zndsysarray_pack(this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags Contents Source Code zndsysarray_pack Source Code subroutine zndsysarray_pack ( this , z , flags ) class ( zndsysarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: ntot ntot = this % ndof * this % ncomp z ( 1 : ntot ) = real ( this % flatarray , pfdp ) z ( ntot + 1 : 2 * ntot ) = aimag ( this % flatarray ) end subroutine zndsysarray_pack","tags":"","loc":"proc/zndsysarray_pack.html","title":"zndsysarray_pack – LibPFASST"},{"text":"public subroutine zndsysarray_unpack(this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags Contents Source Code zndsysarray_unpack Source Code subroutine zndsysarray_unpack ( this , z , flags ) class ( zndsysarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: ntot ntot = this % ndof * this % ncomp this % flatarray = z ( 1 : ntot ) this % flatarray = this % flatarray + cmplx ( 0.0 , 1.0 , pfdp ) * z ( ntot + 1 : 2 * ntot ) this % flatarray = cmplx ( z ( 1 : ntot ), z ( ntot + 1 : 2 * ntot )) end subroutine zndsysarray_unpack","tags":"","loc":"proc/zndsysarray_unpack.html","title":"zndsysarray_unpack – LibPFASST"},{"text":"public subroutine zndsysarray_axpy(this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Contents Source Code zndsysarray_axpy Source Code subroutine zndsysarray_axpy ( this , a , x , flags ) class ( zndsysarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( zndsysarray ) this % flatarray = a * x % flatarray + this % flatarray class default stop \"TYPE ERROR\" end select end subroutine zndsysarray_axpy","tags":"","loc":"proc/zndsysarray_axpy.html","title":"zndsysarray_axpy – LibPFASST"},{"text":"public subroutine zndsysarray_eprint(this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags Contents Source Code zndsysarray_eprint Source Code subroutine zndsysarray_eprint ( this , flags ) class ( zndsysarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % flatarray ( 1 : 10 ) !print *, this%flatarray end subroutine zndsysarray_eprint","tags":"","loc":"proc/zndsysarray_eprint.html","title":"zndsysarray_eprint – LibPFASST"},{"text":"interface Interfaces to output routines in pf_numpy.c public subroutine zndsysarray_mkdir(dname, dlen) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname integer, intent(in), value :: dlen Description Subroutine to make a directory for output","tags":"","loc":"interface/zndsysarray_mkdir.html","title":"zndsysarray_mkdir – LibPFASST"},{"text":"interface Interfaces to output routines in pf_numpy.c public subroutine zndsysarray_dump_numpy(dname, fname, endian, dim, mpibuflen, arr_shape, array) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: arr_shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Description Subroutine to write an the array to a file","tags":"","loc":"interface/zndsysarray_dump_numpy.html","title":"zndsysarray_dump_numpy – LibPFASST"},{"text":"public subroutine exp_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code exp_initialize Source Code subroutine exp_initialize ( this , lev ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev ! local variables integer :: i , nnodes real ( pfdp ), allocatable :: q (:) nnodes = lev % nnodes allocate ( this % eta ( nnodes - 1 )) allocate ( this % nodes ( nnodes )) allocate ( q ( nnodes )) ! set nodes and substeps this % nodes = lev % sdcmats % qnodes this % eta = this % nodes ( 2 : nnodes ) - this % nodes ( 1 : nnodes - 1 ) ! substeps ! compute weights allocate ( this % w ( nnodes - 1 , nnodes , nnodes )) do i = 1 , nnodes - 1 q = this % nodes - this % nodes ( i ); call weights ( this , real ( 0.0 , pfdp ), q , nnodes - 1 , this % W ( i , :, :)); end do ! set number of rhs components this % npieces = 1 ! initialize temporary storage objects call lev % ulevel % factory % create_single ( this % newF , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % b , nnodes + 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % f_old , nnodes , lev % index , lev % shape ) end subroutine exp_initialize","tags":"","loc":"proc/exp_initialize.html","title":"exp_initialize – LibPFASST"},{"text":"public subroutine exp_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks proc~~exp_sweep~~UsesGraph proc~exp_sweep exp_sweep module~pf_mod_hooks pf_mod_hooks proc~exp_sweep->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~exp_sweep->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. $              !  Now we have to add in the tauQ\n$ Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Calls proc~~exp_sweep~~CallsGraph proc~exp_sweep exp_sweep proc~call_hooks call_hooks proc~exp_sweep->proc~call_hooks proc~localderivsatnode LocalDerivsAtNode proc~exp_sweep->proc~localderivsatnode proc~pf_residual pf_residual proc~exp_sweep->proc~pf_residual proc~start_timer start_timer proc~call_hooks->proc~start_timer proc~end_timer end_timer proc~call_hooks->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code exp_sweep Source Code subroutine exp_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags ! local variables class ( pf_level_t ), pointer :: lev integer :: m , nnodes , j , k real ( pfdp ) :: t lev => pf % levels ( level_index ) nnodes = lev % nnodes call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) ! compute F_j&#94;{[k+1]} ! error sweeps do k = 1 , nsweeps call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! NOTE: ensure that lev%F has been properly initialized here do j = 1 , nnodes call this % f_old ( j )% copy ( lev % F ( j , 1 )) ! Save old f end do t = t0 do j = 1 , nnodes - 1 t = t0 + dt * this % eta ( j ) ! form b vectors !              call LocalDerivsAtNode(this, j, nnodes, lev%F(:,1), this%b(2:nnodes+1))  ! phi expansion for exponential picard integral call LocalDerivsAtNode ( this , j , nnodes , this % f_old (:), this % b ( 2 : nnodes + 1 )) ! phi expansion for exponential picard integral call this % b ( 1 )% copy ( lev % Q ( j )) ! add term \\phi_0(tL) y_n if ( j > 1 ) then ! add term \\phi_1(tL) (F_j&#94;{[k+1]} - F_j&#94;{[k]}) call this % b ( 2 )% axpy ( real ( - 1.0 , pfdp ), this % f_old ( j )) ! add -\\phi_1(tL) F_j&#94;{[k]} endif call this % f_eval ( lev % Q ( j ), t , lev % index , lev % F ( j , 1 )) ! compute F_j&#94;{[k+1]} if ( j > 1 ) then ! add term \\phi_1(tL) (F_j&#94;{[k+1]} - F_j&#94;{[k]}) call this % b ( 2 )% axpy ( real ( 1.0 , pfdp ), lev % F ( j , 1 )) ! add \\phi_1(tL) F_j&#94;{[k+1]} end if ! compute phi products if ( this % use_phib ) then call this % phib ( this % eta ( j ), dt , this % b , lev % Q ( j + 1 )) else call this % swpPhib ( j , dt , this % b , lev % Q ( j + 1 )) end if !!$              !  Now we have to add in the tauQ if ( allocated ( lev % tauQ )) then call lev % Q ( j + 1 )% axpy ( 1.0_pfdp , lev % tauQ ( j )) if ( j > 1 ) then ! The tau is not node to node !                    call lev%Q(j+1)%axpy(-1.0_pfdp, lev%tauQ(j-1)) end if end if !!$ end do call this % f_eval ( lev % Q ( nnodes ), t0 + dt , lev % index , lev % F ( nnodes , 1 )) ! eval last nonlinear term call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do end subroutine exp_sweep","tags":"","loc":"proc/exp_sweep.html","title":"exp_sweep – LibPFASST"},{"text":"public subroutine exp_integrate(this, lev, qSDC, fSDC, dt, fintsdc, flags) $        call LocalDerivsAtNode(this, 1, nnodes, fSDC(:,1), this%b(2:nnodes+1)) ! compute derivatives\n$        call this%b(1)%setval(real(0.0, pfdp))\n$        call this%b(1)%axpy(real(1.0, pfdp), qSDC(1))\n$        do i = 1, nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}}\n$            if (this%use_phib) then\n$                call this%phib(this%nodes(i+1), dt, this%b, fintsdc(i))\n$            else\n$                call this%resPhib(i, dt, this%b, fintsdc(i))\n$             end if\n$        end do Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintsdc (:) Integral from t_n to t_m integer, intent(in), optional :: flags Contents Source Code exp_integrate Source Code subroutine exp_integrate ( this , lev , qSDC , fSDC , dt , fintsdc , flags ) ! parameters class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev !!  Current level class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintsdc (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags ! local variables integer :: i , nnodes nnodes = lev % nnodes !!$        call LocalDerivsAtNode(this, 1, nnodes, fSDC(:,1), this%b(2:nnodes+1)) ! compute derivatives !!$        call this%b(1)%setval(real(0.0, pfdp)) !!$        call this%b(1)%axpy(real(1.0, pfdp), qSDC(1)) !!$        do i = 1, nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}} !!$            if (this%use_phib) then !!$                call this%phib(this%nodes(i+1), dt, this%b, fintsdc(i)) !!$            else !!$                call this%resPhib(i, dt, this%b, fintsdc(i)) !!$             end if !!$        end do do i = 1 , nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}} call LocalDerivsAtNode ( this , i , nnodes , fSDC (:, 1 ), this % b ( 2 : nnodes + 1 )) ! compute derivatives call this % b ( 1 )% copy ( qSDC ( i )) call fintsdc ( i )% setval ( 0.0_pfdp ) if ( this % use_phib ) then call this % phib ( this % eta ( i ), dt , this % b , fintsdc ( i )) else call this % resPhib ( i , dt , this % b , fintsdc ( i )) end if !             if (i > 1) then !                call fintsdc(i)%axpy(1.0_pfdp,fintsdc(i-1)) !             end if !             print *,'integrating',i,this%nodes(i+1),dt,this%eta(i) !          call fintsdc(i)%eprint() end do !        do i = 1, nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}} !             call fintsdc(i)%axpy(-1.0_pfdp,qSDC(1)) !        end do !             print *,'integrating',i,this%nodes(i+1),dt,this%eta(i) !          call fintsdc(i)%eprint() end subroutine exp_integrate","tags":"","loc":"proc/exp_integrate.html","title":"exp_integrate – LibPFASST"},{"text":"public subroutine exp_residual(this, lev, dt, flags) Compute the integral of F from t_n to t_m at each node add tau if it exists\n subtract out the solution value Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags Contents Source Code exp_residual Source Code subroutine exp_residual ( this , lev , dt , flags ) class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags integer :: m !>  Compute the integral of F from t_n to t_m at each node call lev % ulevel % sweeper % integrate ( lev , lev % Q , lev % F , dt , lev % I , flags ) !> add tau if it exists if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) if ( m > 1 ) then !     call lev%I(m)%axpy(-1.0_pfdp, lev%tauQ(m-1), flags) end if end do end if !> subtract out the solution value do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) !           call lev%R(m)%axpy(1.0_pfdp, lev%Q(1)) end do end subroutine exp_residual","tags":"","loc":"proc/exp_residual.html","title":"exp_residual – LibPFASST"},{"text":"public subroutine exp_spreadq0(this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~exp_spreadq0~~CallsGraph proc~exp_spreadq0 exp_spreadq0 proc~pf_generic_spreadq0 pf_generic_spreadq0 proc~exp_spreadq0->proc~pf_generic_spreadq0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code exp_spreadq0 Source Code subroutine exp_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine exp_spreadq0","tags":"","loc":"proc/exp_spreadq0.html","title":"exp_spreadq0 – LibPFASST"},{"text":"public subroutine exp_evaluate(this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code exp_evaluate Source Code subroutine exp_evaluate ( this , lev , t , m , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine exp_evaluate","tags":"","loc":"proc/exp_evaluate.html","title":"exp_evaluate – LibPFASST"},{"text":"public subroutine exp_evaluate_all(this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~exp_evaluate_all~~CallsGraph proc~exp_evaluate_all exp_evaluate_all proc~pf_generic_evaluate_all pf_generic_evaluate_all proc~exp_evaluate_all->proc~pf_generic_evaluate_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code exp_evaluate_all Source Code subroutine exp_evaluate_all ( this , lev , t , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine exp_evaluate_all","tags":"","loc":"proc/exp_evaluate_all.html","title":"exp_evaluate_all – LibPFASST"},{"text":"public subroutine exp_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level Contents Source Code exp_destroy Source Code subroutine exp_destroy ( this , lev ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level deallocate ( this % w ) deallocate ( this % eta ) deallocate ( this % newF ) call lev % ulevel % factory % destroy_array ( this % b , lev % index , lev % nnodes , lev % shape ) call lev % ulevel % factory % destroy_array ( this % f_old , lev % index , lev % nnodes , lev % shape ) end subroutine exp_destroy","tags":"","loc":"proc/exp_destroy.html","title":"exp_destroy – LibPFASST"},{"text":"public subroutine LocalDerivsAtNode(this, i, nnodes, N_eval, N_deriv) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: nnodes class( pf_encap_t ), intent(in) :: N_eval (:) class( pf_encap_t ), intent(inout) :: N_deriv (:) Called by proc~~localderivsatnode~~CalledByGraph proc~localderivsatnode LocalDerivsAtNode proc~exp_sweep exp_sweep proc~exp_sweep->proc~localderivsatnode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/localderivsatnode.html","title":"LocalDerivsAtNode – LibPFASST"},{"text":"public subroutine weights(this, z, x, m, W) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z real(kind=pfdp), intent(in) :: x (:) integer, intent(in) :: m real(kind=pfdp), intent(out) :: W (size(x),m+1) Contents Source Code weights Source Code subroutine weights ( this , z , x , m , W ) ! Arguments class ( pf_exp_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z real ( pfdp ), intent ( in ) :: x (:) integer , intent ( in ) :: m real ( pfdp ), intent ( out ) :: W ( size ( x ), m + 1 ) ! Variable Declarations real ( pfdp ) :: c1 , c2 , c3 , c4 , c5 integer :: i , j , k , n , mn c1 = 1.0_pfdp c4 = x ( 1 ) - z W = 0.0_pfdp W ( 1 , 1 ) = 1.0_pfdp n = size ( x ) do i = 2 , n mn = min ( i , m + 1 ) c2 = 1.0_pfdp c5 = c4 c4 = x ( i ) - z do j = 1 , i - 1 c3 = x ( i ) - x ( j ) c2 = c2 * c3 ; if ( j == i - 1 ) then do k = mn , 2 , - 1 W ( i , k ) = c1 * ( real ( k - 1 , pfdp ) * W ( i - 1 , k - 1 ) - c5 * W ( i - 1 , k )) / c2 ; enddo W ( i , 1 ) = - c1 * c5 * W ( i - 1 , 1 ) / c2 ; endif do k = mn , 2 , - 1 W ( j , k ) = ( c4 * W ( j , k ) - real ( k - 1 , pfdp ) * W ( j , k - 1 )) / c3 ; enddo W ( j , 1 ) = c4 * W ( j , 1 ) / c3 ; enddo c1 = c2 ; enddo end subroutine weights","tags":"","loc":"proc/weights.html","title":"weights – LibPFASST"},{"text":"interface public subroutine pf_phib(this, t, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y","tags":"","loc":"interface/pf_phib.html","title":"pf_phib – LibPFASST"},{"text":"interface public subroutine pf_swpPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y","tags":"","loc":"interface/pf_swpphib.html","title":"pf_swpPhib – LibPFASST"},{"text":"interface public subroutine pf_resPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y","tags":"","loc":"interface/pf_resphib.html","title":"pf_resPhib – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level, n) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: n","tags":"","loc":"interface/pf_f_eval_p.html","title":"pf_f_eval_p – LibPFASST"},{"text":"public subroutine verlet_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks proc~~verlet_sweep~~UsesGraph proc~verlet_sweep verlet_sweep module~pf_mod_hooks pf_mod_hooks proc~verlet_sweep->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~verlet_sweep->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Perform one SDC sweep on level lev_index and set qend appropriately\n  Assign level pointer\n  Add the integral term Add the starting value Add the dt*v_0 End substep loop Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Calls proc~~verlet_sweep~~CallsGraph proc~verlet_sweep verlet_sweep proc~call_hooks call_hooks proc~verlet_sweep->proc~call_hooks proc~pf_residual pf_residual proc~verlet_sweep->proc~pf_residual proc~start_timer start_timer proc~verlet_sweep->proc~start_timer proc~end_timer end_timer proc~verlet_sweep->proc~end_timer proc~call_hooks->proc~start_timer proc~call_hooks->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code verlet_sweep Source Code subroutine verlet_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_verlet_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: k , m , n , nnodes real ( pfdp ) :: t , dtmhalf , dtsq real ( pfdp ) :: H lev => pf % levels ( level_index ) !!  Assign level pointer nnodes = lev % nnodes call start_timer ( pf , TLEVEL + lev % index - 1 ) ! ! check hamiltonian ! !    call this%hamiltonian(t0+dt, Lev%qend, encapctx%m,H) !    print *,'Ham=',H,this%Htol,this%H0 !    if ((pf%state%iter > 1) .and. (abs(H-this%H0) < this%Htol)) then !       call Lev%encap%copy(Lev%qend, Lev%Q(nnodes)) !          print *, 'Skipping SDC sweep' !       return !    end if ! ! compute integrals and add fas correction ! dtsq = dt * dt do k = 1 , nsweeps do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) if ( pf % state % iter . eq . 1 ) then !  Do verlet on the first iteration do n = 1 , nnodes call lev % I ( m )% axpy ( dt * this % DQver ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dtsq * this % DQQver ( m , n ), lev % F ( n , 1 ), 2 ) end do else do n = 1 , nnodes call lev % I ( m )% axpy ( dt * this % DQtil ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dtsq * this % DQQtil ( m , n ), lev % F ( n , 1 ), 2 ) end do end if if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) end if t = t0 ! do the sub-stepping in sweep do m = 1 , nnodes - 1 t = t + dt * this % dtsdc ( m ) dtmhalf = 0.5d0 * dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp ) !  Lower triangular verlet to  new piece if ( pf % state % iter . eq . 1 ) then do n = 1 , m call this % rhs % axpy ( dtsq * this % QQver ( m , n ), lev % F ( n , 1 ), 2 ) end do else do n = 1 , m call this % rhs % axpy ( dtsq * this % QQtil ( m , n ), lev % F ( n , 1 ), 2 ) end do endif !>  Add the integral term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) !>  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 2 ) !>  Add the dt*v_0 call this % rhs % axpy ( t - t0 , lev % Q ( 1 ), 12 ) !  Update position term call lev % Q ( m + 1 )% copy ( this % rhs , 2 ) !  update function values call this % f_eval ( Lev % Q ( m + 1 ), t , lev % index , Lev % F ( m + 1 , 1 )) !  Now do the v peice call this % rhs % setval ( 0.0_pfdp , 1 ) !  Lower triangular verlet to  new piece if ( pf % state % iter . eq . 1 ) then do n = 1 , m + 1 call this % rhs % axpy ( dt * this % Qver ( m , n ), Lev % F ( n , 1 ), 1 ) end do else do n = 1 , m + 1 call this % rhs % axpy ( dt * this % Qtil ( m , n ), Lev % F ( n , 1 ), 1 ) end do end if call this % rhs % axpy ( 1.0_pfdp , Lev % I ( m ), 1 ); call this % rhs % axpy ( 1.0_pfdp , Lev % Q ( 1 ), 1 ) !  Start m+1 with value from 1 call lev % Q ( m + 1 )% copy ( this % rhs , 1 ) end do !!  End substep loop !  Set the value of qend !  If Gauss nodes, we must do integration !  unless the sweep was an initial Verlet !  For Lobatto nodes, we have a choice of whether to just use the !  value at the last node, or recompute it. !       if (this%iqend .and. pf%state%iter .gt. 1) then !          call Lev%encap%copy(Lev%qend, Lev%Q(1)) !          call Lev%encap%axpy(Lev%qend, dt, Lev%Q(1), 12)  !  Add the dt*v_0 term !          m = nnodes !          do n = 1, nnodes !             call Lev%encap%axpy(Lev%qend, dt*this%Qmat(m,n), Lev%F(n,1),1) !             call Lev%encap%axpy(Lev%qend, dtsq*this%QQmat(m,n), Lev%F(n,1),2) !          end do !          if (associated(Lev%tauQ)) then !             call Lev%encap%axpy(Lev%qend, 1.0_pfdp, Lev%tauQ(nnodes-1)) !             !          print *,'XXXXXXXXXXX  need code in verlet.f90' !          end if !       else !          call Lev%encap%copy(Lev%qend, Lev%Q(nnodes)) !       end if call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! end loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine verlet_sweep","tags":"","loc":"proc/verlet_sweep.html","title":"verlet_sweep – LibPFASST"},{"text":"public subroutine verlet_initialize(this, lev) Initialize integration matrices\n  Array of substep sizes\n$       do i = 1,nnodes\n$          do j = 1,nnodes\n$             this%QQmat(i,j) =  this%bvec(j)*(1.0_pfdp-this%Qmat(j,i)/this%bvec(i))\n$          end do\n$       end do\n$       this%QQmat = matmul(this%QQmat,this%Qmat)\n  Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Calls proc~~verlet_initialize~~CallsGraph proc~verlet_initialize verlet_initialize proc~pf_stop pf_stop proc~verlet_initialize->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code verlet_initialize Source Code subroutine verlet_initialize ( this , lev ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev integer :: i , j , nnodes , ierr real ( pfdp ), allocatable :: qtemp (:,:) real ( pfdp ), allocatable :: qtemp2 (:,:) this % npieces = 1 nnodes = Lev % nnodes allocate ( this % Qmat ( nnodes - 1 , nnodes ), stat = ierr ) !  0  to node integral if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qmat\" allocate ( this % QQmat ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node double integral (like Qmat*Qmat) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQmat\" allocate ( this % Qtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0  to node integral  approximation of Qmat if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qtil\" allocate ( this % QQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node QQmat  aproximation if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQtil\" allocate ( this % Qver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node verlet  aproximation (trap) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for Qver\" allocate ( this % QQver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node verlet  aproximation if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for QQver\" allocate ( this % DQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node Qmat-Qtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQtil\" allocate ( this % DQQtil ( nnodes - 1 , nnodes ), stat = ierr ) !  node to node QQmat-QQtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQQtil\" allocate ( this % DQver ( nnodes - 1 , nnodes ), stat = ierr ) !  0 to node Qmat-Qtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQtil\" allocate ( this % DQQver ( nnodes - 1 , nnodes ), stat = ierr ) !  node to node QQmat-QQtil if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DQQtil\" allocate ( this % bvec ( nnodes ), stat = ierr ) !  Integration rule for v if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DStil\" allocate ( this % bbarvec ( nnodes ), stat = ierr ) !  Integration rule for x if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for DSStil\" allocate ( this % dtsdc ( nnodes - 1 ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for dtsdc\" allocate ( this % tsdc ( nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in verlet_initialize for tsdc\" !>  Array of substep sizes this % dtsdc = lev % sdcmats % qnodes ( 2 : nnodes ) - lev % sdcmats % qnodes ( 1 : nnodes - 1 ) this % tsdc = lev % sdcmats % qnodes - lev % sdcmats % qnodes ( 1 ) !  Build Q from qmat this % Qmat = lev % sdcmats % qmat !   I just use qmat now? !  The quadrature rule is the last row of Q this % bvec = this % Qmat ( nnodes - 1 ,:); allocate ( qtemp ( nnodes , nnodes ), stat = ierr ) allocate ( qtemp2 ( nnodes , nnodes ), stat = ierr ) !  form the QQ matrix depending on what you want select case ( this % whichQQ ) case ( 0 ) !  Collocation (make it the product) print * , 'Making QQ by collocation Q*Q' print * , size ( this % Qmat ) qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = lev % sdcmats % qmat qtemp = matmul ( qtemp , qtemp ) this % QQmat = qtemp ( 2 : nnodes ,:) print * , shape ( this % QQmat ) case ( 1 ) !  Make the pair like in Lobatto A/B pair print * , 'Making QQ by collocation Lobatto pair' qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = this % Qmat qtemp2 = 0.0_pfdp do i = 1 , nnodes do j = 1 , nnodes qtemp2 ( i , j ) = this % bvec ( j ) * ( 1.0_pfdp - qtemp ( j , i ) / this % bvec ( i )) end do end do qtemp2 = matmul ( qtemp , qtemp2 ) this % QQmat = 0.0_pfdp this % QQmat = qtemp2 ( 2 : nnodes ,:) this % bbarvec = this % QQmat ( nnodes - 1 ,:); case ( 2 ) !  Make the pair like in Lobatto B/A pair print * , 'Error Making QQ by collocation Lobatto pair' !!$       do i = 1,nnodes !!$          do j = 1,nnodes !!$             this%QQmat(i,j) =  this%bvec(j)*(1.0_pfdp-this%Qmat(j,i)/this%bvec(i)) !!$          end do !!$       end do !!$       this%QQmat = matmul(this%QQmat,this%Qmat) case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , this % whichQQ ) end select ! 0 to node this % Qver = lev % sdcmats % qmatTrap qtemp = 0.0_pfdp qtemp ( 2 : nnodes ,:) = lev % sdcmats % qmatFE qtemp2 ( 2 : nnodes ,:) = lev % sdcmats % qmatTrap qtemp = matmul ( qtemp , qtemp2 ) this % QQver = qtemp ( 2 : nnodes ,:) + 0.5_pfdp * lev % sdcmats % qmatFE * lev % sdcmats % qmatFE !  Get LU matrices if desired !    if (this%use_LUq .eq. 1) then !       print *,'Doing LU with doLU=',this%doLU !       call myLUq(SDCmats%qmat,SDCmats%qmatLU,nnodes,0) !       call pf_myLUexp(this%QQmat,L,U,nnodes,this%doLU) !      this%QQLU=U !      print *, 'U from LU',this%QQLU !   else this % Qtil = this % Qver !  Normal verlet all the time this % QQtil = this % QQver !  Normal verlet all the time !   end if this % Qver = 0.0d0 !  Normal verlet all the time this % QQver = 0.0d0 !  Normal verlet all the time this % Qtil = this % Qver !  Normal verlet all the time this % QQtil = this % QQver !  Normal verlet all the time ! !  Make differences this % DQtil = this % Qmat - this % Qtil this % DQQtil = this % QQmat - this % QQtil this % DQver = this % Qmat - this % Qver this % DQQver = this % QQmat - this % QQver deallocate ( qtemp ) deallocate ( qtemp2 ) !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine verlet_initialize","tags":"","loc":"proc/verlet_initialize.html","title":"verlet_initialize – LibPFASST"},{"text":"public subroutine verlet_integrate(this, lev, qSDC, fSDC, dt, fintSDC, flags) Integrate (t_n to node) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags Contents Source Code verlet_integrate Source Code subroutine verlet_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev !!  Current level class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags integer :: n , m do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) call fintSDC ( n )% axpy ( dt * this % tsdc ( n + 1 ), qSDC ( 1 ), 12 ) !  Add the dt*v_0 term do m = 1 , lev % nnodes call fintSDC ( n )% axpy ( dt * this % Qmat ( n , m ), fSDC ( m , 1 ), 1 ) call fintSDC ( n )% axpy ( dt * dt * this % QQmat ( n , m ), fSDC ( m , 1 ), 2 ) end do end do end subroutine verlet_integrate","tags":"","loc":"proc/verlet_integrate.html","title":"verlet_integrate – LibPFASST"},{"text":"public subroutine verlet_residual(this, lev, dt, flags) Compute residual (t_n to node) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags Contents Source Code verlet_residual Source Code subroutine verlet_residual ( this , lev , dt , flags ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags integer :: n , m call this % integrate ( lev , lev % Q , lev % F , dt , lev % I , flags ) ! add tau if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end subroutine verlet_residual","tags":"","loc":"proc/verlet_residual.html","title":"verlet_residual – LibPFASST"},{"text":"public subroutine verlet_destroy(this, lev) Destroy Verlet sweeper matrices Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level Contents Source Code verlet_destroy Source Code subroutine verlet_destroy ( this , lev ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level deallocate ( this % Qmat ) deallocate ( this % QQmat ) deallocate ( this % Qtil ) deallocate ( this % QQtil ) deallocate ( this % Qver ) deallocate ( this % QQver ) deallocate ( this % DQtil ) deallocate ( this % DQQtil ) deallocate ( this % DQver ) deallocate ( this % DQQver ) deallocate ( this % bvec ) deallocate ( this % bbarvec ) deallocate ( this % dtsdc ) deallocate ( this % tsdc ) call lev % ulevel % factory % destroy_single ( this % rhs , lev % index , lev % shape ) end subroutine verlet_destroy","tags":"","loc":"proc/verlet_destroy.html","title":"verlet_destroy – LibPFASST"},{"text":"public subroutine verlet_spreadq0(this, lev, t0, flags, step) Spread the intial data for Verlet sweepers Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~verlet_spreadq0~~CallsGraph proc~verlet_spreadq0 verlet_spreadq0 proc~pf_generic_spreadq0 pf_generic_spreadq0 proc~verlet_spreadq0->proc~pf_generic_spreadq0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code verlet_spreadq0 Source Code subroutine verlet_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine verlet_spreadq0","tags":"","loc":"proc/verlet_spreadq0.html","title":"verlet_spreadq0 – LibPFASST"},{"text":"public subroutine verlet_evaluate(this, lev, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code verlet_evaluate Source Code subroutine verlet_evaluate ( this , lev , t , m , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine verlet_evaluate","tags":"","loc":"proc/verlet_evaluate.html","title":"verlet_evaluate – LibPFASST"},{"text":"public subroutine verlet_evaluate_all(this, lev, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~verlet_evaluate_all~~CallsGraph proc~verlet_evaluate_all verlet_evaluate_all proc~pf_generic_evaluate_all pf_generic_evaluate_all proc~verlet_evaluate_all->proc~pf_generic_evaluate_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code verlet_evaluate_all Source Code subroutine verlet_evaluate_all ( this , lev , t , flags , step ) class ( pf_verlet_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine verlet_evaluate_all","tags":"","loc":"proc/verlet_evaluate_all.html","title":"verlet_evaluate_all – LibPFASST"},{"text":"interface public function pf_hamiltonian_p(this, y, t, level_index) result(H) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Variable real(kind=pfdp), intent(in) :: t Time of solve integer, intent(in) :: level_index Level index Return Value real(kind=pfdp)","tags":"","loc":"interface/pf_hamiltonian_p.html","title":"pf_hamiltonian_p – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level_index, f) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value Description This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two","tags":"","loc":"interface/pf_f_eval_p~2.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate Description Solve the equation y - dtq*f_2(y) =rhs","tags":"","loc":"interface/pf_f_comp_p.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine amisdc_sweep(this, pf, lev, t0, dt) Uses pf_mod_timer proc~~amisdc_sweep~~UsesGraph proc~amisdc_sweep amisdc_sweep module~pf_mod_timer pf_mod_timer proc~amisdc_sweep->module~pf_mod_timer module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Calls proc~~amisdc_sweep~~CallsGraph proc~amisdc_sweep amisdc_sweep proc~start_timer start_timer proc~amisdc_sweep->proc~start_timer proc~end_timer end_timer proc~amisdc_sweep->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code amisdc_sweep Source Code subroutine amisdc_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: rhsA , rhsB , QA , QB call start_timer ( pf , TLEVEL + lev % index - 1 ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % SdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tau )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tau ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call this % f1eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) call this % f2eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 )) call this % f3eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 )) call lev % ulevel % factory % create_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QB , lev % index , lev % shape ) call QA % setval ( 0.0_pfdp ) call QB % setval ( 0.0_pfdp ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) ! First compute the explicit part of the right-hand side call rhsA % copy ( lev % Q ( m )) call rhsA % axpy ( dtsdc ( m ), lev % F ( m , 1 )) call rhsA % axpy ( 1.0_pfdp , lev % S ( m )) ! Save the right-hand side with only the explicit contribution call rhsB % copy ( rhsA ) ! Add the first implicit part to the right-hand side and solve for the first asynchronous update call rhsA % axpy ( - 2.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 2 )) call this % f2comp ( QA , t , 2.0_pfdp * dtsdc ( m ), rhsA , lev % index , lev % F ( m + 1 , 2 )) ! Add the second implicit part to the right-hand side and solve for the second asynchronous update call rhsB % axpy ( - 2.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 3 )) call this % f3comp ( QB , t , 2.0_pfdp * dtsdc ( m ), rhsB , lev % index , lev % F ( m + 1 , 3 )) ! Now we average the two asynchronous updates call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QA ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QB ) ! Evaluate the three right-hand sides with the updated variables call this % f1eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 )) call this % f2eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 )) call this % f3eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 3 )) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) ! Destroy the temporary variables call lev % ulevel % factory % destroy_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QB , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine amisdc_sweep","tags":"","loc":"proc/amisdc_sweep.html","title":"amisdc_sweep – LibPFASST"},{"text":"public subroutine amisdc_evaluate(this, lev, t, m) Uses pf_mod_dtype proc~~amisdc_evaluate~~UsesGraph proc~amisdc_evaluate amisdc_evaluate module~pf_mod_dtype pf_mod_dtype proc~amisdc_evaluate->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m Contents Source Code amisdc_evaluate Source Code subroutine amisdc_evaluate ( this , lev , t , m ) use pf_mod_dtype class ( pf_amisdc_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev call this % f1eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) call this % f2eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 )) call this % f3eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 )) end subroutine amisdc_evaluate","tags":"","loc":"proc/amisdc_evaluate.html","title":"amisdc_evaluate – LibPFASST"},{"text":"public subroutine amisdc_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code amisdc_initialize Source Code subroutine amisdc_initialize ( this , lev ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % SdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % SdiffI ( nnodes - 1 , nnodes )) !  S-BE this % SdiffE = lev % s0mat this % SdiffI = lev % s0mat dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) do m = 1 , nnodes - 1 this % SdiffE ( m , m ) = this % SdiffE ( m , m ) - dsdc ( m ) this % SdiffI ( m , m + 1 ) = this % SdiffI ( m , m + 1 ) - dsdc ( m ) end do end subroutine amisdc_initialize","tags":"","loc":"proc/amisdc_initialize.html","title":"amisdc_initialize – LibPFASST"},{"text":"public subroutine amisdc_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code amisdc_destroy Source Code subroutine amisdc_destroy ( this , lev ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % SdiffE ) deallocate ( this % SdiffI ) end subroutine amisdc_destroy","tags":"","loc":"proc/amisdc_destroy.html","title":"amisdc_destroy – LibPFASST"},{"text":"public subroutine amisdc_integrate(this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) Contents Source Code amisdc_integrate Source Code subroutine amisdc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % s0mat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine amisdc_integrate","tags":"","loc":"proc/amisdc_integrate.html","title":"amisdc_integrate – LibPFASST"},{"text":"public subroutine amisdc_residual(this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt Calls proc~~amisdc_residual~~CallsGraph proc~amisdc_residual amisdc_residual proc~pf_generic_residual pf_generic_residual proc~amisdc_residual->proc~pf_generic_residual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code amisdc_residual Source Code subroutine amisdc_residual ( this , lev , dt ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt call pf_generic_residual ( this , lev , dt ) end subroutine amisdc_residual","tags":"","loc":"proc/amisdc_residual.html","title":"amisdc_residual – LibPFASST"},{"text":"public subroutine amisdc_evaluate_all(this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) Calls proc~~amisdc_evaluate_all~~CallsGraph proc~amisdc_evaluate_all amisdc_evaluate_all proc~pf_generic_evaluate_all pf_generic_evaluate_all proc~amisdc_evaluate_all->proc~pf_generic_evaluate_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code amisdc_evaluate_all Source Code subroutine amisdc_evaluate_all ( this , lev , t ) class ( pf_amisdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) call pf_generic_evaluate_all ( this , lev , t ) end subroutine amisdc_evaluate_all","tags":"","loc":"proc/amisdc_evaluate_all.html","title":"amisdc_evaluate_all – LibPFASST"},{"text":"interface public subroutine pf_f1eval_p(this, y, t, level, f1) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f1","tags":"","loc":"interface/pf_f1eval_p.html","title":"pf_f1eval_p – LibPFASST"},{"text":"interface public subroutine pf_f2eval_p(this, y, t, level, f2) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2","tags":"","loc":"interface/pf_f2eval_p.html","title":"pf_f2eval_p – LibPFASST"},{"text":"interface public subroutine pf_f2comp_p(this, y, t, dt, rhs, level, f2) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2","tags":"","loc":"interface/pf_f2comp_p.html","title":"pf_f2comp_p – LibPFASST"},{"text":"interface public subroutine pf_f3eval_p(this, y, t, level, f3) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3","tags":"","loc":"interface/pf_f3eval_p.html","title":"pf_f3eval_p – LibPFASST"},{"text":"interface public subroutine pf_f3comp_p(this, y, t, dt, rhs, level, f3) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3","tags":"","loc":"interface/pf_f3comp_p.html","title":"pf_f3comp_p – LibPFASST"},{"text":"public subroutine imexQ_oc_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks proc~~imexq_oc_sweep~~UsesGraph proc~imexq_oc_sweep imexQ_oc_sweep module~pf_mod_hooks pf_mod_hooks proc~imexq_oc_sweep->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~imexq_oc_sweep->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Assign level pointer Loop over sweeps Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level this is real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Calls proc~~imexq_oc_sweep~~CallsGraph proc~imexq_oc_sweep imexQ_oc_sweep proc~call_hooks call_hooks proc~imexq_oc_sweep->proc~call_hooks proc~pf_residual pf_residual proc~imexq_oc_sweep->proc~pf_residual proc~start_timer start_timer proc~imexq_oc_sweep->proc~start_timer proc~end_timer end_timer proc~imexq_oc_sweep->proc~end_timer proc~call_hooks->proc~start_timer proc~call_hooks->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imexQ_oc_sweep Source Code subroutine imexQ_oc_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_imexQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: level_index !!  which level this is integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags class ( pf_level_t ), pointer :: lev !!  points to current level ! indicate if sweep on both (0, default; might skip y or p if tolerance satisfied), just y (1), just p (2) integer :: k , m , n , Nnodes , which real ( pfdp ) :: t , tend logical :: sweep_y , sweep_p real ( pfdp ), allocatable :: norms_y (:) !, norms_p(Lev%nnodes-1) integer :: step lev => pf % levels ( level_index ) !!  Assign level pointer step = pf % state % step + 1 !     print *, 'sweep on step', step which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SWEEPER WITHOUT FLAGS\" !     print *, \"IMEXQ_OC SWEEP\", which Nnodes = lev % nnodes tend = t0 + dt call start_timer ( pf , TLEVEL + lev % index - 1 ) if ( which . eq . 1 ) then sweep_y = . true . sweep_p = . false . else if ( which . eq . 2 ) then sweep_y = . false . sweep_p = . true . else sweep_y = . true . sweep_p = . true . allocate ( norms_y ( lev % nnodes - 1 )) do m = 1 , Nnodes - 1 norms_y ( m ) = lev % R ( m )% norm ( 1 ) end do if ( maxval ( abs ( norms_y )) < pf % abs_res_tol ) then sweep_y = . false . if ( level_index == pf % nlevels ) pf % state % skippedy = pf % state % skippedy + 1 end if deallocate ( norms_y ) !if ( maxval(abs(norms_p)) < pf%abs_res_tol ) sweep_p = .false. end if !     if( sweep_p .and. pf%rank == 0)  print *, \"sweep on p with which = \", which do k = 1 , nsweeps !!  Loop over sweeps call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals from previous iteration and add fas correction !     do m = 1, Nnodes-1 !        call Lev%encap%setval(Lev%S(m), 0.0_pfdp, 1) !        call Lev%encap%setval(Lev%S(m), 0.0_pfdp, 2) if ( sweep_y ) then do m = 1 , Nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp , 1 ) !  Forward in y if ( this % explicit ) then do n = 1 , Nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 ), 1 ) !                 call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(m,n), Lev%F(n,1),1) end do end if if ( this % implicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 ), 1 ) !                 call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(m,n), Lev%F(n,2),1) end do end if if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 1 ) !              call Lev%encap%axpy(Lev%S(m), 1.0_pfdp, Lev%tauQ(m),1) end if end do end if if ( sweep_p ) then do m = Nnodes - 1 , 1 , - 1 call lev % I ( m )% setval ( 0.0_pfdp , 2 ) !  Backward in p, note S(m) goes backward now !2          do n =  1,Nnodes !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffE(m,n), Lev%F(Nnodes+1-n,1),2) !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffI(m,n), Lev%F(Nnodes+1-n,2),2) !2          end do if ( this % explicit ) then do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffE ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 1 ), 2 ) !call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(Nnodes-m,Nnodes+1-n), Lev%F(n,1),2) end do end if if ( this % implicit ) then do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 2 ), 2 ) !               call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(Nnodes-m,Nnodes+1-n), Lev%F(n,2),2) end do end if if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 2 ) end if end do end if ! Reload the newest initial values ! Recompute first function values if ( sweep_y ) then if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 , 1 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 , 1 , 1 , step ) if ( this % implicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 , 1 , 1 , step ) end if !        call Lev%encap%copy(Lev%Q(1), Lev%q0, 1) !        call imexQ_oc%f1eval(Lev%Q(1), t0, Lev%level, Lev%ctx, Lev%F(1,1), 1, 1, step) !        call imexQ_oc%f2eval(Lev%Q(1), t0, Lev%level, Lev%ctx, Lev%F(1,2), 1) end if !else !     if( sweep_p ) then !       if (k .eq. 1) then !         call lev%Q(Nnodes)%copy(lev%qend, 2) !         if (this%explicit) & !           call this%f_eval(lev%Q(Nnodes), tend, lev%index, lev%F(Nnodes,1), 1, 2, Nnodes, step) !         if (this%implicit) & !           call this%f_eval(lev%Q(Nnodes), tend, lev%index, lev%F(Nnodes,2), 2, 2, Nnodes, step) !       end if ! !        call Lev%encap%copy(Lev%Q(Nnodes), Lev%qend, 2) ! !        call imexQ_oc%f1eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,1), 2, Nnodes, step) ! !        call imexQ_oc%f2eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,2), 2) !     end if !     if (sweep_p) then !    !  Backward  sweep on p !       t = tend !       do m =  Nnodes-1,1,-1 !          t = t - dt*this%dtsdc(m) ! !          ! Do the dirk parts !          call this%rhs%setval(0.0_pfdp, 2) !          do n = Nnodes, m+1,-1 !             if (this%explicit) & !               call this%rhs%axpy(dt*this%QtilE(Nnodes-m,Nnodes-n+1), lev%F(n,1), 2) !             if (this%implicit) & !               call this%rhs%axpy(dt*this%QtilI(Nnodes-m,Nnodes-n+1), lev%F(n,2), 2) !          end do ! !          call this%rhs%axpy(1.0_pfdp, lev%I(m), 2) !          call this%rhs%axpy(1.0_pfdp, lev%Q(Nnodes), 2) ! !          !  Do implicit solve !          if (this%implicit) then !            call this%f_comp(lev%Q(m), t, dt*this%QtilI(Nnodes-m,Nnodes-m+1), this%rhs, lev%index, lev%F(m,2), 2, 2) !          else !             call lev%Q(m)%copy(this%rhs,2) !          end if !          if (this%explicit) & !            call this%f_eval(lev%Q(m), t, lev%index, lev%F(m,1), 1, 2, m, step) !       end do !       ! reset first value !       call lev%q0%copy(lev%Q(1), 2) !       call pf_residual(pf, lev, dt, 2) ! !       call pf_residual(pf, lev, dt, which) !     end if !  Make some space !     call Lev%encap%create(rhs, Lev%level, SDC_KIND_SOL_FEVAL, Lev%nvars, Lev%shape, Lev%ctx) if ( sweep_y ) then !  Forward sweep on y t = t0 do m = 1 , Nnodes - 1 t = t + dt * this % dtsdc ( m ) !  forward running time !  Form rhs with all explicit terms call this % rhs % setval ( 0.0_pfdp , 1 ) do n = 1 , m if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 ), 1 ) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 ), 1 ) end do call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 1 ) call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) ! Do implicit solve if ( this % implicit ) then call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 ) else call lev % Q ( m + 1 )% copy ( this % rhs , 1 ) end if !  Compute explicit piece on new value if ( this % explicit ) & call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 , 1 , m + 1 , step ) end do !  Reset last values call lev % qend % copy ( lev % Q ( Nnodes ), 1 ) !       call pf_residual(pf, lev, dt, 1) !       call pf_residual(pf, lev, dt, which) end if if ( sweep_p ) then !        do m=1, Nnodes-1 !           call lev%I(m)%setval(0.0_pfdp, 2) ! !           !  Backward in p, note S(m) goes backward now ! !2          do n =  1,Nnodes ! !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffE(m,n), Lev%F(Nnodes+1-n,1),2) ! !2             call Lev%encap%axpy(Lev%S(Nnodes-m), dt*imexQ_oc%QdiffI(m,n), Lev%F(Nnodes+1-n,2),2) ! !2          end do !           if (this%explicit) then !             do n =  Nnodes,1,-1 !               call lev%I(m)%axpy(dt*this%QdiffE(Nnodes-m,Nnodes+1-n), lev%F(n,1), 2) !               !call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffE(Nnodes-m,Nnodes+1-n), Lev%F(n,1),2) !             end do !           end if !           if (this%implicit) then !             do n =  Nnodes,1,-1 !               call lev%I(m)%axpy(dt*this%QdiffI(Nnodes-m,Nnodes+1-n), lev%F(n,2), 2) ! !               call Lev%encap%axpy(Lev%S(m), dt*imexQ_oc%QdiffI(Nnodes-m,Nnodes+1-n), Lev%F(n,2),2) !             end do !           end if !           if (allocated(lev%tauQ)) then !              call lev%I(m)%axpy(1.0_pfdp, lev%tauQ(m), 2) !           end if !       end do if ( k . eq . 1 ) then call lev % Q ( Nnodes )% copy ( lev % qend , 2 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 1 ), 1 , 2 , Nnodes , step ) if ( this % implicit ) & call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 2 ), 2 , 2 , Nnodes , step ) end if !        call Lev%encap%copy(Lev%Q(Nnodes), Lev%qend, 2) !        call imexQ_oc%f1eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,1), 2, Nnodes, step) !        call imexQ_oc%f2eval(Lev%Q(Nnodes), tend, Lev%level, Lev%ctx, Lev%F(Nnodes,2), 2) end if if ( sweep_p ) then !  Backward  sweep on p t = tend do m = Nnodes - 1 , 1 , - 1 t = t - dt * this % dtsdc ( m ) ! Do the dirk parts call this % rhs % setval ( 0.0_pfdp , 2 ) do n = Nnodes , m + 1 , - 1 if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 1 ), 2 ) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 2 ), 2 ) end do call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) call this % rhs % axpy ( 1.0_pfdp , lev % Q ( Nnodes ), 2 ) !  Do implicit solve if ( this % implicit ) then call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 2 ), 2 , 2 ) else call lev % Q ( m )% copy ( this % rhs , 2 ) end if if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , 2 , m , step ) end do ! reset first value call lev % q0 % copy ( lev % Q ( 1 ), 2 ) !       call pf_residual(pf, lev, dt, 2) end if !     if(sweep_p) & !       call this%evaluate_all(lev, t0 + dt*lev%nodes, 2, step) !     if( sweep_p .and. sweep_y ) then !       call pf_residual(pf, lev, dt, 0) !     else if( sweep_y ) then !       call pf_residual(pf, lev, dt, 1) !     else if (sweep_p ) then !       call pf_residual(pf, lev, dt, 2) !     else !       stop \"neither sweep on p nor on y : that should not happen\" !     end if call pf_residual ( pf , lev , dt , which ) ! done call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !nsweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imexQ_oc_sweep","tags":"","loc":"proc/imexq_oc_sweep.html","title":"imexQ_oc_sweep – LibPFASST"},{"text":"public subroutine imexQ_oc_evaluate(this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imexQ_oc_evaluate Source Code subroutine imexQ_oc_evaluate ( this , lev , t , m , flags , step ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m integer , intent ( in ), optional :: flags , step integer :: which , mystep which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC EVAL WITHOUT FLAGS\" mystep = 1 if ( present ( step )) then mystep = step else print * , \"step not present in evaluate\" , which stop end if !     print *, \"IMEXQ_OC EVAL \", which if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , which , m , mystep ) if ( this % implicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , which , m , mystep ) end subroutine imexQ_oc_evaluate","tags":"","loc":"proc/imexq_oc_evaluate.html","title":"imexQ_oc_evaluate – LibPFASST"},{"text":"public subroutine imexQ_oc_evaluate_all(this, lev, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imexQ_oc_evaluate_all Source Code subroutine imexQ_oc_evaluate_all ( this , lev , t , flags , step ) !! Evaluate all function values class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , intent ( in ), optional :: flags , step !     call pf_generic_evaluate_all(this, lev, t, flags, step) integer :: m if (. not . present ( flags )) stop \"IMEXQ_OC EVAL_ALL WITHOUT FLAGS\" if (. not . present ( step )) stop \"IMEXQ_OC EVAL_ALL WITHOUT step\" do m = 1 , lev % nnodes call this % evaluate ( lev , t ( m ), m , flags , step ) end do end subroutine imexQ_oc_evaluate_all","tags":"","loc":"proc/imexq_oc_evaluate_all.html","title":"imexQ_oc_evaluate_all – LibPFASST"},{"text":"public subroutine imexQ_oc_initialize(this, lev) Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code imexQ_oc_initialize Source Code subroutine imexQ_oc_initialize ( this , lev ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev integer :: Nnodes this % npieces = 2 Nnodes = lev % nnodes allocate ( this % QdiffE ( Nnodes - 1 , Nnodes )) !  S-FE allocate ( this % QdiffI ( Nnodes - 1 , Nnodes )) !  S-BE allocate ( this % QtilE ( Nnodes - 1 , Nnodes )) !  S-FE allocate ( this % QtilI ( Nnodes - 1 , Nnodes )) !  S-BE this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp this % dtsdc = lev % nodes ( 2 : Nnodes ) - lev % nodes ( 1 : Nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !!  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine imexQ_oc_initialize","tags":"","loc":"proc/imexq_oc_initialize.html","title":"imexQ_oc_initialize – LibPFASST"},{"text":"public subroutine imexQ_oc_integrate(this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags Contents Source Code imexQ_oc_integrate Source Code subroutine imexQ_oc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) !qSDC unused? real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , intent ( in ), optional :: flags integer :: n , m , Nnodes , which Nnodes = lev % nnodes which = 0 if ( present ( flags )) then which = flags else print * , \"flags not present in integrate\" , which stop end if !     print *, \"IMEXQ_OC INTEGRATE \", which do n = 1 , Nnodes - 1 !  Forward in y if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call fintSDC ( n )% setval ( 0.0_pfdp , 1 ) do m = 1 , Nnodes !               do p = 1, npieces !                 call Lev%encap%axpy(fintSDC(n), dt*Lev%sdcmats%qmat(n,m), fSDC(m,p),1) !               end do if ( this % explicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 1 ), 1 ) if ( this % implicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 2 ), 1 ) end do end if !  Backward in p if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call fintSDC ( Nnodes - n )% setval ( 0.0_pfdp , 2 ) do m = 1 , Nnodes !               do p = 1, npieces !                 call Lev%encap%axpy(fintSDC(Nnodes-n), dt*Lev%sdcmats%qmat(n,m), fSDC(Nnodes+1-m,p),2) !               end do if ( this % explicit ) & call fintSDC ( Nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( Nnodes + 1 - m , 1 ), 2 ) if ( this % implicit ) & call fintSDC ( Nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( Nnodes + 1 - m , 2 ), 2 ) end do end if end do end subroutine imexQ_oc_integrate","tags":"","loc":"proc/imexq_oc_integrate.html","title":"imexQ_oc_integrate – LibPFASST"},{"text":"public subroutine imexQ_oc_residual(this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Contents Source Code imexQ_oc_residual Source Code subroutine imexQ_oc_residual ( this , lev , dt , flags ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , intent ( in ), optional :: flags integer :: m , which which = 0 if ( present ( flags )) then which = flags else print * , \"flags not present in residual\" , which stop end if !     print *, \"IMEXQ_OC RESIDUAL \", which call this % integrate ( lev , lev % Q , lev % F , dt , lev % I , which ) ! add tau (which is 'node to node') if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), which ) end do end if ! subtract out Q do m = 1 , lev % nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 1 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 ), 1 ) end if if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 2 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( lev % nnodes ), 2 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m ), 2 ) end if end do end subroutine imexQ_oc_residual","tags":"","loc":"proc/imexq_oc_residual.html","title":"imexQ_oc_residual – LibPFASST"},{"text":"public subroutine imexQ_oc_spreadq0(this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~imexq_oc_spreadq0~~CallsGraph proc~imexq_oc_spreadq0 imexQ_oc_spreadq0 proc~pf_stop pf_stop proc~imexq_oc_spreadq0->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imexQ_oc_spreadq0 Source Code subroutine imexQ_oc_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer :: m , p , which , mystep which = 3 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SPREADQ0 WITHOUT FLAGS\" !     print *, \"IMEXQ_OC SPREADQ0\", which mystep = 1 if ( present ( step )) then mystep = step !needed for sequential version else print * , \"step not present in spreadq0\" , which stop end if select case ( which ) case ( 1 ) !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , 1 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , 1 , 1 , mystep ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), 1 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p ), 1 ) end do end do case ( 2 ) !  Stick terminal condition into last node slot call lev % Q ( lev % nnodes )% copy ( lev % qend , 2 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , lev % nnodes , 2 , mystep ) ! Spread F and solution to all nodes do m = lev % nnodes - 1 , 1 , - 1 call lev % Q ( m )% copy ( lev % Q ( lev % nnodes ), 2 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( lev % nnodes , p ), 2 ) end do end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine imexQ_oc_spreadq0","tags":"","loc":"proc/imexq_oc_spreadq0.html","title":"imexQ_oc_spreadq0 – LibPFASST"},{"text":"public subroutine imexQ_oc_destroy(this, lev) deallocate Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code imexQ_oc_destroy Source Code subroutine imexQ_oc_destroy ( this , lev ) !!  deallocate class ( pf_imexQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_single ( this % rhs , lev % index , lev % shape ) end subroutine imexQ_oc_destroy","tags":"","loc":"proc/imexq_oc_destroy.html","title":"imexQ_oc_destroy – LibPFASST"},{"text":"interface This is the interface for the routine to compute the RHS function values public subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags integer, intent(in), optional :: idx integer, intent(in), optional :: step Description Evaluae f_piece(y), where piece is one or two","tags":"","loc":"interface/pf_f_eval_p~3.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface This is the interface for the routine to compute the RHS function values public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags Description Solve the equation y - dtq*f_2(y) =rhs","tags":"","loc":"interface/pf_f_comp_p~2.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public function ndarray_oc_norm(this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) Calls proc~~ndarray_oc_norm~~CallsGraph proc~ndarray_oc_norm ndarray_oc_norm proc~pf_stop pf_stop proc~ndarray_oc_norm->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_norm Source Code function ndarray_oc_norm ( this , flags ) result ( norm ) class ( ndarray_oc ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm integer :: which which = 0 if ( present ( flags )) which = flags if (. not . present ( flags )) print * , \"norm without flags\" select case ( which ) case ( 0 ) norm = max ( maxval ( abs ( this % yflatarray )), maxval ( abs ( this % pflatarray ))) case ( 1 ) norm = maxval ( abs ( this % yflatarray )) case ( 2 ) norm = maxval ( abs ( this % pflatarray )) case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end function ndarray_oc_norm","tags":"","loc":"proc/ndarray_oc_norm.html","title":"ndarray_oc_norm – LibPFASST"},{"text":"public function cast_as_ndarray_oc(encap_polymorph) result(ndarray_oc_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndarray_oc ),\n  pointer Calls proc~~cast_as_ndarray_oc~~CallsGraph proc~cast_as_ndarray_oc cast_as_ndarray_oc proc~pf_stop pf_stop proc~cast_as_ndarray_oc->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cast_as_ndarray_oc~~CalledByGraph proc~cast_as_ndarray_oc cast_as_ndarray_oc proc~ndarray_oc_destroy ndarray_oc_destroy proc~ndarray_oc_destroy->proc~cast_as_ndarray_oc proc~ndarray_oc_dump_hook ndarray_oc_dump_hook proc~ndarray_oc_dump_hook->proc~cast_as_ndarray_oc proc~ndarray_oc_dump_all_hook ndarray_oc_dump_all_hook proc~ndarray_oc_dump_all_hook->proc~cast_as_ndarray_oc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cast_as_ndarray_oc Source Code function cast_as_ndarray_oc ( encap_polymorph ) result ( ndarray_oc_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndarray_oc ), pointer :: ndarray_oc_obj select type ( encap_polymorph ) type is ( ndarray_oc ) ndarray_oc_obj => encap_polymorph class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function cast_as_ndarray_oc","tags":"","loc":"proc/cast_as_ndarray_oc.html","title":"cast_as_ndarray_oc – LibPFASST"},{"text":"public function get_array1d_oc(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:) Calls proc~~get_array1d_oc~~CallsGraph proc~get_array1d_oc get_array1d_oc proc~pf_stop pf_stop proc~get_array1d_oc->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_array1d_oc Source Code function get_array1d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"array1d_oc without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r => x % yflatarray case ( 2 ) r => x % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array1d_oc","tags":"","loc":"proc/get_array1d_oc.html","title":"get_array1d_oc – LibPFASST"},{"text":"public function get_array2d_oc(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:) Calls proc~~get_array2d_oc~~CallsGraph proc~get_array2d_oc get_array2d_oc proc~pf_stop pf_stop proc~get_array2d_oc->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_array2d_oc Source Code function get_array2d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"array2d_oc without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % yflatarray case ( 2 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % pflatarray case default stop \"ERROR in get_array1d_oc: only 1, 2 allowed as flags\" end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array2d_oc","tags":"","loc":"proc/get_array2d_oc.html","title":"get_array2d_oc – LibPFASST"},{"text":"public function get_array3d_oc(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:,:) Calls proc~~get_array3d_oc~~CallsGraph proc~get_array3d_oc get_array3d_oc proc~pf_stop pf_stop proc~get_array3d_oc->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_array3d_oc Source Code function get_array3d_oc ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) integer :: which which = 0 if ( present ( flags )) which = flags select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 1 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % yflatarray case ( 2 ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % pflatarray case default stop \"ERROR in get_array1d_oc: only 1, 2 allowed as flags\" end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end function get_array3d_oc","tags":"","loc":"proc/get_array3d_oc.html","title":"get_array3d_oc – LibPFASST"},{"text":"public subroutine ndarray_oc_build(q, shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) Calls proc~~ndarray_oc_build~~CallsGraph proc~ndarray_oc_build ndarray_oc_build proc~pf_stop pf_stop proc~ndarray_oc_build->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ndarray_oc_build~~CalledByGraph proc~ndarray_oc_build ndarray_oc_build proc~ndarray_oc_create_single ndarray_oc_create_single proc~ndarray_oc_create_single->proc~ndarray_oc_build Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_build Source Code subroutine ndarray_oc_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) select type ( q ) class is ( ndarray_oc ) allocate ( q % shape ( size ( shape ))) allocate ( q % yflatarray ( product ( shape ))) allocate ( q % pflatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_build","tags":"","loc":"proc/ndarray_oc_build.html","title":"ndarray_oc_build – LibPFASST"},{"text":"public subroutine ndarray_oc_create_single(this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Calls proc~~ndarray_oc_create_single~~CallsGraph proc~ndarray_oc_create_single ndarray_oc_create_single proc~ndarray_oc_build ndarray_oc_build proc~ndarray_oc_create_single->proc~ndarray_oc_build proc~pf_stop pf_stop proc~ndarray_oc_build->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_create_single Source Code subroutine ndarray_oc_create_single ( this , x , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( ndarray_oc :: x ) call ndarray_oc_build ( x , shape ) end subroutine ndarray_oc_create_single","tags":"","loc":"proc/ndarray_oc_create_single.html","title":"ndarray_oc_create_single – LibPFASST"},{"text":"public subroutine ndarray_oc_create_array(this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndarray_oc_create_array Source Code subroutine ndarray_oc_create_array ( this , x , n , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndarray_oc :: x ( n )) do i = 1 , n call ndarray_oc_build ( x ( i ), shape ) end do end subroutine ndarray_oc_create_array","tags":"","loc":"proc/ndarray_oc_create_array.html","title":"ndarray_oc_create_array – LibPFASST"},{"text":"public subroutine ndarray_oc_destroy(encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap Calls proc~~ndarray_oc_destroy~~CallsGraph proc~ndarray_oc_destroy ndarray_oc_destroy proc~cast_as_ndarray_oc cast_as_ndarray_oc proc~ndarray_oc_destroy->proc~cast_as_ndarray_oc proc~pf_stop pf_stop proc~cast_as_ndarray_oc->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_destroy Source Code subroutine ndarray_oc_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndarray_oc ), pointer :: ndarray_oc_obj ndarray_oc_obj => cast_as_ndarray_oc ( encap ) !?? deallocate ( ndarray_oc_obj % pflatarray ) deallocate ( ndarray_oc_obj % yflatarray ) deallocate ( ndarray_oc_obj % shape ) nullify ( ndarray_oc_obj ) end subroutine ndarray_oc_destroy","tags":"","loc":"proc/ndarray_oc_destroy.html","title":"ndarray_oc_destroy – LibPFASST"},{"text":"public subroutine ndarray_oc_destroy_single(this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Calls proc~~ndarray_oc_destroy_single~~CallsGraph proc~ndarray_oc_destroy_single ndarray_oc_destroy_single proc~pf_stop pf_stop proc~ndarray_oc_destroy_single->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_destroy_single Source Code subroutine ndarray_oc_destroy_single ( this , x , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) select type ( x ) class is ( ndarray_oc ) deallocate ( x % pflatarray ) deallocate ( x % yflatarray ) deallocate ( x % shape ) class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select deallocate ( x ) end subroutine ndarray_oc_destroy_single","tags":"","loc":"proc/ndarray_oc_destroy_single.html","title":"ndarray_oc_destroy_single – LibPFASST"},{"text":"public subroutine ndarray_oc_destroy_array(this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Calls proc~~ndarray_oc_destroy_array~~CallsGraph proc~ndarray_oc_destroy_array ndarray_oc_destroy_array proc~pf_stop pf_stop proc~ndarray_oc_destroy_array->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_destroy_array Source Code subroutine ndarray_oc_destroy_array ( this , x , n , level , shape ) class ( ndarray_oc_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i select type ( x ) class is ( ndarray_oc ) do i = 1 , n deallocate ( x ( i )% pflatarray ) deallocate ( x ( i )% yflatarray ) deallocate ( x ( i )% shape ) end do class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select deallocate ( x ) end subroutine ndarray_oc_destroy_array","tags":"","loc":"proc/ndarray_oc_destroy_array.html","title":"ndarray_oc_destroy_array – LibPFASST"},{"text":"public subroutine ndarray_oc_setval(this, val, flags) Subroutine to set array to a scalar  value. Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags Calls proc~~ndarray_oc_setval~~CallsGraph proc~ndarray_oc_setval ndarray_oc_setval proc~pf_stop pf_stop proc~ndarray_oc_setval->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_setval Source Code subroutine ndarray_oc_setval ( this , val , flags ) class ( ndarray_oc ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"setval without flags\" select case ( which ) case ( 0 ) this % yflatarray = val this % pflatarray = val case ( 1 ) this % yflatarray = val case ( 2 ) this % pflatarray = val case default call pf_stop ( __ FILE__ , __ LINE__ , 'Select case error' , which ) end select end subroutine ndarray_oc_setval","tags":"","loc":"proc/ndarray_oc_setval.html","title":"ndarray_oc_setval – LibPFASST"},{"text":"public subroutine ndarray_oc_copy(this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags Calls proc~~ndarray_oc_copy~~CallsGraph proc~ndarray_oc_copy ndarray_oc_copy proc~pf_stop pf_stop proc~ndarray_oc_copy->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_copy Source Code subroutine ndarray_oc_copy ( this , src , flags ) class ( ndarray_oc ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if(.not.present(flags)) print *, \"copy without flags\" select type ( src ) type is ( ndarray_oc ) select case ( which ) case ( 0 ) this % yflatarray = src % yflatarray this % pflatarray = src % pflatarray case ( 1 ) this % yflatarray = src % yflatarray case ( 2 ) this % pflatarray = src % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_copy","tags":"","loc":"proc/ndarray_oc_copy.html","title":"ndarray_oc_copy – LibPFASST"},{"text":"public subroutine ndarray_oc_pack(this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags Calls proc~~ndarray_oc_pack~~CallsGraph proc~ndarray_oc_pack ndarray_oc_pack proc~pf_stop pf_stop proc~ndarray_oc_pack->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_pack Source Code subroutine ndarray_oc_pack ( this , z , flags ) class ( ndarray_oc ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags select case ( which ) case ( 0 ) !z = [sol%yflatarray, sol%pflatarray] !z has to be right size? initialized to nvars, so it can hold either y or p !is it ever needed to pack y and p simultaneously? stop \"ERROR in ndarray_oc_pack: only 1, 2 allowed as flags\" case ( 1 ) z = this % yflatarray case ( 2 ) z = this % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine ndarray_oc_pack","tags":"","loc":"proc/ndarray_oc_pack.html","title":"ndarray_oc_pack – LibPFASST"},{"text":"public subroutine ndarray_oc_unpack(this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags Calls proc~~ndarray_oc_unpack~~CallsGraph proc~ndarray_oc_unpack ndarray_oc_unpack proc~pf_stop pf_stop proc~ndarray_oc_unpack->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_unpack Source Code subroutine ndarray_oc_unpack ( this , z , flags ) class ( ndarray_oc ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags select case ( which ) case ( 0 ) stop \"ERROR in ndarray_oc_unpack: only 1, 2 allowed as flags\" case ( 1 ) this % yflatarray = z case ( 2 ) this % pflatarray = z case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select end subroutine ndarray_oc_unpack","tags":"","loc":"proc/ndarray_oc_unpack.html","title":"ndarray_oc_unpack – LibPFASST"},{"text":"public subroutine ndarray_oc_axpy(this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Calls proc~~ndarray_oc_axpy~~CallsGraph proc~ndarray_oc_axpy ndarray_oc_axpy proc~pf_stop pf_stop proc~ndarray_oc_axpy->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_axpy Source Code subroutine ndarray_oc_axpy ( this , a , x , flags ) class ( ndarray_oc ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags integer :: which which = 0 if ( present ( flags )) which = flags !     if (.not.present(flags)) stop \"axpy without flags\" select type ( x ) type is ( ndarray_oc ) select case ( which ) case ( 0 ) this % yflatarray = a * x % yflatarray + this % yflatarray this % pflatarray = a * x % pflatarray + this % pflatarray case ( 1 ) this % yflatarray = a * x % yflatarray + this % yflatarray case ( 2 ) this % pflatarray = a * x % pflatarray + this % pflatarray case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) end select class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_oc_axpy","tags":"","loc":"proc/ndarray_oc_axpy.html","title":"ndarray_oc_axpy – LibPFASST"},{"text":"public subroutine ndarray_oc_dump_hook(pf, lev, state) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf type( pf_level_t ), intent(inout) :: lev type( pf_state_t ), intent(in) :: state Calls proc~~ndarray_oc_dump_hook~~CallsGraph proc~ndarray_oc_dump_hook ndarray_oc_dump_hook proc~cast_as_ndarray_oc cast_as_ndarray_oc proc~ndarray_oc_dump_hook->proc~cast_as_ndarray_oc proc~pf_stop pf_stop proc~cast_as_ndarray_oc->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_dump_hook Source Code subroutine ndarray_oc_dump_hook ( pf , lev , state ) type ( pf_pfasst_t ), intent ( inout ) :: pf type ( pf_level_t ), intent ( inout ) :: lev type ( pf_state_t ), intent ( in ) :: state character ( len = 256 ) :: fnamey , fnamep type ( ndarray_oc ), pointer :: qend qend => cast_as_ndarray_oc ( lev % qend ) write ( fnamey , \"('y_s',i0.2,'i',i0.3,'l',i0.2,'.npy')\" ) & state % step , state % iter , lev % index call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamey ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % yflatarray ), qend % yflatarray ) write ( fnamep , \"('p_s',i0.2,'i',i0.3,'l',i0.2,'.npy')\" ) & state % step , state % iter , lev % index call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamep ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % pflatarray ), qend % pflatarray ) end subroutine ndarray_oc_dump_hook","tags":"","loc":"proc/ndarray_oc_dump_hook.html","title":"ndarray_oc_dump_hook – LibPFASST"},{"text":"public subroutine ndarray_oc_dump_all_hook(pf, lev, state) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev type( pf_state_t ), intent(in) :: state Calls proc~~ndarray_oc_dump_all_hook~~CallsGraph proc~ndarray_oc_dump_all_hook ndarray_oc_dump_all_hook proc~cast_as_ndarray_oc cast_as_ndarray_oc proc~ndarray_oc_dump_all_hook->proc~cast_as_ndarray_oc proc~pf_stop pf_stop proc~cast_as_ndarray_oc->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_oc_dump_all_hook Source Code subroutine ndarray_oc_dump_all_hook ( pf , lev , state ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: lev type ( pf_state_t ), intent ( in ) :: state character ( len = 256 ) :: fnamey , fnamep integer :: m type ( ndarray_oc ), pointer :: qend do m = 1 , lev % nnodes qend => cast_as_ndarray_oc ( lev % Q ( m )) write ( fnamey , \"('y_s',i0.2,'l',i0.2,'m',i0.2,'.npy')\" ) & state % step , lev % index , m call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamey ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % yflatarray ), qend % yflatarray ) write ( fnamep , \"('p_s',i0.2,'l',i0.2,'m',i0.2,'.npy')\" ) & state % step , lev % index , m call ndarray_dump_numpy ( trim ( pf % outdir ) // c_null_char , trim ( fnamep ) // c_null_char , '<f8' // c_null_char // c_null_char , & qend % dim , qend % shape , size ( qend % pflatarray ), qend % pflatarray ) end do end subroutine ndarray_oc_dump_all_hook","tags":"","loc":"proc/ndarray_oc_dump_all_hook.html","title":"ndarray_oc_dump_all_hook – LibPFASST"},{"text":"public subroutine ndarray_oc_eprint(this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this integer, intent(in), optional :: flags Contents Source Code ndarray_oc_eprint Source Code subroutine ndarray_oc_eprint ( this , flags ) class ( ndarray_oc ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values print * , this % yflatarray ( 1 : 10 ) print * , this % pflatarray ( 1 : 10 ) end subroutine ndarray_oc_eprint","tags":"","loc":"proc/ndarray_oc_eprint.html","title":"ndarray_oc_eprint – LibPFASST"},{"text":"interface public subroutine ndarray_mkdir(dname, dlen) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname integer(kind=c_int), intent(in), value :: dlen","tags":"","loc":"interface/ndarray_mkdir.html","title":"ndarray_mkdir – LibPFASST"},{"text":"interface public subroutine ndarray_dump_numpy(dname, fname, endian, dim, shape, nvars, array) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer(kind=c_int), intent(in), value :: dim integer(kind=c_int), intent(in) :: shape (dim) integer(kind=c_int), intent(in), value :: nvars real(kind=pfdp), intent(in) :: array (nvars)","tags":"","loc":"interface/ndarray_dump_numpy.html","title":"ndarray_dump_numpy – LibPFASST"},{"text":"public subroutine pf_mpi_create(pf_comm, mpi_comm) Subroutine to create an MPI based PFASST communicator using the MPI communicator mpi_comm .\n assign communicator assign number of processors assign procedure pointers Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(out) :: pf_comm integer, intent(in) :: mpi_comm Calls proc~~pf_mpi_create~~CallsGraph proc~pf_mpi_create pf_mpi_create mpi_comm_size mpi_comm_size proc~pf_mpi_create->mpi_comm_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_mpi_create Source Code subroutine pf_mpi_create ( pf_comm , mpi_comm ) type ( pf_comm_t ), intent ( out ) :: pf_comm integer , intent ( in ) :: mpi_comm integer :: ierror pf_comm % comm = mpi_comm !! assign communicator !> assign number of processors call mpi_comm_size ( mpi_comm , pf_comm % nproc , ierror ) !>  assign procedure pointers pf_comm % post => pf_mpi_post pf_comm % recv => pf_mpi_recv pf_comm % send => pf_mpi_send pf_comm % wait => pf_mpi_wait pf_comm % broadcast => pf_mpi_broadcast pf_comm % recv_status => pf_mpi_recv_status pf_comm % send_status => pf_mpi_send_status end subroutine pf_mpi_create","tags":"","loc":"proc/pf_mpi_create.html","title":"pf_mpi_create – LibPFASST"},{"text":"public subroutine pf_mpi_setup(pf_comm, pf, ierror) Uses pf_mod_mpi proc~~pf_mpi_setup~~UsesGraph proc~pf_mpi_setup pf_mpi_setup module~pf_mod_mpi pf_mod_mpi proc~pf_mpi_setup->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to set up the PFASST communicator.\n This should be called soon after adding levels to the PFASST controller \n  set the rank allocate arrarys for and and receive requests Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(inout) :: pf_comm communicator type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(inout) :: ierror error flag Calls proc~~pf_mpi_setup~~CallsGraph proc~pf_mpi_setup pf_mpi_setup mpi_comm_rank mpi_comm_rank proc~pf_mpi_setup->mpi_comm_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_mpi_setup~~CalledByGraph proc~pf_mpi_setup pf_mpi_setup proc~pf_pfasst_create pf_pfasst_create proc~pf_pfasst_create->proc~pf_mpi_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_mpi_setup Source Code subroutine pf_mpi_setup ( pf_comm , pf , ierror ) use pf_mod_mpi , only : MPI_REQUEST_NULL type ( pf_comm_t ), intent ( inout ) :: pf_comm !!  communicator type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( inout ) :: ierror !!  error flag !>  set the rank call mpi_comm_rank ( pf_comm % comm , pf % rank , ierror ) !>  allocate arrarys for and and receive requests allocate ( pf_comm % recvreq ( pf % nlevels )) allocate ( pf_comm % sendreq ( pf % nlevels )) pf_comm % sendreq = MPI_REQUEST_NULL pf_comm % statreq = - 66 !Tells the first send_status not to wait for previous one to arrive end subroutine pf_mpi_setup","tags":"","loc":"proc/pf_mpi_setup.html","title":"pf_mpi_setup – LibPFASST"},{"text":"public subroutine pf_mpi_destroy(pf_comm) Subroutine to destroy the PFASST communicator. Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(inout) :: pf_comm Called by proc~~pf_mpi_destroy~~CalledByGraph proc~pf_mpi_destroy pf_mpi_destroy proc~pf_pfasst_destroy pf_pfasst_destroy proc~pf_pfasst_destroy->proc~pf_mpi_destroy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_mpi_destroy Source Code subroutine pf_mpi_destroy ( pf_comm ) type ( pf_comm_t ), intent ( inout ) :: pf_comm deallocate ( pf_comm % recvreq ) deallocate ( pf_comm % sendreq ) end subroutine pf_mpi_destroy","tags":"","loc":"proc/pf_mpi_destroy.html","title":"pf_mpi_destroy – LibPFASST"},{"text":"public subroutine pf_mpi_post(pf, level, tag, ierror, source) Subroutine to post receive requests. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf class( pf_level_t ), intent(inout) :: level level to send from integer, intent(in) :: tag message tag integer, intent(inout) :: ierror error flag integer, intent(in) :: source Calls proc~~pf_mpi_post~~CallsGraph proc~pf_mpi_post pf_mpi_post mpi_irecv mpi_irecv proc~pf_mpi_post->mpi_irecv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_mpi_post Source Code subroutine pf_mpi_post ( pf , level , tag , ierror , source ) type ( pf_pfasst_t ), intent ( in ) :: pf class ( pf_level_t ), intent ( inout ) :: level !!  level to send from integer , intent ( in ) :: tag !!  message tag integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source call mpi_irecv ( level % recv , level % mpibuflen , myMPI_Datatype , & source , tag , pf % comm % comm , pf % comm % recvreq ( level % index ), ierror ) end subroutine pf_mpi_post","tags":"","loc":"proc/pf_mpi_post.html","title":"pf_mpi_post – LibPFASST"},{"text":"public subroutine pf_mpi_send_status(pf, tag, istatus, ierror, dest) Uses pf_mod_mpi proc~~pf_mpi_send_status~~UsesGraph proc~pf_mpi_send_status pf_mpi_send_status module~pf_mod_mpi pf_mod_mpi proc~pf_mpi_send_status->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to send convergence status information Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: tag message tag integer, intent(in) :: istatus status flag to send integer, intent(inout) :: ierror error flag integer, intent(in) :: dest Calls proc~~pf_mpi_send_status~~CallsGraph proc~pf_mpi_send_status pf_mpi_send_status mpi_issend mpi_issend proc~pf_mpi_send_status->mpi_issend mpi_wait mpi_wait proc~pf_mpi_send_status->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_mpi_send_status Source Code subroutine pf_mpi_send_status ( pf , tag , istatus , ierror , dest ) use pf_mod_mpi , only : MPI_INTEGER , MPI_STATUS_SIZE , MPI_REQUEST_NULL type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: tag !!  message tag integer , intent ( in ) :: istatus !!  status flag to send integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: dest integer :: stat ( MPI_STATUS_SIZE ) integer :: message message = istatus if ( pf % comm % statreq /= - 66 ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'waiting in send_status with statreq' , pf % comm % statreq call mpi_wait ( pf % comm % statreq , stat , ierror ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'done waiting in send_status' end if call mpi_issend ( message , 1 , MPI_INTEGER , & dest , tag , pf % comm % comm , pf % comm % statreq , ierror ) end subroutine pf_mpi_send_status","tags":"","loc":"proc/pf_mpi_send_status.html","title":"pf_mpi_send_status – LibPFASST"},{"text":"public subroutine pf_mpi_recv_status(pf, tag, istatus, ierror, source) Uses pf_mod_mpi proc~~pf_mpi_recv_status~~UsesGraph proc~pf_mpi_recv_status pf_mpi_recv_status module~pf_mod_mpi pf_mod_mpi proc~pf_mpi_recv_status->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to receive convergence status information Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: tag message tag integer, intent(inout) :: istatus status flag to receive integer, intent(inout) :: ierror error flag integer, intent(in) :: source Calls proc~~pf_mpi_recv_status~~CallsGraph proc~pf_mpi_recv_status pf_mpi_recv_status mpi_recv mpi_recv proc~pf_mpi_recv_status->mpi_recv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_mpi_recv_status Source Code subroutine pf_mpi_recv_status ( pf , tag , istatus , ierror , source ) use pf_mod_mpi , only : MPI_INTEGER , MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: tag !!  message tag integer , intent ( inout ) :: istatus !!  status flag to receive integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source integer :: stat ( MPI_STATUS_SIZE ) integer :: message ! Get the message call mpi_recv ( message , 1 , MPI_INTEGER , source , tag , pf % comm % comm , stat , ierror ) istatus = message end subroutine pf_mpi_recv_status","tags":"","loc":"proc/pf_mpi_recv_status.html","title":"pf_mpi_recv_status – LibPFASST"},{"text":"public subroutine pf_mpi_send(pf, level, tag, blocking, ierror, dest) Uses pf_mod_mpi proc~~pf_mpi_send~~UsesGraph proc~pf_mpi_send pf_mpi_send module~pf_mod_mpi pf_mod_mpi proc~pf_mpi_send->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to send solutions Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: level level to send from integer, intent(in) :: tag message tag logical, intent(in) :: blocking true if send is blocking integer, intent(inout) :: ierror error flag integer, intent(in) :: dest Calls proc~~pf_mpi_send~~CallsGraph proc~pf_mpi_send pf_mpi_send mpi_send mpi_send proc~pf_mpi_send->mpi_send mpi_isend mpi_isend proc~pf_mpi_send->mpi_isend mpi_wait mpi_wait proc~pf_mpi_send->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_mpi_send Source Code subroutine pf_mpi_send ( pf , level , tag , blocking , ierror , dest ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: level !!  level to send from integer , intent ( in ) :: tag !!  message tag logical , intent ( in ) :: blocking !!  true if send is blocking integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: dest integer :: stat ( MPI_STATUS_SIZE ) if ( blocking ) then call mpi_send ( level % send , level % mpibuflen , myMPI_Datatype , & dest , tag , pf % comm % comm , stat , ierror ) else call mpi_wait ( pf % comm % sendreq ( level % index ), stat , ierror ) call mpi_isend ( level % send , level % mpibuflen , myMPI_Datatype , & dest , tag , pf % comm % comm , pf % comm % sendreq ( level % index ), ierror ) end if end subroutine pf_mpi_send","tags":"","loc":"proc/pf_mpi_send.html","title":"pf_mpi_send – LibPFASST"},{"text":"public subroutine pf_mpi_recv(pf, level, tag, blocking, ierror, source) Uses pf_mod_mpi proc~~pf_mpi_recv~~UsesGraph proc~pf_mpi_recv pf_mpi_recv module~pf_mod_mpi pf_mod_mpi proc~pf_mpi_recv->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to receive solutions\n Note when blocking == .false. this is actually a wait because the\n nonblocking receive  should have already been posted Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: level level to recieve into integer, intent(in) :: tag message tag logical, intent(in) :: blocking true if receive is blocking integer, intent(inout) :: ierror error flag integer, intent(in) :: source Calls proc~~pf_mpi_recv~~CallsGraph proc~pf_mpi_recv pf_mpi_recv mpi_recv mpi_recv proc~pf_mpi_recv->mpi_recv mpi_wait mpi_wait proc~pf_mpi_recv->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_mpi_recv Source Code subroutine pf_mpi_recv ( pf , level , tag , blocking , ierror , source ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: level !!  level to recieve into integer , intent ( in ) :: tag !!  message tag logical , intent ( in ) :: blocking !!  true if receive is blocking integer , intent ( inout ) :: ierror !!  error flag integer , intent ( in ) :: source integer :: stat ( MPI_STATUS_SIZE ) if ( blocking ) then call mpi_recv ( level % recv , level % mpibuflen , myMPI_Datatype , & source , tag , pf % comm % comm , stat , ierror ) else call mpi_wait ( pf % comm % recvreq ( level % index ), stat , ierror ) end if end subroutine pf_mpi_recv","tags":"","loc":"proc/pf_mpi_recv.html","title":"pf_mpi_recv – LibPFASST"},{"text":"public subroutine pf_mpi_wait(pf, level, ierror) Uses pf_mod_mpi proc~~pf_mpi_wait~~UsesGraph proc~pf_mpi_wait pf_mpi_wait module~pf_mod_mpi pf_mod_mpi proc~pf_mpi_wait->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf main pfasst structure integer, intent(in) :: level level on which to wait integer, intent(inout) :: ierror error flag Calls proc~~pf_mpi_wait~~CallsGraph proc~pf_mpi_wait pf_mpi_wait mpi_wait mpi_wait proc~pf_mpi_wait->mpi_wait Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_mpi_wait Source Code subroutine pf_mpi_wait ( pf , level , ierror ) use pf_mod_mpi , only : MPI_STATUS_SIZE type ( pf_pfasst_t ), intent ( in ) :: pf !!  main pfasst structure integer , intent ( in ) :: level !!  level on which to wait integer , intent ( inout ) :: ierror !!  error flag integer :: stat ( MPI_STATUS_SIZE ) call mpi_wait ( pf % comm % sendreq ( level ), stat , ierror ) end subroutine pf_mpi_wait","tags":"","loc":"proc/pf_mpi_wait.html","title":"pf_mpi_wait – LibPFASST"},{"text":"public subroutine pf_mpi_broadcast(pf, y, nvar, root, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure real(kind=pfdp), intent(in) :: y (nvar) data to broadcast integer, intent(in) :: nvar size of data to broadcast integer, intent(in) :: root rank of broadcaster integer, intent(inout) :: ierror error flag Calls proc~~pf_mpi_broadcast~~CallsGraph proc~pf_mpi_broadcast pf_mpi_broadcast mpi_bcast mpi_bcast proc~pf_mpi_broadcast->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_mpi_broadcast Source Code subroutine pf_mpi_broadcast ( pf , y , nvar , root , ierror ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure integer , intent ( in ) :: nvar !!  size of data to broadcast real ( pfdp ), intent ( in ) :: y ( nvar ) !!  data to broadcast integer , intent ( in ) :: root !!  rank of broadcaster integer , intent ( inout ) :: ierror !!  error flag call mpi_bcast ( y , nvar , myMPI_Datatype , root , pf % comm % comm , ierror ) end subroutine pf_mpi_broadcast","tags":"","loc":"proc/pf_mpi_broadcast.html","title":"pf_mpi_broadcast – LibPFASST"},{"text":"public subroutine pf_pfasst_create(pf, comm, nlevels, fname, nocmd) Uses pf_mod_hooks proc~~pf_pfasst_create~~UsesGraph proc~pf_pfasst_create pf_pfasst_create module~pf_mod_hooks pf_mod_hooks proc~pf_pfasst_create->module~pf_mod_hooks module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Create a PFASST object\n gather some input from a file and command line\n  fname  present,  read inputs from a file (and maybe command line)\n  fname not present, only call read_opts if we want command line read\n  set communicator Set up the mpi communicator\n  allocate level pointers\n  loop over levels to set parameters\n  allocate hooks\n  allocate status Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Main pfasst object type( pf_comm_t ), intent(inout), target :: comm Communicator integer, intent(in), optional :: nlevels number of pfasst levels character(len=*), intent(in), optional :: fname Input file for pfasst parameters logical, intent(in), optional :: nocmd Determines if command line variables are to be read Calls proc~~pf_pfasst_create~~CallsGraph proc~pf_pfasst_create pf_pfasst_create proc~pf_mpi_setup pf_mpi_setup proc~pf_pfasst_create->proc~pf_mpi_setup proc~pf_stop pf_stop proc~pf_pfasst_create->proc~pf_stop proc~pf_read_opts pf_read_opts proc~pf_pfasst_create->proc~pf_read_opts mpi_comm_rank mpi_comm_rank proc~pf_mpi_setup->mpi_comm_rank proc~pf_read_opts->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_pfasst_create Source Code subroutine pf_pfasst_create ( pf , comm , nlevels , fname , nocmd ) use pf_mod_hooks , only : PF_MAX_HOOK type ( pf_pfasst_t ), intent ( inout ) :: pf !! Main pfasst object type ( pf_comm_t ), intent ( inout ), target :: comm !! Communicator integer , intent ( in ), optional :: nlevels !! number of pfasst levels character ( len =* ), intent ( in ), optional :: fname !! Input file for pfasst parameters logical , intent ( in ), optional :: nocmd !! Determines if command line variables are to be read logical :: read_cmd !! Local version of nocmd integer :: ierr integer :: l !!  Loop variable for levels if ( present ( nlevels )) pf % nlevels = nlevels pf % outdir = \"\" !> gather some input from a file and command line read_cmd = . true . if ( present ( nocmd )) then if ( nocmd ) read_cmd = . false . end if if ( present ( fname )) then !!  fname  present,  read inputs from a file (and maybe command line) call pf_read_opts ( pf , read_cmd , fname ) else !!  fname not present, only call read_opts if we want command line read if ( read_cmd ) call pf_read_opts ( pf , read_cmd ) end if !>  set communicator pf % comm => comm !>  Set up the mpi communicator call pf_mpi_setup ( pf % comm , pf , ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"ERROR: mpi_setup failed\" ) if ( pf % rank < 0 ) then call pf_stop ( __ FILE__ , __ LINE__ ,& \"Invalid PF rank: did you call setup correctly?\" ) end if !>  allocate level pointers allocate ( pf % levels ( pf % nlevels ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error\" , pf % nlevels ) !>  loop over levels to set parameters do l = 1 , pf % nlevels pf % levels ( l )% index = l pf % levels ( l )% nsweeps = pf % nsweeps ( l ) pf % levels ( l )% nsweeps_pred = pf % nsweeps_pred ( l ) pf % levels ( l )% nnodes = pf % nnodes ( l ) pf % levels ( l )% Finterp = pf % Finterp pf % levels ( l )% nsteps_rk = pf % nsteps_rk ( l ) end do !>  allocate hooks allocate ( pf % hooks ( pf % nlevels , PF_MAX_HOOK , PF_MAX_HOOKS ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error hooks\" ) allocate ( pf % nhooks ( pf % nlevels , PF_MAX_HOOK ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error nhooks\" ) pf % nhooks = 0 !>  allocate status allocate ( pf % state , stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ ,& \"allocate error state\" ) pf % state % pstatus = 0 pf % state % status = 0 end subroutine pf_pfasst_create","tags":"","loc":"proc/pf_pfasst_create.html","title":"pf_pfasst_create – LibPFASST"},{"text":"public subroutine pf_pfasst_setup(pf) Setup both the PFASST object and the comm object\n  loop over levels to set parameters\n  Loop over levels setting interpolation and restriction matrices (in time) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf Main pfasst structure Calls proc~~pf_pfasst_setup~~CallsGraph proc~pf_pfasst_setup pf_pfasst_setup proc~pf_level_setup pf_level_setup proc~pf_pfasst_setup->proc~pf_level_setup proc~pf_time_interpolation_matrix pf_time_interpolation_matrix proc~pf_pfasst_setup->proc~pf_time_interpolation_matrix proc~pf_init_sdcmats pf_init_sdcmats proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_make_matrices pf_make_matrices proc~pf_init_sdcmats->proc~pf_make_matrices proc~pf_quadrature pf_quadrature proc~pf_init_sdcmats->proc~pf_quadrature proc~myluq myLUq proc~pf_make_matrices->proc~myluq proc~sdc_qnodes sdc_qnodes proc~pf_quadrature->proc~sdc_qnodes proc~pf_stop pf_stop proc~pf_quadrature->proc~pf_stop proc~sdc_qmats sdc_qmats proc~pf_quadrature->proc~sdc_qmats proc~sdc_qnodes->proc~pf_stop proc~poly_legendre poly_legendre proc~sdc_qnodes->proc~poly_legendre proc~poly_diff poly_diff proc~sdc_qnodes->proc~poly_diff proc~poly_roots poly_roots proc~sdc_qnodes->proc~poly_roots proc~myluq->proc~pf_stop proc~poly_int poly_int proc~sdc_qmats->proc~poly_int proc~not_proper not_proper proc~sdc_qmats->proc~not_proper interface~poly_eval poly_eval proc~sdc_qmats->interface~poly_eval proc~qsort qsort proc~poly_roots->proc~qsort proc~poly_eval_complex poly_eval_complex proc~poly_roots->proc~poly_eval_complex interface~poly_eval->interface~poly_eval interface~poly_eval->proc~poly_eval_complex var panprocpf_pfasst_setupCallsGraph = svgPanZoom('#procpf_pfasst_setupCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_pfasst_setup Source Code subroutine pf_pfasst_setup ( pf ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  Main pfasst structure class ( pf_level_t ), pointer :: lev_fine , lev_coarse !!  Pointers to level structures for brevity integer :: l !!  Level loop index integer :: ierr !!  error flag !>  loop over levels to set parameters do l = 1 , pf % nlevels call pf_level_setup ( pf , pf % levels ( l )) end do !>  Loop over levels setting interpolation and restriction matrices (in time) do l = pf % nlevels , 2 , - 1 lev_fine => pf % levels ( l ); lev_coarse => pf % levels ( l - 1 ) allocate ( lev_fine % tmat ( lev_fine % nnodes , lev_coarse % nnodes ), stat = ierr ) if ( ierr /= 0 ) & call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" , lev_fine % nnodes ) allocate ( lev_fine % rmat ( lev_coarse % nnodes , lev_fine % nnodes ), stat = ierr ) if ( ierr /= 0 ) & call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" , lev_fine % nnodes ) ! with the RK stepper, no need to interpolate and restrict in time ! we only copy the first node and last node betweem levels if ( pf % use_rk_stepper . eqv . . true .) then lev_fine % tmat = 0.0_pfdp lev_fine % rmat = 0.0_pfdp lev_fine % tmat ( 1 , 1 ) = 1.0_pfdp lev_fine % tmat ( lev_fine % nnodes , lev_coarse % nnodes ) = 1.0_pfdp lev_fine % rmat ( 1 , 1 ) = 1.0_pfdp lev_fine % rmat ( lev_coarse % nnodes , lev_fine % nnodes ) = 1.0_pfdp else ! else compute the interpolation matrix call pf_time_interpolation_matrix ( lev_fine % nodes , lev_fine % nnodes , lev_coarse % nodes , lev_coarse % nnodes , lev_fine % tmat ) call pf_time_interpolation_matrix ( lev_coarse % nodes , lev_coarse % nnodes , lev_fine % nodes , lev_fine % nnodes , lev_fine % rmat ) endif end do end subroutine pf_pfasst_setup","tags":"","loc":"proc/pf_pfasst_setup.html","title":"pf_pfasst_setup – LibPFASST"},{"text":"public subroutine pf_level_setup(pf, lev) Uses pf_mod_quadrature proc~~pf_level_setup~~UsesGraph proc~pf_level_setup pf_level_setup module~pf_mod_quadrature pf_mod_quadrature proc~pf_level_setup->module~pf_mod_quadrature module~pf_mod_utils pf_mod_utils module~pf_mod_quadrature->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_quadrature->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi var panprocpf_level_setupUsesGraph = svgPanZoom('#procpf_level_setupUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Setup (allocate) PFASST level\n If the level is already setup, calling this again will allocate\n (or deallocate) tauQ appropriately.\n do some sanity checks\n (re)allocate tauQ (may to need create/destroy tauQ dynamically  when doing AMR)\n skip the rest if we're already allocated\n allocate flat buffers for send, and recv\n allocate nodes, flags, and integration matrices\n  Allocate and compute all the matrices\n  initialize sweeper\n allocate solution and function arrays Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf Main pfasst structure class( pf_level_t ), intent(inout), target :: lev Level to set up Calls proc~~pf_level_setup~~CallsGraph proc~pf_level_setup pf_level_setup proc~pf_init_sdcmats pf_init_sdcmats proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_make_matrices pf_make_matrices proc~pf_init_sdcmats->proc~pf_make_matrices proc~pf_quadrature pf_quadrature proc~pf_init_sdcmats->proc~pf_quadrature proc~myluq myLUq proc~pf_make_matrices->proc~myluq proc~sdc_qnodes sdc_qnodes proc~pf_quadrature->proc~sdc_qnodes proc~pf_stop pf_stop proc~pf_quadrature->proc~pf_stop proc~sdc_qmats sdc_qmats proc~pf_quadrature->proc~sdc_qmats proc~sdc_qnodes->proc~pf_stop proc~poly_legendre poly_legendre proc~sdc_qnodes->proc~poly_legendre proc~poly_diff poly_diff proc~sdc_qnodes->proc~poly_diff proc~poly_roots poly_roots proc~sdc_qnodes->proc~poly_roots proc~myluq->proc~pf_stop proc~poly_int poly_int proc~sdc_qmats->proc~poly_int proc~not_proper not_proper proc~sdc_qmats->proc~not_proper interface~poly_eval poly_eval proc~sdc_qmats->interface~poly_eval proc~qsort qsort proc~poly_roots->proc~qsort proc~poly_eval_complex poly_eval_complex proc~poly_roots->proc~poly_eval_complex interface~poly_eval->interface~poly_eval interface~poly_eval->proc~poly_eval_complex var panprocpf_level_setupCallsGraph = svgPanZoom('#procpf_level_setupCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_level_setup~~CalledByGraph proc~pf_level_setup pf_level_setup proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_level_setup Source Code subroutine pf_level_setup ( pf , lev ) use pf_mod_quadrature type ( pf_pfasst_t ), intent ( in ) :: pf !!  Main pfasst structure class ( pf_level_t ), intent ( inout ), target :: lev !!  Level to set up integer :: mpibuflen , nnodes , npieces , nnodes0 integer :: i , ierr !> do some sanity checks mpibuflen = lev % mpibuflen if ( mpibuflen <= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , 'allocate fail' , mpibuflen ) nnodes = lev % nnodes if ( nnodes <= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , 'allocate fail' , nnodes ) lev % residual = - 1.0_pfdp !> (re)allocate tauQ (may to need create/destroy tauQ dynamically  when doing AMR) if (( lev % index < pf % nlevels ) . and . (. not . allocated ( lev % tauQ ))) then call lev % ulevel % factory % create_array ( lev % tauQ , nnodes - 1 , lev % index , lev % shape ) else if (( lev % index >= pf % nlevels ) . and . ( allocated ( lev % tauQ ))) then deallocate ( lev % tauQ ) end if !> skip the rest if we're already allocated if ( lev % allocated ) return lev % allocated = . true . !> allocate flat buffers for send, and recv allocate ( lev % send ( mpibuflen ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) allocate ( lev % recv ( mpibuflen ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) !> allocate nodes, flags, and integration matrices allocate ( lev % nodes ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) allocate ( lev % nflags ( nnodes ), stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate fail\" ) lev % nflags = 0 !>  Allocate and compute all the matrices allocate ( lev % sdcmats , stat = ierr ) if ( ierr /= 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"allocate error sdcmats\" ) call pf_init_sdcmats ( pf , lev % sdcmats , nnodes , lev % nflags ) lev % nodes = lev % sdcmats % qnodes !>  initialize sweeper lev % ulevel % sweeper % use_LUq = pf % use_LUq call lev % ulevel % sweeper % initialize ( lev ) if ( pf % use_rk_stepper ) call lev % ulevel % stepper % initialize ( lev ) !> allocate solution and function arrays npieces = lev % ulevel % sweeper % npieces call lev % ulevel % factory % create_array ( lev % Q , nnodes , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( lev % Fflt , nnodes * npieces , lev % index , lev % shape ) do i = 1 , nnodes * npieces call lev % Fflt ( i )% setval ( 0.0_pfdp , 0 ) end do lev % F ( 1 : nnodes , 1 : npieces ) => lev % Fflt call lev % ulevel % factory % create_array ( lev % I , nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( lev % R , nnodes - 1 , lev % index , lev % shape ) !  Need space for old function values in imexR sweepers call lev % ulevel % factory % create_array ( lev % pFflt , nnodes * npieces , lev % index , lev % shape ) lev % pF ( 1 : nnodes , 1 : npieces ) => lev % pFflt if ( lev % index < pf % nlevels ) then call lev % ulevel % factory % create_array ( lev % pQ , nnodes , lev % index , lev % shape ) end if call lev % ulevel % factory % create_single ( lev % qend , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( lev % q0 , lev % index , lev % shape ) end subroutine pf_level_setup","tags":"","loc":"proc/pf_level_setup.html","title":"pf_level_setup – LibPFASST"},{"text":"public subroutine pf_pfasst_destroy(pf) Deallocate PFASST object\n  destroy all levels\n  deallocate pfasst pointer arrays Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Main pfasst structure Calls proc~~pf_pfasst_destroy~~CallsGraph proc~pf_pfasst_destroy pf_pfasst_destroy proc~pf_mpi_destroy pf_mpi_destroy proc~pf_pfasst_destroy->proc~pf_mpi_destroy proc~pf_level_destroy pf_level_destroy proc~pf_pfasst_destroy->proc~pf_level_destroy proc~pf_destroy_sdcmats pf_destroy_sdcmats proc~pf_level_destroy->proc~pf_destroy_sdcmats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_pfasst_destroy Source Code subroutine pf_pfasst_destroy ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  Main pfasst structure integer :: l !>  destroy all levels do l = 1 , pf % nlevels call pf_level_destroy ( pf % levels ( l ), pf % nlevels ) end do !>  deallocate pfasst pointer arrays !    call pf%destroy_results() deallocate ( pf % levels ) deallocate ( pf % hooks ) deallocate ( pf % nhooks ) deallocate ( pf % state ) call pf_mpi_destroy ( pf % comm ) end subroutine pf_pfasst_destroy","tags":"","loc":"proc/pf_pfasst_destroy.html","title":"pf_pfasst_destroy – LibPFASST"},{"text":"public subroutine pf_level_destroy(lev, nlevels) Uses pf_mod_quadrature proc~~pf_level_destroy~~UsesGraph proc~pf_level_destroy pf_level_destroy module~pf_mod_quadrature pf_mod_quadrature proc~pf_level_destroy->module~pf_mod_quadrature module~pf_mod_utils pf_mod_utils module~pf_mod_quadrature->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_quadrature->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi var panprocpf_level_destroyUsesGraph = svgPanZoom('#procpf_level_destroyUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Deallocate PFASST level\n deallocate flat buffers for communcition\n deallocate nodes, flags, and integration matrices\n deallocate solution and function storage destroy the sweeper deallocate misc. arrays Arguments Type Intent Optional Attributes Name class( pf_level_t ), intent(inout) :: lev level to destroy integer :: nlevels number of pfasst levels Calls proc~~pf_level_destroy~~CallsGraph proc~pf_level_destroy pf_level_destroy proc~pf_destroy_sdcmats pf_destroy_sdcmats proc~pf_level_destroy->proc~pf_destroy_sdcmats Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_level_destroy~~CalledByGraph proc~pf_level_destroy pf_level_destroy proc~pf_pfasst_destroy pf_pfasst_destroy proc~pf_pfasst_destroy->proc~pf_level_destroy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_level_destroy Source Code subroutine pf_level_destroy ( lev , nlevels ) use pf_mod_quadrature class ( pf_level_t ), intent ( inout ) :: lev !!  level to destroy integer :: nlevels !!  number of pfasst levels integer :: npieces !!  local copy of number of function pieces if (. not . lev % allocated ) return !> deallocate flat buffers for communcition deallocate ( lev % send ) deallocate ( lev % recv ) !> deallocate nodes, flags, and integration matrices deallocate ( lev % nodes ) deallocate ( lev % nflags ) call pf_destroy_sdcmats ( lev % sdcmats ) deallocate ( lev % sdcmats ) !> deallocate solution and function storage npieces = lev % ulevel % sweeper % npieces if (( lev % index < nlevels ) . and . allocated ( lev % tauQ )) then call lev % ulevel % factory % destroy_array ( lev % tauQ , lev % nnodes - 1 , lev % index , lev % shape ) end if call lev % ulevel % factory % destroy_array ( lev % Q , lev % nnodes , lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( lev % Fflt , lev % nnodes * npieces , lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( lev % I , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( lev % R , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( lev % pFflt , lev % nnodes * npieces , lev % index , lev % shape ) if ( lev % index < nlevels ) then call lev % ulevel % factory % destroy_array ( lev % pQ , lev % nnodes , lev % index , lev % shape ) end if call lev % ulevel % factory % destroy_single ( lev % qend , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( lev % q0 , lev % index , lev % shape ) !> destroy the sweeper call lev % ulevel % sweeper % destroy ( lev ) !> deallocate misc. arrays if ( allocated ( lev % shape )) then deallocate ( lev % shape ) end if if ( allocated ( lev % tmat )) then deallocate ( lev % tmat ) end if if ( allocated ( lev % rmat )) then deallocate ( lev % rmat ) end if end subroutine pf_level_destroy","tags":"","loc":"proc/pf_level_destroy.html","title":"pf_level_destroy – LibPFASST"},{"text":"public subroutine pf_read_opts(pf, read_cmd, fname) Subroutine to read pfasst options from file and command line\n define the namelist for reading\n set local variables to pf_pfasst defaults\n open the file \"fname\" and read the pfasst namelist\n overwrite parameters defined on  command line\n re-assign the pfasst internals\n  Sanity check Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf logical, intent(in) :: read_cmd character(len=*), intent(in), optional :: fname Calls proc~~pf_read_opts~~CallsGraph proc~pf_read_opts pf_read_opts proc~pf_stop pf_stop proc~pf_read_opts->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_read_opts~~CalledByGraph proc~pf_read_opts pf_read_opts proc~pf_pfasst_create pf_pfasst_create proc~pf_pfasst_create->proc~pf_read_opts Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_read_opts Source Code subroutine pf_read_opts ( pf , read_cmd , fname ) type ( pf_pfasst_t ), intent ( inout ) :: pf logical , intent ( in ) :: read_cmd character ( len =* ), intent ( in ), optional :: fname ! local versions of pfasst parameters integer :: niters , nlevels , qtype integer :: nsweeps ( PF_MAXLEVS ) integer :: nsweeps_pred ( PF_MAXLEVS ) integer :: nnodes ( PF_MAXLEVS ) integer :: nsteps_rk ( PF_MAXLEVS ) real ( pfdp ) :: abs_res_tol , rel_res_tol logical :: PFASST_pred , RK_pred , pipeline_pred integer :: nsweeps_burn , q0_style , taui0 logical :: Vcycle , Finterp , use_LUq logical :: debug , use_rk_stepper logical :: save_timings , echo_timings , save_residuals , save_errors logical :: use_no_left_q , use_composite_nodes , use_proper_nodes ! stuff for reading the command line integer , parameter :: un = 9 integer :: i , ios character ( len = 32 ) :: arg character ( len = 255 ) :: istring ! stores command line argument character ( len = 255 ) :: message ! use for i/o error messages character ( len = 512 ) :: outdir !> define the namelist for reading namelist / pf_params / niters , nlevels , qtype , nsweeps , nsweeps_pred , nnodes , nsteps_rk , abs_res_tol , rel_res_tol namelist / pf_params / PFASST_pred , RK_pred , pipeline_pred , nsweeps_burn , q0_style , taui0 namelist / pf_params / Vcycle , Finterp , use_LUq , echo_timings , debug , save_timings , save_residuals , save_errors , use_rk_stepper namelist / pf_params / use_no_left_q , use_composite_nodes , use_proper_nodes !> set local variables to pf_pfasst defaults nlevels = pf % nlevels niters = pf % niters qtype = pf % qtype nsweeps = pf % nsweeps nsweeps_pred = pf % nsweeps_pred nnodes = pf % nnodes abs_res_tol = pf % abs_res_tol rel_res_tol = pf % rel_res_tol pfasst_pred = pf % pfasst_pred pipeline_pred = pf % pipeline_pred nsweeps_burn = pf % nsweeps_burn q0_style = pf % q0_style Vcycle = pf % Vcycle Finterp = pf % Finterp use_LUq = pf % use_LUq taui0 = pf % taui0 outdir = pf % outdir debug = pf % debug save_residuals = pf % save_residuals save_errors = pf % save_errors save_timings = pf % save_timings echo_timings = pf % echo_timings nsteps_rk = pf % nsteps_rk rk_pred = pf % rk_pred use_rk_stepper = pf % use_rk_stepper use_no_left_q = pf % use_no_left_q use_composite_nodes = pf % use_composite_nodes use_proper_nodes = pf % use_proper_nodes !> open the file \"fname\" and read the pfasst namelist if ( present ( fname )) then open ( unit = un , file = fname , status = 'old' , action = 'read' ) read ( unit = un , nml = pf_params ) close ( unit = un ) end if !> overwrite parameters defined on  command line if ( read_cmd ) then i = 0 do call get_command_argument ( i , arg ) if ( len_trim ( arg ) == 0 ) exit if ( i > 0 ) then istring = \"&pf_params \" // trim ( arg ) // \" /\" read ( istring , nml = pf_params , iostat = ios , iomsg = message ) ! internal read of namelist end if i = i + 1 end do end if !> re-assign the pfasst internals pf % nlevels = nlevels pf % niters = niters pf % qtype = qtype pf % nsweeps = nsweeps pf % nsweeps_pred = nsweeps_pred pf % nnodes = nnodes pf % abs_res_tol = abs_res_tol pf % rel_res_tol = rel_res_tol pf % pfasst_pred = pfasst_pred pf % pipeline_pred = pipeline_pred pf % nsweeps_burn = nsweeps_burn pf % q0_style = q0_style pf % Vcycle = Vcycle pf % Finterp = Finterp pf % use_LUq = use_LUq pf % taui0 = taui0 pf % outdir = outdir pf % debug = debug pf % echo_timings = echo_timings pf % save_residuals = save_residuals pf % save_timings = save_timings pf % save_errors = save_errors pf % use_rk_stepper = use_rk_stepper pf % nsteps_rk = nsteps_rk pf % rk_pred = rk_pred pf % use_no_left_q = use_no_left_q pf % use_composite_nodes = use_composite_nodes pf % use_proper_nodes = use_proper_nodes !>  Sanity check if ( pf % nlevels < 1 ) then call pf_stop ( __ FILE__ , __ LINE__ , 'Bad specification for nlevels' , pf % nlevels ) endif end subroutine pf_read_opts","tags":"","loc":"proc/pf_read_opts.html","title":"pf_read_opts – LibPFASST"},{"text":"public subroutine pf_print_options(pf, un_opt, show_mats_opt) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in), optional :: un_opt logical, intent(in), optional :: show_mats_opt Calls proc~~pf_print_options~~CallsGraph proc~pf_print_options pf_print_options proc~pf_stop pf_stop proc~pf_print_options->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_print_options Source Code subroutine pf_print_options ( pf , un_opt , show_mats_opt ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ), optional :: un_opt logical , intent ( in ), optional :: show_mats_opt integer :: un = 6 logical :: show_mats = . FALSE . integer :: l , i character ( 8 ) :: date character ( 10 ) :: time if ( pf % rank /= 0 ) return if ( present ( un_opt )) un = un_opt write ( un , * ) '==================================================' write ( un , * ) 'PFASST Configuration' write ( un , * ) '--------------------' call date_and_time ( date = date , time = time ) write ( un , * ) 'date:        ' , date write ( un , * ) 'time:        ' , time write ( un , * ) 'double precision:   ' , pfdp , '  bytes' write ( un , * ) 'quad precision:   ' , pfqp , '  bytes' write ( un , * ) 'nlevels:     ' , pf % nlevels , '! number of pfasst levels' write ( un , * ) 'nprocs:      ' , pf % comm % nproc , '! number of pfasst \"time\" processors' if ( pf % comm % nproc == 1 ) then write ( un , * ) '            ' , '             ' , ' ! since 1 time proc is being used, this is a serial sdc run' else write ( un , * ) '            ' , '             ' , ' ! since >1 time procs are being used, this is a parallel pfasst run' end if write ( un , * ) 'niters:      ' , pf % niters , '! maximum number of sdc/pfasst iterations' select case ( pf % qtype ) case ( SDC_GAUSS_LEGENDRE ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Legendre nodes are used' case ( SDC_GAUSS_LOBATTO ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Lobatto nodes are used' case ( SDC_GAUSS_RADAU ) write ( un , * ) 'qtype:' , pf % qtype , '! Gauss Radua nodes are used' case ( SDC_CLENSHAW_CURTIS ) write ( un , * ) 'qtype:' , pf % qtype , '! Clenshaw Curtis nodes are used' case ( SDC_UNIFORM ) write ( un , * ) 'qtype:' , pf % qtype , '! Uniform  nodes are used' case ( SDC_CHEBYSHEV ) write ( un , * ) 'qtype:' , pf % qtype , '! Chebyshev  nodes are used' case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , pf % qtype ) end select if ( pf % use_proper_nodes ) write ( un , * ) 'Using proper node nesting' if ( pf % use_composite_nodes ) write ( un , * ) 'Using composite node nesting' if ( pf % use_no_left_q ) write ( un , * ) ' Skipping left end point in quadruture rule ' write ( un , * ) 'nnodes:      ' , pf % levels ( 1 : pf % nlevels )% nnodes , '! number of sdc nodes per level' write ( un , * ) 'mpibuflen:   ' , pf % levels ( 1 : pf % nlevels )% mpibuflen , '! size of data send between time steps' write ( un , * ) 'nsweeps:     ' , pf % levels ( 1 : pf % nlevels )% nsweeps , '! number of sdc sweeps performed per visit to each level' write ( un , * ) 'nsweeps_pred:     ' , pf % levels ( 1 : pf % nlevels )% nsweeps_pred , '! number of sdc sweeps in predictor' write ( un , * ) 'taui0:     ' , pf % taui0 , '! cutoff for tau correction' write ( un , * ) 'abs_res_tol:' , pf % abs_res_tol , '! absolute residual tolerance: ' write ( un , * ) 'rel_res_tol:' , pf % rel_res_tol , '! relative residual tolerance: ' if ( pf % use_Luq ) then write ( un , * ) 'Implicit matrix is LU  ' else write ( un , * ) 'Implicit matrix is backward Euler  ' end if if ( pf % Vcycle ) then write ( un , * ) 'V-cycling is on' else write ( un , * ) 'V-cycling is off, fine level is pipelining' end if if ( pf % rk_pred ) then write ( un , * ) 'Runge-Kutta used for predictor' else if ( pf % pipeline_pred ) then write ( un , * ) 'Predictor pipelining is ON    ' else write ( un , * ) 'Predictor pipelining is OFF    ' end if if ( pf % PFASST_pred ) then write ( un , * ) 'PFASST Predictor style  ' else write ( un , * ) 'Serial Predictor style  ' end if endif if ( pf % debug ) write ( un , * ) 'Debug mode is on ' write ( un , * ) '' if ( present ( show_mats_opt )) show_mats = show_mats_opt if ( show_mats ) then do l = 1 , pf % nlevels print * , \"Level\" , l print * , \"-----------------\" print * , \"  nodes\" print * , pf % levels ( l )% nodes print * , \"  Q\" do i = 1 , pf % levels ( l )% nnodes - 1 print * , pf % levels ( l )% sdcmats % qmat ( i ,:) end do end do end if end subroutine pf_print_options","tags":"","loc":"proc/pf_print_options.html","title":"pf_print_options – LibPFASST"},{"text":"public subroutine pf_time_interpolation_matrix(f_nodes, f_nnodes, c_nodes, c_nnodes, tmat) Subroutine to make the matrices for interpolation  between noodes Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: f_nodes (0:f_nnodes-1) quadrature nodes on fine  level integer, intent(in) :: f_nnodes number of nodes on fine level real(kind=pfdp), intent(in) :: c_nodes (0:c_nnodes-1) quadrature nodes on coarse  level integer, intent(in) :: c_nnodes number of nodes on coarse  level real(kind=pfdp), intent(out) :: tmat (0:f_nnodes-1,0:c_nnodes-1) Interpolation matrix to compute Called by proc~~pf_time_interpolation_matrix~~CalledByGraph proc~pf_time_interpolation_matrix pf_time_interpolation_matrix proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_time_interpolation_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_time_interpolation_matrix Source Code subroutine pf_time_interpolation_matrix ( f_nodes , f_nnodes , c_nodes , c_nnodes , tmat ) integer , intent ( in ) :: f_nnodes !!  number of nodes on fine level integer , intent ( in ) :: c_nnodes !!  number of nodes on coarse  level real ( pfdp ), intent ( in ) :: f_nodes ( 0 : f_nnodes - 1 ) !!  quadrature nodes on fine  level real ( pfdp ), intent ( in ) :: c_nodes ( 0 : c_nnodes - 1 ) !!  quadrature nodes on coarse  level real ( pfdp ), intent ( out ) :: tmat ( 0 : f_nnodes - 1 , 0 : c_nnodes - 1 ) !!  Interpolation matrix to compute integer :: i , j , k real ( pfdp ) :: xi , num , den do i = 0 , f_nnodes - 1 xi = f_nodes ( i ) do j = 0 , c_nnodes - 1 den = 1.0_pfdp num = 1.0_pfdp do k = 0 , c_nnodes - 1 if ( k == j ) cycle den = den * ( c_nodes ( j ) - c_nodes ( k )) num = num * ( xi - c_nodes ( k )) end do tmat ( i , j ) = num / den end do end do end subroutine pf_time_interpolation_matrix","tags":"","loc":"proc/pf_time_interpolation_matrix.html","title":"pf_time_interpolation_matrix – LibPFASST"},{"text":"public subroutine pf_initialize_results(pf) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Calls proc~~pf_initialize_results~~CallsGraph proc~pf_initialize_results pf_initialize_results proc~initialize_results initialize_results proc~pf_initialize_results->proc~initialize_results Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_initialize_results~~CalledByGraph proc~pf_initialize_results pf_initialize_results proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_initialize_results Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_initialize_results Source Code subroutine pf_initialize_results ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: lev_ind ALLOCATE ( pf % results ( pf % nlevels )) do lev_ind = 1 , pf % nlevels call initialize_results ( pf % results ( lev_ind ), pf % state % nsteps , pf % niters , pf % comm % nproc , pf % nsweeps ( lev_ind ), pf % rank , lev_ind ) end do end subroutine pf_initialize_results","tags":"","loc":"proc/pf_initialize_results.html","title":"pf_initialize_results – LibPFASST"},{"text":"public subroutine pf_dump_results(pf) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Calls proc~~pf_dump_results~~CallsGraph proc~pf_dump_results pf_dump_results proc~dump_timings dump_timings proc~pf_dump_results->proc~dump_timings proc~dump_results dump_results proc~pf_dump_results->proc~dump_results timer_names timer_names proc~dump_timings->timer_names Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_dump_results~~CalledByGraph proc~pf_dump_results pf_dump_results proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_dump_results proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_dump_results Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_dump_results Source Code subroutine pf_dump_results ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: lev_ind if ( pf % save_residuals ) then do lev_ind = 1 , pf % nlevels call dump_results ( pf % results ( lev_ind )) end do end if if ( pf % save_errors ) then do lev_ind = 1 , pf % nlevels !          call  dump_errors(pf%results(lev_ind)) end do end if if ( pf % save_timings ) then call dump_timings ( pf ) end if end subroutine pf_dump_results","tags":"","loc":"proc/pf_dump_results.html","title":"pf_dump_results – LibPFASST"},{"text":"public subroutine imex_sweep(this, pf, lev, t0, dt) Uses pf_mod_timer proc~~imex_sweep~~UsesGraph proc~imex_sweep imex_sweep module~pf_mod_timer pf_mod_timer proc~imex_sweep->module~pf_mod_timer module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Calls proc~~imex_sweep~~CallsGraph proc~imex_sweep imex_sweep proc~start_timer start_timer proc~imex_sweep->proc~start_timer proc~end_timer end_timer proc~imex_sweep->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imex_sweep Source Code subroutine imex_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_imex_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: rhs call start_timer ( pf , TLEVEL + lev % index - 1 ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % SdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( dt * this % SdiffI ( m , n ), lev % F ( n , 2 )) end do if ( allocated ( lev % tau )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tau ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) call lev % ulevel % factory % create_single ( rhs , lev % index , lev % shape ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) call rhs % copy ( lev % Q ( m )) call rhs % axpy ( dtsdc ( m ), lev % F ( m , 1 )) call rhs % axpy ( 1.0_pfdp , lev % S ( m )) call this % f_comp ( lev % Q ( m + 1 ), t , dtsdc ( m ), rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) ! done call lev % ulevel % factory % destroy_single ( rhs , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imex_sweep","tags":"","loc":"proc/imex_sweep.html","title":"imex_sweep – LibPFASST"},{"text":"public subroutine imex_evaluate(this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m Contents Source Code imex_evaluate Source Code subroutine imex_evaluate ( this , lev , t , m ) class ( pf_imex_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) end subroutine imex_evaluate","tags":"","loc":"proc/imex_evaluate.html","title":"imex_evaluate – LibPFASST"},{"text":"public subroutine imex_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code imex_initialize Source Code subroutine imex_initialize ( this , lev ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , nnodes this % npieces = 2 nnodes = lev % nnodes allocate ( this % SdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % SdiffI ( nnodes - 1 , nnodes )) !  S-BE this % SdiffE = lev % s0mat this % SdiffI = lev % s0mat dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) do m = 1 , nnodes - 1 this % SdiffE ( m , m ) = this % SdiffE ( m , m ) - dsdc ( m ) this % SdiffI ( m , m + 1 ) = this % SdiffI ( m , m + 1 ) - dsdc ( m ) end do end subroutine imex_initialize","tags":"","loc":"proc/imex_initialize.html","title":"imex_initialize – LibPFASST"},{"text":"public subroutine imex_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code imex_destroy Source Code subroutine imex_destroy ( this , lev ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % SdiffE ) deallocate ( this % SdiffI ) end subroutine imex_destroy","tags":"","loc":"proc/imex_destroy.html","title":"imex_destroy – LibPFASST"},{"text":"public subroutine imex_integrate(this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) Contents Source Code imex_integrate Source Code subroutine imex_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % s0mat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine imex_integrate","tags":"","loc":"proc/imex_integrate.html","title":"imex_integrate – LibPFASST"},{"text":"public subroutine imex_residual(this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt Calls proc~~imex_residual~~CallsGraph proc~imex_residual imex_residual proc~pf_generic_residual pf_generic_residual proc~imex_residual->proc~pf_generic_residual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imex_residual Source Code subroutine imex_residual ( this , lev , dt ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt call pf_generic_residual ( this , lev , dt ) end subroutine imex_residual","tags":"","loc":"proc/imex_residual.html","title":"imex_residual – LibPFASST"},{"text":"public subroutine imex_spreadq0(this, lev, t0) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 Calls proc~~imex_spreadq0~~CallsGraph proc~imex_spreadq0 imex_spreadq0 proc~pf_generic_spreadq0 pf_generic_spreadq0 proc~imex_spreadq0->proc~pf_generic_spreadq0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imex_spreadq0 Source Code subroutine imex_spreadq0 ( this , lev , t0 ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine imex_spreadq0","tags":"","loc":"proc/imex_spreadq0.html","title":"imex_spreadq0 – LibPFASST"},{"text":"public subroutine imex_evaluate_all(this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) Calls proc~~imex_evaluate_all~~CallsGraph proc~imex_evaluate_all imex_evaluate_all proc~pf_generic_evaluate_all pf_generic_evaluate_all proc~imex_evaluate_all->proc~pf_generic_evaluate_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imex_evaluate_all Source Code subroutine imex_evaluate_all ( this , lev , t ) class ( pf_imex_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) call pf_generic_evaluate_all ( this , lev , t ) end subroutine imex_evaluate_all","tags":"","loc":"proc/imex_evaluate_all.html","title":"imex_evaluate_all – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece","tags":"","loc":"interface/pf_f_eval_p~4.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dt, rhs, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece","tags":"","loc":"interface/pf_f_comp_p~3.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine pf_add_hook(pf, level_ind, hook, proc) Subroutine to add a procedure to the hook on the given level Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: level_ind which pfasst level to add hook integer, intent(in) :: hook which hook to add procedure( pf_hook_p ) :: proc precudre to call from hook Called by proc~~pf_add_hook~~CalledByGraph proc~pf_add_hook pf_add_hook proc~pf_logger_attach pf_logger_attach proc~pf_logger_attach->proc~pf_add_hook Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_add_hook Source Code subroutine pf_add_hook ( pf , level_ind , hook , proc ) type ( pf_pfasst_t ), intent ( inout ) :: pf !! main pfasst structure integer , intent ( in ) :: level_ind !! which pfasst level to add hook integer , intent ( in ) :: hook !! which hook to add procedure ( pf_hook_p ) :: proc !! precudre to call from hook integer :: l ! if ( level_ind == - 1 ) then ! Do to all levels do l = 1 , pf % nlevels pf % nhooks ( l , hook ) = pf % nhooks ( l , hook ) + 1 pf % hooks ( l , hook , pf % nhooks ( l , hook ))% proc => proc end do else ! Do to just level level_ind pf % nhooks ( level_ind , hook ) = pf % nhooks ( level_ind , hook ) + 1 pf % hooks ( level_ind , hook , pf % nhooks ( level_ind , hook ))% proc => proc end if end subroutine pf_add_hook","tags":"","loc":"proc/pf_add_hook.html","title":"pf_add_hook – LibPFASST"},{"text":"public subroutine call_hooks(pf, level_ind, hook) Uses pf_mod_timer proc~~call_hooks~~UsesGraph proc~call_hooks call_hooks module~pf_mod_timer pf_mod_timer proc~call_hooks->module~pf_mod_timer module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to call hooks associated with the hook and level Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf main pfasst structure integer, intent(in) :: level_ind which pfasst level to call hook integer, intent(in) :: hook which hook to call Calls proc~~call_hooks~~CallsGraph proc~call_hooks call_hooks proc~start_timer start_timer proc~call_hooks->proc~start_timer proc~end_timer end_timer proc~call_hooks->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~call_hooks~~CalledByGraph proc~call_hooks call_hooks proc~exp_sweep exp_sweep proc~exp_sweep->proc~call_hooks proc~pf_check_convergence_block pf_check_convergence_block proc~pf_check_convergence_block->proc~call_hooks proc~imexq_oc_sweep imexQ_oc_sweep proc~imexq_oc_sweep->proc~call_hooks proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~call_hooks proc~pf_check_convergence_oc pf_check_convergence_oc proc~pf_pfasst_block_oc->proc~pf_check_convergence_oc proc~pf_predictor_oc pf_predictor_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~mkrk_step mkrk_step proc~mkrk_step->proc~call_hooks proc~restrict_time_space_fas restrict_time_space_fas proc~restrict_time_space_fas->proc~call_hooks proc~interpolate_qend interpolate_qend proc~interpolate_qend->proc~call_hooks proc~pf_check_convergence_oc->proc~call_hooks proc~interpolate_time_space interpolate_time_space proc~interpolate_time_space->proc~call_hooks proc~magpicard_sweep magpicard_sweep proc~magpicard_sweep->proc~call_hooks proc~interpolate_q0 interpolate_q0 proc~interpolate_q0->proc~call_hooks proc~rk_step rk_step proc~rk_step->proc~call_hooks proc~pf_block_run pf_block_run proc~pf_block_run->proc~call_hooks proc~pf_block_run->proc~pf_check_convergence_block proc~pf_predictor pf_predictor proc~pf_block_run->proc~pf_predictor proc~pf_v_cycle pf_v_cycle proc~pf_block_run->proc~pf_v_cycle proc~pf_predictor->proc~call_hooks proc~pf_predictor->proc~restrict_time_space_fas proc~pf_predictor->proc~interpolate_time_space proc~pf_predictor->proc~interpolate_q0 proc~pf_predictor_oc->proc~call_hooks proc~pf_predictor_oc->proc~restrict_time_space_fas proc~pf_predictor_oc->proc~interpolate_time_space proc~misdcq_oc_sweep misdcQ_oc_sweep proc~misdcq_oc_sweep->proc~call_hooks proc~verlet_sweep verlet_sweep proc~verlet_sweep->proc~call_hooks proc~misdcq_sweep misdcQ_sweep proc~misdcq_sweep->proc~call_hooks proc~exp_sweep~2 exp_sweep proc~exp_sweep~2->proc~call_hooks proc~imexq_sweep imexQ_sweep proc~imexq_sweep->proc~call_hooks proc~imk_sweep imk_sweep proc~imk_sweep->proc~mkrk_step proc~imk_sweep->proc~rk_step proc~pf_v_cycle->proc~restrict_time_space_fas proc~pf_v_cycle->proc~interpolate_time_space proc~pf_v_cycle->proc~interpolate_q0 proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run proc~pf_v_cycle_oc->proc~restrict_time_space_fas proc~pf_v_cycle_oc->proc~interpolate_time_space var panproccall_hooksCalledByGraph = svgPanZoom('#proccall_hooksCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code call_hooks Source Code subroutine call_hooks ( pf , level_ind , hook ) use pf_mod_timer type ( pf_pfasst_t ), intent ( inout ), target :: pf !! main pfasst structure integer , intent ( in ) :: level_ind !! which pfasst level to call hook integer , intent ( in ) :: hook !! which hook to call integer :: i !!  hook loop index integer :: l !!  level loop index call start_timer ( pf , THOOKS ) pf % state % hook = hook if ( level_ind == - 1 ) then ! Do to all levels do l = 1 , pf % nlevels do i = 1 , pf % nhooks ( l , hook ) call pf % hooks ( l , hook , i )% proc ( pf , pf % levels ( l ), pf % state ) end do end do else ! Do to just level level_ind do i = 1 , pf % nhooks ( level_ind , hook ) call pf % hooks ( level_ind , hook , i )% proc ( pf , pf % levels ( level_ind ), pf % state ) end do end if call end_timer ( pf , THOOKS ) end subroutine call_hooks","tags":"","loc":"proc/call_hooks.html","title":"call_hooks – LibPFASST"},{"text":"public subroutine pf_logger_hook(pf, level, state) Subroutine defining log hook Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level type( pf_state_t ), intent(in) :: state Contents Source Code pf_logger_hook Source Code subroutine pf_logger_hook ( pf , level , state ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level type ( pf_state_t ), intent ( in ) :: state print '(\"PF:: trank: \",i4,\", step: \",i6,\", iter: \",i3,\", level: \",i2,\" location: \",a)' , & pf % rank , state % step , state % iter , level % index , hook_names ( state % hook ) end subroutine pf_logger_hook","tags":"","loc":"proc/pf_logger_hook.html","title":"pf_logger_hook – LibPFASST"},{"text":"public subroutine pf_logger_attach(pf) Subroutine to add log hook Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Calls proc~~pf_logger_attach~~CallsGraph proc~pf_logger_attach pf_logger_attach proc~pf_add_hook pf_add_hook proc~pf_logger_attach->proc~pf_add_hook Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_logger_attach Source Code subroutine pf_logger_attach ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer :: l , h do h = PF_HOOK_LOG_ONE , PF_HOOK_LOG_ALL - 1 call pf_add_hook ( pf , 1 , h , pf_logger_hook ) end do do l = 1 , pf % nlevels do h = PF_HOOK_LOG_ALL , PF_HOOK_LOG_LAST call pf_add_hook ( pf , l , h , pf_logger_hook ) end do end do end subroutine pf_logger_attach","tags":"","loc":"proc/pf_logger_attach.html","title":"pf_logger_attach – LibPFASST"},{"text":"public subroutine misdc_sweep(this, pf, lev, t0, dt) Uses pf_mod_timer proc~~misdc_sweep~~UsesGraph proc~misdc_sweep misdc_sweep module~pf_mod_timer pf_mod_timer proc~misdc_sweep->module~pf_mod_timer module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Calls proc~~misdc_sweep~~CallsGraph proc~misdc_sweep misdc_sweep proc~start_timer start_timer proc~misdc_sweep->proc~start_timer proc~misdc_evaluate misdc_evaluate proc~misdc_sweep->proc~misdc_evaluate proc~end_timer end_timer proc~misdc_sweep->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code misdc_sweep Source Code subroutine misdc_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_misdc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: S3 (:) class ( pf_encap_t ), allocatable :: rhs call start_timer ( pf , TLEVEL + lev % index - 1 ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % SdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( dt * this % SdiffI ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( dt * lev % s0mat ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tau )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tau ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call misdc_evaluate ( this , lev , t , 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 ) call lev % ulevel % factory % create_single ( rhs , lev % index , lev % shape ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) call rhs % copy ( lev % Q ( m )) call rhs % axpy ( dtsdc ( m ), lev % F ( m , 1 )) call rhs % axpy ( 1.0_pfdp , lev % S ( m )) call this % f_comp ( lev % Q ( m + 1 ), t , dtsdc ( m ), rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) !  Now we need to do the final subtraction for the f3 piece call rhs % copy ( Lev % Q ( m + 1 )) call rhs % axpy ( - 1.0_pfdp * dtsdc ( m ), lev % F ( m + 1 , 3 )) call this % f_comp ( lev % Q ( m + 1 ), t , dtsdc ( m ), rhs , lev % index , lev % F ( m + 1 , 3 ), 3 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 ) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) ! done call lev % ulevel % factory % destroy_single ( rhs , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine misdc_sweep","tags":"","loc":"proc/misdc_sweep.html","title":"misdc_sweep – LibPFASST"},{"text":"public subroutine misdc_evaluate(this, lev, t, m) Uses pf_mod_dtype proc~~misdc_evaluate~~UsesGraph proc~misdc_evaluate misdc_evaluate module~pf_mod_dtype pf_mod_dtype proc~misdc_evaluate->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m Called by proc~~misdc_evaluate~~CalledByGraph proc~misdc_evaluate misdc_evaluate proc~misdc_sweep misdc_sweep proc~misdc_sweep->proc~misdc_evaluate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code misdc_evaluate Source Code subroutine misdc_evaluate ( this , lev , t , m ) use pf_mod_dtype class ( pf_misdc_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 ) end subroutine misdc_evaluate","tags":"","loc":"proc/misdc_evaluate.html","title":"misdc_evaluate – LibPFASST"},{"text":"public subroutine misdc_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code misdc_initialize Source Code subroutine misdc_initialize ( this , lev ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % SdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % SdiffI ( nnodes - 1 , nnodes )) !  S-BE this % SdiffE = lev % s0mat this % SdiffI = lev % s0mat dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) do m = 1 , nnodes - 1 this % SdiffE ( m , m ) = this % SdiffE ( m , m ) - dsdc ( m ) this % SdiffI ( m , m + 1 ) = this % SdiffI ( m , m + 1 ) - dsdc ( m ) end do end subroutine misdc_initialize","tags":"","loc":"proc/misdc_initialize.html","title":"misdc_initialize – LibPFASST"},{"text":"public subroutine misdc_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code misdc_destroy Source Code subroutine misdc_destroy ( this , lev ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % SdiffE ) deallocate ( this % SdiffI ) end subroutine misdc_destroy","tags":"","loc":"proc/misdc_destroy.html","title":"misdc_destroy – LibPFASST"},{"text":"public subroutine misdc_integrate(this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) Contents Source Code misdc_integrate Source Code subroutine misdc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % s0mat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine misdc_integrate","tags":"","loc":"proc/misdc_integrate.html","title":"misdc_integrate – LibPFASST"},{"text":"public subroutine misdc_residual(this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt Calls proc~~misdc_residual~~CallsGraph proc~misdc_residual misdc_residual proc~pf_generic_residual pf_generic_residual proc~misdc_residual->proc~pf_generic_residual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code misdc_residual Source Code subroutine misdc_residual ( this , lev , dt ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt call pf_generic_residual ( this , lev , dt ) end subroutine misdc_residual","tags":"","loc":"proc/misdc_residual.html","title":"misdc_residual – LibPFASST"},{"text":"public subroutine misdc_evaluate_all(this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) Calls proc~~misdc_evaluate_all~~CallsGraph proc~misdc_evaluate_all misdc_evaluate_all proc~pf_generic_evaluate_all pf_generic_evaluate_all proc~misdc_evaluate_all->proc~pf_generic_evaluate_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code misdc_evaluate_all Source Code subroutine misdc_evaluate_all ( this , lev , t ) class ( pf_misdc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) call pf_generic_evaluate_all ( this , lev , t ) end subroutine misdc_evaluate_all","tags":"","loc":"proc/misdc_evaluate_all.html","title":"misdc_evaluate_all – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece","tags":"","loc":"interface/pf_f_eval_p~5.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dt, rhs, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece","tags":"","loc":"interface/pf_f_comp_p~4.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public function cast_as_ndarray(encap_polymorph) result(ndarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndarray ),\n  pointer Called by proc~~cast_as_ndarray~~CalledByGraph proc~cast_as_ndarray cast_as_ndarray proc~ndarray_destroy ndarray_destroy proc~ndarray_destroy->proc~cast_as_ndarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cast_as_ndarray Source Code function cast_as_ndarray ( encap_polymorph ) result ( ndarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( ndarray ), pointer :: ndarray_obj select type ( encap_polymorph ) type is ( ndarray ) ndarray_obj => encap_polymorph end select end function cast_as_ndarray","tags":"","loc":"proc/cast_as_ndarray.html","title":"cast_as_ndarray – LibPFASST"},{"text":"public function ndarray_norm(this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) Contents Source Code ndarray_norm Source Code function ndarray_norm ( this , flags ) result ( norm ) class ( ndarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function ndarray_norm","tags":"","loc":"proc/ndarray_norm.html","title":"ndarray_norm – LibPFASST"},{"text":"public function get_array1d(x, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:) Contents Source Code get_array1d Source Code function get_array1d ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:) select type ( x ) type is ( ndarray ) r => x % flatarray end select end function get_array1d","tags":"","loc":"proc/get_array1d~3.html","title":"get_array1d – LibPFASST"},{"text":"public function get_array2d(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_array2d Source Code function get_array2d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( ndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % flatarray end select end function get_array2d","tags":"","loc":"proc/get_array2d~3.html","title":"get_array2d – LibPFASST"},{"text":"public function get_array3d(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_array3d Source Code function get_array3d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags real ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( ndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % flatarray end select end function get_array3d","tags":"","loc":"proc/get_array3d~3.html","title":"get_array3d – LibPFASST"},{"text":"public subroutine ndarray_build(q, shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) Called by proc~~ndarray_build~~CalledByGraph proc~ndarray_build ndarray_build proc~ndarray_create_single ndarray_create_single proc~ndarray_create_single->proc~ndarray_build Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_build Source Code subroutine ndarray_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) select type ( q ) class is ( ndarray ) allocate ( q % shape ( size ( shape ))) allocate ( q % flatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape end select end subroutine ndarray_build","tags":"","loc":"proc/ndarray_build.html","title":"ndarray_build – LibPFASST"},{"text":"public subroutine ndarray_create_single(this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Calls proc~~ndarray_create_single~~CallsGraph proc~ndarray_create_single ndarray_create_single proc~ndarray_build ndarray_build proc~ndarray_create_single->proc~ndarray_build Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_create_single Source Code subroutine ndarray_create_single ( this , x , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) integer :: i allocate ( ndarray :: x ) call ndarray_build ( x , shape ) end subroutine ndarray_create_single","tags":"","loc":"proc/ndarray_create_single.html","title":"ndarray_create_single – LibPFASST"},{"text":"public subroutine ndarray_create_array(this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndarray_create_array Source Code subroutine ndarray_create_array ( this , x , n , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( ndarray :: x ( n )) do i = 1 , n call ndarray_build ( x ( i ), shape ) end do end subroutine ndarray_create_array","tags":"","loc":"proc/ndarray_create_array.html","title":"ndarray_create_array – LibPFASST"},{"text":"public subroutine ndarray_destroy(encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap Calls proc~~ndarray_destroy~~CallsGraph proc~ndarray_destroy ndarray_destroy proc~cast_as_ndarray cast_as_ndarray proc~ndarray_destroy->proc~cast_as_ndarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_destroy Source Code subroutine ndarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( ndarray ), pointer :: ndarray_obj ndarray_obj => cast_as_ndarray ( encap ) deallocate ( ndarray_obj % shape ) deallocate ( ndarray_obj % flatarray ) nullify ( ndarray_obj ) end subroutine ndarray_destroy","tags":"","loc":"proc/ndarray_destroy.html","title":"ndarray_destroy – LibPFASST"},{"text":"public subroutine ndarray_destroy_single(this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndarray_destroy_single Source Code subroutine ndarray_destroy_single ( this , x , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) select type ( x ) class is ( ndarray ) deallocate ( x % shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine ndarray_destroy_single","tags":"","loc":"proc/ndarray_destroy_single.html","title":"ndarray_destroy_single – LibPFASST"},{"text":"public subroutine ndarray_destroy_array(this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code ndarray_destroy_array Source Code subroutine ndarray_destroy_array ( this , x , n , level , shape ) class ( ndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i select type ( x ) class is ( ndarray ) do i = 1 , n deallocate ( x ( i )% shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine ndarray_destroy_array","tags":"","loc":"proc/ndarray_destroy_array.html","title":"ndarray_destroy_array – LibPFASST"},{"text":"public subroutine ndarray_setval(this, val, flags) The following are the base subroutines that all encapsulations must provide Subroutine to set array to a scalare  value. Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags Contents Source Code ndarray_setval Source Code subroutine ndarray_setval ( this , val , flags ) class ( ndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags this % flatarray = val end subroutine ndarray_setval","tags":"","loc":"proc/ndarray_setval.html","title":"ndarray_setval – LibPFASST"},{"text":"public subroutine ndarray_copy(this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags Calls proc~~ndarray_copy~~CallsGraph proc~ndarray_copy ndarray_copy proc~pf_stop pf_stop proc~ndarray_copy->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_copy Source Code subroutine ndarray_copy ( this , src , flags ) class ( ndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags select type ( src ) type is ( ndarray ) this % flatarray = src % flatarray class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_copy","tags":"","loc":"proc/ndarray_copy.html","title":"ndarray_copy – LibPFASST"},{"text":"public subroutine ndarray_pack(this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags Contents Source Code ndarray_pack Source Code subroutine ndarray_pack ( this , z , flags ) class ( ndarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags z = this % flatarray end subroutine ndarray_pack","tags":"","loc":"proc/ndarray_pack.html","title":"ndarray_pack – LibPFASST"},{"text":"public subroutine ndarray_unpack(this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags Contents Source Code ndarray_unpack Source Code subroutine ndarray_unpack ( this , z , flags ) class ( ndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags this % flatarray = z end subroutine ndarray_unpack","tags":"","loc":"proc/ndarray_unpack.html","title":"ndarray_unpack – LibPFASST"},{"text":"public subroutine ndarray_axpy(this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Calls proc~~ndarray_axpy~~CallsGraph proc~ndarray_axpy ndarray_axpy proc~pf_stop pf_stop proc~ndarray_axpy->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndarray_axpy Source Code subroutine ndarray_axpy ( this , a , x , flags ) class ( ndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags select type ( x ) type is ( ndarray ) this % flatarray = a * x % flatarray + this % flatarray class default call pf_stop ( __ FILE__ , __ LINE__ , 'Type error' ) end select end subroutine ndarray_axpy","tags":"","loc":"proc/ndarray_axpy.html","title":"ndarray_axpy – LibPFASST"},{"text":"public subroutine ndarray_eprint(this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this integer, intent(in), optional :: flags Contents Source Code ndarray_eprint Source Code subroutine ndarray_eprint ( this , flags ) class ( ndarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags !  Just print the first few values if ( product ( this % shape ) < 10 ) then print * , this % flatarray else print * , this % flatarray ( 1 : 10 ) endif end subroutine ndarray_eprint","tags":"","loc":"proc/ndarray_eprint.html","title":"ndarray_eprint – LibPFASST"},{"text":"interface Interfaces to output routines in pf_numpy.c public subroutine ndarray_mkdir(dname, dlen) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname integer, intent(in), value :: dlen Description Subroutine to make a directory for output","tags":"","loc":"interface/ndarray_mkdir~2.html","title":"ndarray_mkdir – LibPFASST"},{"text":"interface Interfaces to output routines in pf_numpy.c public subroutine ndarray_dump_numpy(dname, fname, endian, dim, mpibuflen, shape, array) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Description Subroutine to write an the array to a file","tags":"","loc":"interface/ndarray_dump_numpy~2.html","title":"ndarray_dump_numpy – LibPFASST"},{"text":"public subroutine initialize_results(this, nsteps_in, niters_in, nprocs_in, nsweeps_in, rank_in, lev_ind) Arguments Type Intent Optional Attributes Name class( pf_results_t ), intent(inout) :: this integer, intent(in) :: nsteps_in integer, intent(in) :: niters_in integer, intent(in) :: nprocs_in integer, intent(in) :: nsweeps_in integer, intent(in) :: rank_in integer, intent(in) :: lev_ind Called by proc~~initialize_results~~CalledByGraph proc~initialize_results initialize_results proc~pf_initialize_results pf_initialize_results proc~pf_initialize_results->proc~initialize_results proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_initialize_results Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code initialize_results Source Code subroutine initialize_results ( this , nsteps_in , niters_in , nprocs_in , nsweeps_in , rank_in , lev_ind ) class ( pf_results_t ), intent ( inout ) :: this integer , intent ( in ) :: nsteps_in , niters_in , nprocs_in , nsweeps_in , rank_in , lev_ind character ( len = 25 ) :: fname !!  output file name for residuals integer :: istat !  Set up the directory to dump results istat = system ( 'mkdir -p dat' ) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in initialize_results\" ) if ( rank_in == 0 ) then write ( fname , \"(A20,I0.1,A4)\" ) 'dat/residuals_size_L' , lev_ind , '.dat' open ( unit = 123 , file = fname , form = 'formatted' ) write ( 123 , '(I5, I5, I5, I5)' ) nsteps_in , niters_in , nprocs_in , nsweeps_in close ( unit = 123 ) end if this % dump => dump_results this % destroy => destroy_results this % nsteps = nsteps_in this % nblocks = nsteps_in / nprocs_in this % niters = niters_in this % nprocs = nprocs_in this % nsweeps = nsweeps_in this % rank = rank_in this % level = lev_ind if (. not . allocated ( this % errors )) allocate ( this % errors ( niters_in , this % nblocks , nsweeps_in )) if (. not . allocated ( this % residuals )) allocate ( this % residuals ( niters_in , this % nblocks , nsweeps_in )) this % errors = 0.0_pfdp this % residuals = 0.0_pfdp end subroutine initialize_results","tags":"","loc":"proc/initialize_results.html","title":"initialize_results – LibPFASST"},{"text":"public subroutine dump_results(this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this Called by proc~~dump_results~~CalledByGraph proc~dump_results dump_results proc~pf_dump_results pf_dump_results proc~pf_dump_results->proc~dump_results proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_dump_results proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_dump_results Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dump_results Source Code subroutine dump_results ( this ) type ( pf_results_t ), intent ( inout ) :: this integer :: i , j , k character ( len = 32 ) :: fname_r !!  output file name for residuals character ( len = 25 ) :: fname_t !!  output file name for runtimes character ( len = 21 ) :: fname_e !!  output file name errors integer :: istat istat = system ( 'mkdir -p dat/residuals' ) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in initialize_results\" ) write ( fname_r , \"(A19,I0.3,A5,I0.1,A4)\" ) 'dat/residuals/Proc_' , this % rank , '_Lev_' , this % level , '.dat' !    write (fname_e, \"(A10,I0.3,A1,I0.3,A4)\") 'dat/errors_',  this%rank,'_',this%level,'.dat' !  output residuals open ( 100 + this % rank , file = fname_r , form = 'formatted' ) do j = 1 , this % nblocks do i = 1 , this % niters do k = 1 , this % nsweeps write ( 100 + this % rank , '(I4, I4, I4, e21.14)' ) j , i , k , this % residuals ( i , j , k ) end do end do enddo close ( 100 + this % rank ) end subroutine dump_results","tags":"","loc":"proc/dump_results.html","title":"dump_results – LibPFASST"},{"text":"public subroutine dump_timings(pf) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Calls proc~~dump_timings~~CallsGraph proc~dump_timings dump_timings timer_names timer_names proc~dump_timings->timer_names Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dump_timings~~CalledByGraph proc~dump_timings dump_timings proc~pf_dump_results pf_dump_results proc~pf_dump_results->proc~dump_timings proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_dump_results proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_dump_results Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dump_timings Source Code subroutine dump_timings ( pf ) type ( pf_pfasst_t ), intent ( inout ) :: pf character ( len = 25 ) :: fname !!  output file name for runtimes integer :: istat , j , istream istat = system ( 'mkdir -p dat/runtimes' ) if ( istat . ne . 0 ) call pf_stop ( __ FILE__ , __ LINE__ , \"Cannot make directory in dump_timings\" ) write ( fname , \"(A18,I0.3,A4)\" ) 'dat/runtimes/Proc_' , pf % rank , '.dat' istream = 200 + pf % rank !  Use processor dependent file number !  output timings open ( istream , file = fname , form = 'formatted' ) do j = 1 , 100 if ( pf % runtimes ( j ) > 0.0d0 ) then write ( istream , '(a16,  f23.8)' ) timer_names ( j ), pf % runtimes ( j ) end if end do close ( istream ) end subroutine dump_timings","tags":"","loc":"proc/dump_timings.html","title":"dump_timings – LibPFASST"},{"text":"public subroutine destroy_results(this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this Contents Source Code destroy_results Source Code subroutine destroy_results ( this ) type ( pf_results_t ), intent ( inout ) :: this if ( allocated ( this % errors )) deallocate ( this % errors ) if ( allocated ( this % residuals )) deallocate ( this % residuals ) end subroutine destroy_results","tags":"","loc":"proc/destroy_results.html","title":"destroy_results – LibPFASST"},{"text":"public subroutine interpolate_time_space(pf, t0, dt, level_index, F_INTERP, flags) Subroutine to interpolate (in time and space) level_index-1 to level_index\n Interpolation is done by interpolating increments. The fine function values are re-evaluated after interpolation.\n create workspaces\n set time at coarse and fine nodes\n  interpolate coarse level correction in space only\n interpolate corrections in time either interpolate function values or recompute them\n  reset qend so that it is up to date\n destroy local data structures Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf main pfasst structure real(kind=pfdp), intent(in) :: t0 time at beginning of time interval real(kind=pfdp), intent(in) :: dt time step integer, intent(in) :: level_index defines which level to interpolate to logical, intent(in) :: F_INTERP Flag, if true, then do interp on f not sol integer, intent(in), optional :: flags Calls proc~~interpolate_time_space~~CallsGraph proc~interpolate_time_space interpolate_time_space proc~call_hooks call_hooks proc~interpolate_time_space->proc~call_hooks proc~pf_apply_mat pf_apply_mat proc~interpolate_time_space->proc~pf_apply_mat proc~start_timer start_timer proc~interpolate_time_space->proc~start_timer proc~end_timer end_timer proc~interpolate_time_space->proc~end_timer proc~call_hooks->proc~start_timer proc~call_hooks->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpolate_time_space~~CalledByGraph proc~interpolate_time_space interpolate_time_space proc~pf_predictor_oc pf_predictor_oc proc~pf_predictor_oc->proc~interpolate_time_space proc~pf_v_cycle pf_v_cycle proc~pf_v_cycle->proc~interpolate_time_space proc~pf_predictor pf_predictor proc~pf_predictor->proc~interpolate_time_space proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_v_cycle_oc->proc~interpolate_time_space proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_v_cycle proc~pf_block_run->proc~pf_predictor proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolate_time_space Source Code subroutine interpolate_time_space ( pf , t0 , dt , level_index , F_INTERP , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! main pfasst structure real ( pfdp ), intent ( in ) :: t0 !! time at beginning of time interval real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ) :: level_index !! defines which level to interpolate to logical , intent ( in ) :: F_INTERP !!  Flag, if true, then do interp on f not sol integer , optional , intent ( in ) :: flags !  Local variables class ( pf_level_t ), pointer :: c_lev_ptr !  Pointer to coarse level class ( pf_level_t ), pointer :: f_lev_ptr !  Pointer to fine level integer :: m , p , step real ( pfdp ), allocatable :: c_times (:) ! coarse level node times real ( pfdp ), allocatable :: f_times (:) ! fine level node times class ( pf_encap_t ), allocatable :: c_delta (:) !  Coarse in time and space class ( pf_encap_t ), allocatable :: cf_delta (:) !  Coarse in time but fine in space f_lev_ptr => pf % levels ( level_index ) ! fine level c_lev_ptr => pf % levels ( level_index - 1 ) ! coarse level call call_hooks ( pf , level_index , PF_PRE_INTERP_ALL ) call start_timer ( pf , TINTERPOLATE + level_index - 1 ) step = pf % state % step + 1 !> create workspaces call c_lev_ptr % ulevel % factory % create_array ( c_delta , c_lev_ptr % nnodes , c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % create_array ( cf_delta , c_lev_ptr % nnodes , f_lev_ptr % index , f_lev_ptr % shape ) !> set time at coarse and fine nodes allocate ( c_times ( c_lev_ptr % nnodes )) allocate ( f_times ( f_lev_ptr % nnodes )) c_times = t0 + dt * c_lev_ptr % nodes f_times = t0 + dt * f_lev_ptr % nodes do m = 1 , c_lev_ptr % nnodes call c_delta ( m )% setval ( 0.0_pfdp , flags ) call cf_delta ( m )% setval ( 0.0_pfdp , flags ) end do !>  interpolate coarse level correction in space only do m = 1 , c_lev_ptr % nnodes call c_delta ( m )% copy ( c_lev_ptr % Q ( m ), flags ) call c_delta ( m )% axpy ( - 1.0_pfdp , c_lev_ptr % pQ ( m ), flags ) call f_lev_ptr % ulevel % interpolate ( f_lev_ptr , c_lev_ptr , cf_delta ( m ), c_delta ( m ), c_times ( m ), flags ) end do !> interpolate corrections in time call pf_apply_mat ( f_lev_ptr % Q , 1.0_pfdp , f_lev_ptr % tmat , cf_delta , . false ., flags ) !> either interpolate function values or recompute them if ( F_INTERP ) then !  Interpolating F do p = 1 , size ( c_lev_ptr % F ( 1 ,:)) do m = 1 , c_lev_ptr % nnodes call c_delta ( m )% setval ( 0.0_pfdp , flags ) call cf_delta ( m )% setval ( 0.0_pfdp , flags ) end do ! interpolate coarse corrections  in space do m = 1 , c_lev_ptr % nnodes call c_delta ( m )% copy ( c_lev_ptr % F ( m , p ), flags ) call c_delta ( m )% axpy ( - 1.0_pfdp , c_lev_ptr % pF ( m , p ), flags ) call f_lev_ptr % ulevel % interpolate ( f_lev_ptr , c_lev_ptr , cf_delta ( m ), c_delta ( m ), c_times ( m ), flags ) end do ! interpolate corrections  in time call pf_apply_mat ( f_lev_ptr % F (:, p ), 1.0_pfdp , f_lev_ptr % tmat , cf_delta , . false ., flags ) end do !  Loop on npieces else ! recompute function values call f_lev_ptr % ulevel % sweeper % evaluate_all ( f_lev_ptr , f_times , flags = flags , step = step ) end if !  Feval !>  reset qend so that it is up to date !  This block moved to controllers !         if (present(flags)) then !           if ((flags .eq. 0) .or. (flags .eq. 1))  call f_lev_ptr%qend%copy(f_lev_ptr%Q(f_lev_ptr%nnodes), flags=1) !           if (flags .eq. 2)  call f_lev_ptr%q0%copy(f_lev_ptr%Q(1), flags=2) !         else !           call f_lev_ptr%qend%copy(f_lev_ptr%Q(f_lev_ptr%nnodes)) !         end if !> destroy local data structures call c_lev_ptr % ulevel % factory % destroy_array ( c_delta , c_lev_ptr % nnodes , & c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % destroy_array ( cf_delta , c_lev_ptr % nnodes , & f_lev_ptr % index , f_lev_ptr % shape ) call end_timer ( pf , TINTERPOLATE + f_lev_ptr % index - 1 ) call call_hooks ( pf , f_lev_ptr % index , PF_POST_INTERP_ALL ) end subroutine interpolate_time_space","tags":"","loc":"proc/interpolate_time_space.html","title":"interpolate_time_space – LibPFASST"},{"text":"public subroutine interpolate_q0(pf, f_lev_ptr, c_lev_ptr, flags) Subroutine to update the fine initial condition from coarse increment by spatial interpolation create local workspace\n  restrict fine initial data to coarse\n  get coarse level correction\n  interpolate correction in space\n update fine inital condition\n destroy local workspace Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: f_lev_ptr fine level class( pf_level_t ), intent(inout) :: c_lev_ptr coarse level integer, intent(in), optional :: flags Calls proc~~interpolate_q0~~CallsGraph proc~interpolate_q0 interpolate_q0 proc~call_hooks call_hooks proc~interpolate_q0->proc~call_hooks proc~start_timer start_timer proc~interpolate_q0->proc~start_timer proc~end_timer end_timer proc~interpolate_q0->proc~end_timer proc~call_hooks->proc~start_timer proc~call_hooks->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpolate_q0~~CalledByGraph proc~interpolate_q0 interpolate_q0 proc~pf_v_cycle pf_v_cycle proc~pf_v_cycle->proc~interpolate_q0 proc~pf_predictor pf_predictor proc~pf_predictor->proc~interpolate_q0 proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_v_cycle proc~pf_block_run->proc~pf_predictor proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolate_q0 Source Code subroutine interpolate_q0 ( pf , f_lev_ptr , c_lev_ptr , flags ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: f_lev_ptr !!  fine level class ( pf_level_t ), intent ( inout ) :: c_lev_ptr !!  coarse level integer , optional , intent ( in ) :: flags !!  optional: specify component on which to operate !   here flags more or less is logical, if it is present we operate on component 1 !   of the ndarray-type class ( pf_encap_t ), allocatable :: c_delta !!  coarse correction class ( pf_encap_t ), allocatable :: f_delta !!  fine correction call call_hooks ( pf , f_lev_ptr % index , PF_PRE_INTERP_Q0 ) call start_timer ( pf , TINTERPOLATE + f_lev_ptr % index - 1 ) !> create local workspace call c_lev_ptr % ulevel % factory % create_single ( c_delta , c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % create_single ( f_delta , f_lev_ptr % index , f_lev_ptr % shape ) call c_delta % setval ( 0.0_pfdp , flags ) call f_delta % setval ( 0.0_pfdp , flags ) !>  restrict fine initial data to coarse call f_lev_ptr % ulevel % restrict ( f_lev_ptr , c_lev_ptr , f_lev_ptr % q0 , c_delta , pf % state % t0 , flags ) !>  get coarse level correction call c_delta % axpy ( - 1.0_pfdp , c_lev_ptr % q0 , flags ) !>  interpolate correction in space call f_lev_ptr % ulevel % interpolate ( f_lev_ptr , c_lev_ptr , f_delta , c_delta , pf % state % t0 , flags ) !> update fine inital condition call f_lev_ptr % q0 % axpy ( - 1.0_pfdp , f_delta , flags ) call end_timer ( pf , TINTERPOLATE + f_lev_ptr % index - 1 ) call call_hooks ( pf , f_lev_ptr % index , PF_POST_INTERP_Q0 ) !> destroy local workspace call c_lev_ptr % ulevel % factory % destroy_single ( c_delta , c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % destroy_single ( f_delta , f_lev_ptr % index , f_lev_ptr % shape ) end subroutine interpolate_q0","tags":"","loc":"proc/interpolate_q0.html","title":"interpolate_q0 – LibPFASST"},{"text":"public subroutine interpolate_qend(pf, f_lev_ptr, c_lev_ptr) Subroutine to update the fine terminal condition from coarse increment by spatial interpolation\n  used for adjoint solver create local workspace\n  restrict fine initial data to coarse\n  get coarse level correction interpolate correction in space update fine inital condition destroy local workspace Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: f_lev_ptr fine level class( pf_level_t ), intent(inout) :: c_lev_ptr coarse level Calls proc~~interpolate_qend~~CallsGraph proc~interpolate_qend interpolate_qend proc~call_hooks call_hooks proc~interpolate_qend->proc~call_hooks proc~start_timer start_timer proc~interpolate_qend->proc~start_timer proc~end_timer end_timer proc~interpolate_qend->proc~end_timer proc~call_hooks->proc~start_timer proc~call_hooks->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpolate_qend Source Code subroutine interpolate_qend ( pf , f_lev_ptr , c_lev_ptr ) type ( pf_pfasst_t ), intent ( inout ) :: pf !!  main pfasst structure class ( pf_level_t ), intent ( inout ) :: f_lev_ptr !!  fine level class ( pf_level_t ), intent ( inout ) :: c_lev_ptr !!  coarse level class ( pf_encap_t ), allocatable :: c_delta !!  coarse correction class ( pf_encap_t ), allocatable :: f_delta !!  fine correction call call_hooks ( pf , f_lev_ptr % index , PF_PRE_INTERP_Q0 ) call start_timer ( pf , TINTERPOLATE + f_lev_ptr % index - 1 ) !> create local workspace call c_lev_ptr % ulevel % factory % create_single ( c_delta , c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % create_single ( f_delta , f_lev_ptr % index , f_lev_ptr % shape ) call c_delta % setval ( 0.0_pfdp ) call f_delta % setval ( 0.0_pfdp ) !>  restrict fine initial data to coarse call f_lev_ptr % ulevel % restrict ( f_lev_ptr , c_lev_ptr , f_lev_ptr % qend , c_delta , pf % state % t0 , flags = 2 ) !>  get coarse level correction call c_delta % axpy ( - 1.0_pfdp , c_lev_ptr % qend , flags = 2 ) !>  interpolate correction in space call f_lev_ptr % ulevel % interpolate ( f_lev_ptr , c_lev_ptr , f_delta , c_delta , pf % state % t0 , flags = 2 ) !> update fine inital condition call f_lev_ptr % qend % axpy ( - 1.0_pfdp , f_delta , flags = 2 ) call end_timer ( pf , TINTERPOLATE + f_lev_ptr % index - 1 ) call call_hooks ( pf , f_lev_ptr % index , PF_POST_INTERP_Q0 ) !> destroy local workspace call c_lev_ptr % ulevel % factory % destroy_single ( c_delta , c_lev_ptr % index , c_lev_ptr % shape ) call f_lev_ptr % ulevel % factory % destroy_single ( f_delta , f_lev_ptr % index , f_lev_ptr % shape ) end subroutine interpolate_qend","tags":"","loc":"proc/interpolate_qend.html","title":"interpolate_qend – LibPFASST"},{"text":"public function cast_as_zndarray(encap_polymorph) result(zndarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( zndarray ),\n  pointer Called by proc~~cast_as_zndarray~~CalledByGraph proc~cast_as_zndarray cast_as_zndarray proc~zndarray_copy zndarray_copy proc~zndarray_copy->proc~cast_as_zndarray proc~zndarray_axpy zndarray_axpy proc~zndarray_axpy->proc~cast_as_zndarray proc~zndarray_destroy zndarray_destroy proc~zndarray_destroy->proc~cast_as_zndarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cast_as_zndarray Source Code function cast_as_zndarray ( encap_polymorph ) result ( zndarray_obj ) class ( pf_encap_t ), intent ( in ), target :: encap_polymorph type ( zndarray ), pointer :: zndarray_obj select type ( encap_polymorph ) type is ( zndarray ) zndarray_obj => encap_polymorph end select end function cast_as_zndarray","tags":"","loc":"proc/cast_as_zndarray.html","title":"cast_as_zndarray – LibPFASST"},{"text":"public function zndarray_norm(this, flags) result(norm) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) Contents Source Code zndarray_norm Source Code function zndarray_norm ( this , flags ) result ( norm ) class ( zndarray ), intent ( in ) :: this integer , intent ( in ), optional :: flags real ( pfdp ) :: norm norm = maxval ( abs ( this % flatarray )) end function zndarray_norm","tags":"","loc":"proc/zndarray_norm.html","title":"zndarray_norm – LibPFASST"},{"text":"public function get_array1d(x, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:) Contents Source Code get_array1d Source Code function get_array1d ( x , flags ) result ( r ) class ( pf_encap_t ), target , intent ( in ) :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:) select type ( x ) type is ( zndarray ) r => x % flatarray end select end function get_array1d","tags":"","loc":"proc/get_array1d~4.html","title":"get_array1d – LibPFASST"},{"text":"public function get_array2d(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:,:) Contents Source Code get_array2d Source Code function get_array2d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:) select type ( x ) type is ( zndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 )) => x % flatarray end select end function get_array2d","tags":"","loc":"proc/get_array2d~4.html","title":"get_array2d – LibPFASST"},{"text":"public function get_array3d(x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer,(:,:,:) Contents Source Code get_array3d Source Code function get_array3d ( x , flags ) result ( r ) class ( pf_encap_t ), intent ( in ) :: x integer , intent ( in ), optional :: flags complex ( pfdp ), pointer :: r (:,:,:) select type ( x ) type is ( zndarray ) r ( 1 : x % shape ( 1 ), 1 : x % shape ( 2 ), 1 : x % shape ( 3 )) => x % flatarray end select end function get_array3d","tags":"","loc":"proc/get_array3d~4.html","title":"get_array3d – LibPFASST"},{"text":"public subroutine zndarray_build(q, shape) Allocates complex ndarray Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) Called by proc~~zndarray_build~~CalledByGraph proc~zndarray_build zndarray_build proc~zndarray_create_single zndarray_create_single proc~zndarray_create_single->proc~zndarray_build Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code zndarray_build Source Code subroutine zndarray_build ( q , shape ) class ( pf_encap_t ), intent ( inout ) :: q integer , intent ( in ) :: shape (:) type ( zndarray ), pointer :: zndarray_obj select type ( q ) class is ( zndarray ) allocate ( q % shape ( size ( shape ))) allocate ( q % flatarray ( product ( shape ))) q % dim = size ( shape ) q % shape = shape q % flatarray = cmplx ( 0.0 , 0.0 , pfdp ) end select nullify ( zndarray_obj ) end subroutine zndarray_build","tags":"","loc":"proc/zndarray_build.html","title":"zndarray_build – LibPFASST"},{"text":"public subroutine zndarray_destroy(encap) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap Calls proc~~zndarray_destroy~~CallsGraph proc~zndarray_destroy zndarray_destroy proc~cast_as_zndarray cast_as_zndarray proc~zndarray_destroy->proc~cast_as_zndarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code zndarray_destroy Source Code subroutine zndarray_destroy ( encap ) class ( pf_encap_t ), intent ( inout ) :: encap type ( zndarray ), pointer :: zndarray_obj zndarray_obj => cast_as_zndarray ( encap ) deallocate ( zndarray_obj % shape ) deallocate ( zndarray_obj % flatarray ) nullify ( zndarray_obj ) end subroutine zndarray_destroy","tags":"","loc":"proc/zndarray_destroy.html","title":"zndarray_destroy – LibPFASST"},{"text":"public subroutine zndarray_create_single(this, x, level, shape) Wrapper routine for allocation of a single zndarray type array Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Calls proc~~zndarray_create_single~~CallsGraph proc~zndarray_create_single zndarray_create_single proc~zndarray_build zndarray_build proc~zndarray_create_single->proc~zndarray_build Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code zndarray_create_single Source Code subroutine zndarray_create_single ( this , x , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) allocate ( zndarray :: x ) call zndarray_build ( x , shape ) end subroutine zndarray_create_single","tags":"","loc":"proc/zndarray_create_single.html","title":"zndarray_create_single – LibPFASST"},{"text":"public subroutine zndarray_create_array(this, x, n, level, shape) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code zndarray_create_array Source Code subroutine zndarray_create_array ( this , x , n , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i allocate ( zndarray :: x ( n )) do i = 1 , n call zndarray_build ( x ( i ), shape ) end do end subroutine zndarray_create_array","tags":"","loc":"proc/zndarray_create_array.html","title":"zndarray_create_array – LibPFASST"},{"text":"public subroutine zndarray_destroy_single(this, x, level, shape) Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code zndarray_destroy_single Source Code subroutine zndarray_destroy_single ( this , x , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x integer , intent ( in ) :: level , shape (:) select type ( x ) class is ( zndarray ) deallocate ( x % shape ) deallocate ( x % flatarray ) end select deallocate ( x ) end subroutine zndarray_destroy_single","tags":"","loc":"proc/zndarray_destroy_single.html","title":"zndarray_destroy_single – LibPFASST"},{"text":"public subroutine zndarray_destroy_array(this, x, n, level, shape) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) Contents Source Code zndarray_destroy_array Source Code subroutine zndarray_destroy_array ( this , x , n , level , shape ) class ( zndarray_factory ), intent ( inout ) :: this class ( pf_encap_t ), intent ( inout ), allocatable :: x (:) integer , intent ( in ) :: n , level , shape (:) integer :: i select type ( x ) class is ( zndarray ) do i = 1 , n deallocate ( x ( i )% shape ) deallocate ( x ( i )% flatarray ) end do end select deallocate ( x ) end subroutine zndarray_destroy_array","tags":"","loc":"proc/zndarray_destroy_array.html","title":"zndarray_destroy_array – LibPFASST"},{"text":"public subroutine zndarray_setval(this, val, flags) Set solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags Contents Source Code zndarray_setval Source Code subroutine zndarray_setval ( this , val , flags ) class ( zndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: val integer , intent ( in ), optional :: flags complex ( pfdp ) :: zval zval = cmplx ( val , 0.0 , pfdp ) this % flatarray = zval end subroutine zndarray_setval","tags":"","loc":"proc/zndarray_setval.html","title":"zndarray_setval – LibPFASST"},{"text":"public subroutine zndarray_copy(this, src, flags) Copy solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags Calls proc~~zndarray_copy~~CallsGraph proc~zndarray_copy zndarray_copy proc~cast_as_zndarray cast_as_zndarray proc~zndarray_copy->proc~cast_as_zndarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code zndarray_copy Source Code subroutine zndarray_copy ( this , src , flags ) class ( zndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: src integer , intent ( in ), optional :: flags class ( zndarray ), pointer :: zndarray_src zndarray_src => cast_as_zndarray ( src ) this % flatarray = zndarray_src % flatarray end subroutine zndarray_copy","tags":"","loc":"proc/zndarray_copy.html","title":"zndarray_copy – LibPFASST"},{"text":"public subroutine zndarray_pack(this, z, flags) Pack solution q into a flat array. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags Contents Source Code zndarray_pack Source Code subroutine zndarray_pack ( this , z , flags ) class ( zndarray ), intent ( in ) :: this real ( pfdp ), intent ( out ) :: z (:) integer , intent ( in ), optional :: flags integer :: i do i = 1 , product ( this % shape ) z ( 2 * i - 1 ) = real ( this % flatarray ( i )) z ( 2 * i ) = aimag ( this % flatarray ( i )) end do end subroutine zndarray_pack","tags":"","loc":"proc/zndarray_pack.html","title":"zndarray_pack – LibPFASST"},{"text":"public subroutine zndarray_unpack(this, z, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags Contents Source Code zndarray_unpack Source Code subroutine zndarray_unpack ( this , z , flags ) class ( zndarray ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z (:) integer , intent ( in ), optional :: flags integer :: i do i = 1 , product ( this % shape ) this % flatarray ( i ) = cmplx ( z ( 2 * i - 1 ), z ( 2 * i ), pfdp ) enddo end subroutine zndarray_unpack","tags":"","loc":"proc/zndarray_unpack.html","title":"zndarray_unpack – LibPFASST"},{"text":"public subroutine zndarray_axpy(this, a, x, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Calls proc~~zndarray_axpy~~CallsGraph proc~zndarray_axpy zndarray_axpy proc~cast_as_zndarray cast_as_zndarray proc~zndarray_axpy->proc~cast_as_zndarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code zndarray_axpy Source Code subroutine zndarray_axpy ( this , a , x , flags ) class ( zndarray ), intent ( inout ) :: this class ( pf_encap_t ), intent ( in ) :: x real ( pfdp ), intent ( in ) :: a integer , intent ( in ), optional :: flags class ( zndarray ), pointer :: zndarray_obj zndarray_obj => cast_as_zndarray ( x ) this % flatarray = a * zndarray_obj % flatarray + this % flatarray end subroutine zndarray_axpy","tags":"","loc":"proc/zndarray_axpy.html","title":"zndarray_axpy – LibPFASST"},{"text":"public subroutine zndarray_eprint(this, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this integer, intent(in), optional :: flags Contents Source Code zndarray_eprint Source Code subroutine zndarray_eprint ( this , flags ) class ( zndarray ), intent ( inout ) :: this integer , intent ( in ), optional :: flags print * , this % flatarray ( 1 : 10 ) end subroutine zndarray_eprint","tags":"","loc":"proc/zndarray_eprint.html","title":"zndarray_eprint – LibPFASST"},{"text":"public subroutine write_to_disk(this, filename) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this character(len=*), intent(in) :: filename Contents Source Code write_to_disk Source Code subroutine write_to_disk ( this , filename ) class ( zndarray ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename open ( unit = 1 , file = trim ( filename ), form = 'unformatted' ) write ( 1 ) this % flatarray close ( 1 ) end subroutine write_to_disk","tags":"","loc":"proc/write_to_disk.html","title":"write_to_disk – LibPFASST"},{"text":"public subroutine ark_do_n_steps(this, pf, level_index, t0, big_dt, nsteps_rk) Uses pf_mod_timer pf_mod_hooks proc~~ark_do_n_steps~~UsesGraph proc~ark_do_n_steps ark_do_n_steps module~pf_mod_hooks pf_mod_hooks proc~ark_do_n_steps->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~ark_do_n_steps->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Perform N steps of ark on level level_index and set qend appropriately.\n Assign pointer to appropriate level Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Level of the index to step on real(kind=pfdp), intent(in) :: t0 Time at start of time interval real(kind=pfdp), intent(in) :: big_dt Size of time interval to integrato on integer, intent(in) :: nsteps_rk Number of steps to use Contents Source Code ark_do_n_steps Source Code subroutine ark_do_n_steps ( this , pf , level_index , t0 , big_dt , nsteps_rk ) use pf_mod_timer use pf_mod_hooks class ( pf_ark_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 !!  Time at start of time interval real ( pfdp ), intent ( in ) :: big_dt !!  Size of time interval to integrato on integer , intent ( in ) :: level_index !!  Level of the index to step on integer , intent ( in ) :: nsteps_rk !!  Number of steps to use class ( pf_level_t ), pointer :: lev !!  Pointer to level level_index class ( pf_encap_t ), allocatable :: rhs !!  Accumulated right hand side for implicit solves integer :: j , m , n !!  Loop counters real ( pfdp ) :: t !!  Time real ( pfdp ) :: dt !!  Size of each ark step lev => pf % levels ( level_index ) !! Assign pointer to appropriate level dt = big_dt / real ( nsteps_rk , pfdp ) ! Set the internal time step size based on the number of rk steps ! Allocate space for the right-hand side call lev % ulevel % factory % create_single ( rhs , lev % index , lev % shape ) do n = 1 , nsteps_rk ! Loop over time steps ! Recompute the first explicit function value if ( n == 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) else call lev % Q ( 1 )% copy ( lev % Q ( lev % nnodes )) end if ! this assumes that cvec(1) == 0 if ( this % explicit ) & call this % f_eval ( lev % Q ( 1 ), t0 + dt * ( n - 1 ) + dt * this % cvec ( 1 ), lev % index , lev % F ( 1 , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( lev % Q ( 1 ), t0 + dt * ( n - 1 ) + dt * this % cvec ( 1 ), lev % index , lev % F ( 1 , 2 ), 2 ) ! Loop over stage values do m = 1 , this % nstages - 1 ! Set current time t = t0 + dt * ( n - 1 ) + dt * this % cvec ( m + 1 ) ! Initialize the right-hand size for each stage call rhs % copy ( lev % Q ( 1 )) do j = 1 , m ! Add explicit rhs if ( this % explicit ) & call rhs % axpy ( dt * this % AmatE ( m + 1 , j ), lev % F ( j , 1 )) ! Add implicit rhs if ( this % implicit ) & call rhs % axpy ( dt * this % AmatI ( m + 1 , j ), lev % F ( j , 2 )) end do ! Solve the implicit system if ( this % implicit . and . this % AmatI ( m + 1 , m + 1 ) /= 0 ) then call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % AmatI ( m + 1 , m + 1 ), rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) else call lev % Q ( m + 1 )% copy ( rhs ) end if ! Reevaluate explicit rhs with the new solution if ( this % explicit ) & call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) end do ! End loop over stage values ! Compute final value using quadrature rule call lev % Q ( lev % nnodes )% copy ( lev % Q ( 1 )) ! Loop over stage values one more time do j = 1 , this % nstages ! Add explicit terms if ( this % explicit ) & call lev % Q ( lev % nnodes )% axpy ( dt * this % bvecE ( j ), lev % F ( j , 1 )) ! Add implicit terms if ( this % implicit ) & call lev % Q ( lev % nnodes )% axpy ( dt * this % bvecI ( j ), lev % F ( j , 2 )) end do ! End loop over stage values end do ! End Loop over time steps ! Assign final value to end of time step call lev % qend % copy ( lev % Q ( lev % nnodes )) end subroutine ark_do_n_steps","tags":"","loc":"proc/ark_do_n_steps.html","title":"ark_do_n_steps – LibPFASST"},{"text":"public subroutine ark_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code ark_initialize Source Code subroutine ark_initialize ( this , lev ) class ( pf_ark_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev integer :: nstages real ( pfdp ) :: gamma , delta this % explicit = . true . this % implicit = . true . if ( this % order == 2 ) then !  Ascher-Ruuth-Spiteri nstages = 3 this % nstages = nstages allocate ( this % AmatE ( nstages , nstages )) !  Explicit Butcher matrix allocate ( this % AmatI ( nstages , nstages )) !  Implicit Butcher matrix allocate ( this % cvec ( nstages )) !  stage times allocate ( this % bvecE ( nstages )) !  quadrature weights on explicit allocate ( this % bvecI ( nstages )) !  quadrature weights on implicit this % AmatE = 0.0_pfdp this % AmatI = 0.0_pfdp this % bvecE = 0.0_pfdp this % bvecI = 0.0_pfdp this % cvec = 0.0_pfdp gamma = ( TWO - sqrt ( TWO )) / TWO delta = - TWO * sqrt ( TWO ) / THREE this % AmatE ( 2 , 1 ) = gamma this % AmatE ( 3 , 1 ) = delta this % AmatE ( 3 , 2 ) = ONE - delta this % AmatI ( 2 , 2 ) = gamma this % AmatI ( 3 , 2 ) = ONE - gamma this % AmatI ( 3 , 3 ) = gamma this % cvec = ( / ZERO , gamma , ONE / ) this % bvecE = ( / ZERO , ONE - gamma , gamma / ) this % bvecI = this % bvecE else if ( this % order == 3 ) then ! Third-order Kennedy-Carpenter nstages = 4 this % nstages = nstages allocate ( this % AmatE ( nstages , nstages )) !  Explicit Butcher matrix allocate ( this % AmatI ( nstages , nstages )) !  Implicit Butcher matrix allocate ( this % cvec ( nstages )) !  stage times allocate ( this % bvecE ( nstages )) !  quadrature weights on explicit allocate ( this % bvecI ( nstages )) !  quadrature weights on implicit this % AmatE = 0.0_pfdp this % AmatI = 0.0_pfdp this % bvecE = 0.0_pfdp this % bvecI = 0.0_pfdp this % cvec = 0.0_pfdp this % AmatE ( 2 , 1 ) = 176773220590 3.0_pfdp / 202783664111 8.0_pfdp this % AmatE ( 3 , 1 ) = 553582888582 5.0_pfdp / 1049269177363 7.0_pfdp this % AmatE ( 3 , 2 ) = 78802234243 7.0_pfdp / 1088263485894 0.0_pfdp this % AmatE ( 4 , 1 ) = 648598928062 9.0_pfdp / 1625170173562 2.0_pfdp this % AmatE ( 4 , 2 ) = - 424626684708 9.0_pfdp / 970447391861 9.0_pfdp this % AmatE ( 4 , 3 ) = 1075544844929 2.0_pfdp / 1035709742484 1.0_pfdp this % AmatI ( 2 , 1 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 2 , 2 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 3 , 1 ) = 274623878971 9.0_pfdp / 1065886856070 8.0_pfdp this % AmatI ( 3 , 2 ) = - 64016744523 7.0_pfdp / 684562943199 7.0_pfdp this % AmatI ( 3 , 3 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % AmatI ( 4 , 1 ) = 147126639957 9.0_pfdp / 784085678865 4.0_pfdp this % AmatI ( 4 , 2 ) = - 448244416785 8.0_pfdp / 752975506669 7.0_pfdp this % AmatI ( 4 , 3 ) = 1126623926642 8.0_pfdp / 1159328672282 1.0_pfdp this % AmatI ( 4 , 4 ) = 176773220590 3.0_pfdp / 405567328223 6.0_pfdp this % cvec = ( / 0.0_pfdp , 176773220590 3.0_pfdp / 202783664111 8.0_pfdp , 3.0_pfdp / 5.0_pfdp , 1.0_pfdp / ) this % bvecE = ( / 147126639957 9.0_pfdp / 784085678865 4.0_pfdp , - 448244416785 8.0_pfdp / 752975506669 7.0_pfdp ,& 1126623926642 8.0_pfdp / 1159328672282 1.0_pfdp , 176773220590 3.0_pfdp / 405567328223 6.0_pfdp / ) this % bvecI = this % bvecE else if ( this % order == 4 ) then ! Fourth-order Kennedy-Carpenter nstages = 6 this % nstages = nstages allocate ( this % AmatE ( nstages , nstages )) !  Explicit Butcher matrix allocate ( this % AmatI ( nstages , nstages )) !  Implicit Butcher matrix allocate ( this % cvec ( nstages )) !  stage times allocate ( this % bvecE ( nstages )) !  quadrature weights on explicit allocate ( this % bvecI ( nstages )) !  quadrature weights on implicit this % AmatE = 0.0_pfdp this % AmatI = 0.0_pfdp this % bvecE = 0.0_pfdp this % bvecI = 0.0_pfdp this % cvec = 0.0_pfdp this % AmatE ( 2 , 1 ) = 0.5_pfdp this % AmatE ( 3 , 1 ) = 1386 1.0_pfdp / 6250 0.0_pfdp this % AmatE ( 3 , 2 ) = 688 9.0_pfdp / 6250 0.0_pfdp this % AmatE ( 4 , 1 ) = - 11692331627 5.0_pfdp / 239368406146 8.0_pfdp this % AmatE ( 4 , 2 ) = - 273121846731 7.0_pfdp / 1536804210183 1.0_pfdp this % AmatE ( 4 , 3 ) = 940804670208 9.0_pfdp / 1111317113920 9.0_pfdp this % AmatE ( 5 , 1 ) = - 45108634878 8.0_pfdp / 290242868990 9.0_pfdp this % AmatE ( 5 , 2 ) = - 268234879257 2.0_pfdp / 751979568189 7.0_pfdp this % AmatE ( 5 , 3 ) = 1266286877508 2.0_pfdp / 1196047911538 3.0_pfdp this % AmatE ( 5 , 4 ) = 335581797596 5.0_pfdp / 1106085150927 1.0_pfdp this % AmatE ( 6 , 1 ) = 64784517918 8.0_pfdp / 321632005775 1.0_pfdp this % AmatE ( 6 , 2 ) = 7328151925 0.0_pfdp / 838263948453 3.0_pfdp this % AmatE ( 6 , 3 ) = 55253951339 1.0_pfdp / 345466838623 3.0_pfdp this % AmatE ( 6 , 4 ) = 335451267163 9.0_pfdp / 830676392457 3.0_pfdp this % AmatE ( 6 , 5 ) = 404 0.0_pfdp / 1787 1.0_pfdp this % AmatI ( 2 , 1 ) = 0.25_pfdp this % AmatI ( 2 , 2 ) = 0.25_pfdp this % AmatI ( 3 , 1 ) = 861 1.0_pfdp / 6250 0.0_pfdp this % AmatI ( 3 , 2 ) = - 174 3.0_pfdp / 3125 0.0_pfdp this % AmatI ( 3 , 3 ) = 0.25_pfdp this % AmatI ( 4 , 1 ) = 501202 9.0_pfdp / 3465250 0.0_pfdp this % AmatI ( 4 , 2 ) = - 65444 1.0_pfdp / 292250 0.0_pfdp this % AmatI ( 4 , 3 ) = 17437 5.0_pfdp / 38810 8.0_pfdp this % AmatI ( 4 , 4 ) = 0.25_pfdp this % AmatI ( 5 , 1 ) = 1526708280 9.0_pfdp / 15537626560 0.0_pfdp this % AmatI ( 5 , 2 ) = - 7144340 1.0_pfdp / 12077440 0.0_pfdp this % AmatI ( 5 , 3 ) = 73087887 5.0_pfdp / 90218476 8.0_pfdp this % AmatI ( 5 , 4 ) = 228539 5.0_pfdp / 807091 2.0_pfdp this % AmatI ( 5 , 5 ) = 0.25_pfdp this % AmatI ( 6 , 1 ) = 8288 9.0_pfdp / 52489 2.0_pfdp this % AmatI ( 6 , 2 ) = 0.0_pfdp this % AmatI ( 6 , 3 ) = 1562 5.0_pfdp / 8366 4.0_pfdp this % AmatI ( 6 , 4 ) = 6987 5.0_pfdp / 10267 2.0_pfdp this % AmatI ( 6 , 5 ) = - 226 0.0_pfdp / 821 1.0_pfdp this % AmatI ( 6 , 6 ) = 0.25_pfdp this % cvec = ( / 0.0_pfdp , 0.5_pfdp , 8 3.0_pfdp / 25 0.0_pfdp , & 3 1.0_pfdp / 5 0.0_pfdp , 1 7.0_pfdp / 2 0.0_pfdp , 1.0_pfdp / ) this % bvecE = ( / 8288 9.0_pfdp / 52489 2.0_pfdp , 0.0_pfdp , 1562 5.0_pfdp / 8366 4.0_pfdp , & 6987 5.0_pfdp / 10267 2.0_pfdp , - 226 0.0_pfdp / 821 1.0_pfdp , 0.25_pfdp / ) this % bvecI = this % bvecE else stop \"ark_initialize: This RK order is not supported\" end if if ( lev % nnodes < this % nstages + 1 ) & stop \"ark_initialize: With RK, lev%nnodes should be equal to rkstepper%nstages + 1\" end subroutine ark_initialize","tags":"","loc":"proc/ark_initialize.html","title":"ark_initialize – LibPFASST"},{"text":"public subroutine ark_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code ark_destroy Source Code subroutine ark_destroy ( this , lev ) class ( pf_ark_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % AmatE ) deallocate ( this % AmatI ) deallocate ( this % bvecE ) deallocate ( this % bvecI ) deallocate ( this % cvec ) end subroutine ark_destroy","tags":"","loc":"proc/ark_destroy.html","title":"ark_destroy – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece","tags":"","loc":"interface/pf_f_eval_p~6.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dtq class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece","tags":"","loc":"interface/pf_f_comp_p~5.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine start_timer(pf, timer) Subroutine to start a timer Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: timer Calls proc~~start_timer~~CallsGraph proc~start_timer start_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~start_timer~~CalledByGraph proc~start_timer start_timer proc~magpicard_sweep magpicard_sweep proc~magpicard_sweep->proc~start_timer proc~pf_residual pf_residual proc~magpicard_sweep->proc~pf_residual proc~call_hooks call_hooks proc~magpicard_sweep->proc~call_hooks proc~sweep_coupled_implicit_terms sweep_coupled_implicit_terms proc~sweep_coupled_implicit_terms->proc~start_timer proc~imexq_oc_sweep imexQ_oc_sweep proc~imexq_oc_sweep->proc~start_timer proc~imexq_oc_sweep->proc~pf_residual proc~imexq_oc_sweep->proc~call_hooks proc~pf_predictor pf_predictor proc~pf_predictor->proc~start_timer proc~restrict_time_space_fas restrict_time_space_fas proc~pf_predictor->proc~restrict_time_space_fas proc~pf_predictor->proc~pf_residual proc~interpolate_time_space interpolate_time_space proc~pf_predictor->proc~interpolate_time_space proc~interpolate_q0 interpolate_q0 proc~pf_predictor->proc~interpolate_q0 proc~pf_predictor->proc~call_hooks proc~imex_sweep imex_sweep proc~imex_sweep->proc~start_timer proc~restrict_time_space_fas->proc~start_timer proc~restrict_time_space_fas->proc~call_hooks proc~interpolate_qend interpolate_qend proc~interpolate_qend->proc~start_timer proc~interpolate_qend->proc~call_hooks proc~verlet_sweep verlet_sweep proc~verlet_sweep->proc~start_timer proc~verlet_sweep->proc~pf_residual proc~verlet_sweep->proc~call_hooks proc~pf_residual->proc~start_timer proc~amisdc_sweep amisdc_sweep proc~amisdc_sweep->proc~start_timer proc~interpolate_time_space->proc~start_timer proc~interpolate_time_space->proc~call_hooks proc~imk_actually_sweep imk_actually_sweep proc~imk_actually_sweep->proc~start_timer proc~imk_actually_sweep->proc~pf_residual proc~interpolate_q0->proc~start_timer proc~interpolate_q0->proc~call_hooks proc~pf_block_run pf_block_run proc~pf_block_run->proc~start_timer proc~pf_block_run->proc~pf_predictor proc~pf_block_run->proc~call_hooks proc~pf_check_convergence_block pf_check_convergence_block proc~pf_block_run->proc~pf_check_convergence_block proc~pf_v_cycle pf_v_cycle proc~pf_block_run->proc~pf_v_cycle proc~call_hooks->proc~start_timer proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~start_timer proc~pf_pfasst_block_oc->proc~call_hooks proc~pf_predictor_oc pf_predictor_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~pf_check_convergence_oc pf_check_convergence_oc proc~pf_pfasst_block_oc->proc~pf_check_convergence_oc proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~pf_predictor_oc->proc~start_timer proc~pf_predictor_oc->proc~restrict_time_space_fas proc~pf_predictor_oc->proc~pf_residual proc~pf_predictor_oc->proc~interpolate_time_space proc~pf_predictor_oc->proc~call_hooks proc~misdcq_oc_sweep misdcQ_oc_sweep proc~misdcq_oc_sweep->proc~start_timer proc~misdcq_oc_sweep->proc~pf_residual proc~misdcq_oc_sweep->proc~call_hooks proc~misdc_sweep misdc_sweep proc~misdc_sweep->proc~start_timer proc~misdcq_sweep misdcQ_sweep proc~misdcq_sweep->proc~start_timer proc~misdcq_sweep->proc~pf_residual proc~misdcq_sweep->proc~call_hooks proc~imexq_sweep imexQ_sweep proc~imexq_sweep->proc~start_timer proc~imexq_sweep->proc~pf_residual proc~imexq_sweep->proc~call_hooks proc~exp_sweep exp_sweep proc~exp_sweep->proc~pf_residual proc~exp_sweep->proc~call_hooks proc~pf_check_convergence_block->proc~call_hooks proc~pf_v_cycle->proc~restrict_time_space_fas proc~pf_v_cycle->proc~pf_residual proc~pf_v_cycle->proc~interpolate_time_space proc~pf_v_cycle->proc~interpolate_q0 proc~mkrk_step mkrk_step proc~mkrk_step->proc~pf_residual proc~mkrk_step->proc~call_hooks proc~pf_check_convergence_oc->proc~call_hooks proc~pf_v_cycle_oc->proc~restrict_time_space_fas proc~pf_v_cycle_oc->proc~pf_residual proc~pf_v_cycle_oc->proc~interpolate_time_space proc~amisdcq_sweep amisdcQ_sweep proc~amisdcq_sweep->proc~sweep_coupled_implicit_terms proc~rk_step rk_step proc~rk_step->proc~pf_residual proc~rk_step->proc~call_hooks proc~imk_sweep imk_sweep proc~imk_sweep->proc~imk_actually_sweep proc~imk_sweep->proc~mkrk_step proc~imk_sweep->proc~rk_step proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run proc~exp_sweep~2 exp_sweep proc~exp_sweep~2->proc~pf_residual proc~exp_sweep~2->proc~call_hooks var panprocstart_timerCalledByGraph = svgPanZoom('#procstart_timerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code start_timer Source Code subroutine start_timer ( pf , timer ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: timer pf % timers ( timer ) = MPI_Wtime () end subroutine start_timer","tags":"","loc":"proc/start_timer.html","title":"start_timer – LibPFASST"},{"text":"public subroutine end_timer(pf, timer) Subroutine to stop a timer Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: timer Calls proc~~end_timer~~CallsGraph proc~end_timer end_timer mpi_wtime mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~end_timer~~CalledByGraph proc~end_timer end_timer proc~sweep_coupled_implicit_terms sweep_coupled_implicit_terms proc~sweep_coupled_implicit_terms->proc~end_timer proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~end_timer proc~call_hooks call_hooks proc~pf_pfasst_block_oc->proc~call_hooks proc~pf_predictor_oc pf_predictor_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~pf_check_convergence_oc pf_check_convergence_oc proc~pf_pfasst_block_oc->proc~pf_check_convergence_oc proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~imex_sweep imex_sweep proc~imex_sweep->proc~end_timer proc~restrict_time_space_fas restrict_time_space_fas proc~restrict_time_space_fas->proc~end_timer proc~restrict_time_space_fas->proc~call_hooks proc~interpolate_qend interpolate_qend proc~interpolate_qend->proc~end_timer proc~interpolate_qend->proc~call_hooks proc~verlet_sweep verlet_sweep proc~verlet_sweep->proc~end_timer proc~pf_residual pf_residual proc~verlet_sweep->proc~pf_residual proc~verlet_sweep->proc~call_hooks proc~pf_residual->proc~end_timer proc~amisdc_sweep amisdc_sweep proc~amisdc_sweep->proc~end_timer proc~interpolate_time_space interpolate_time_space proc~interpolate_time_space->proc~end_timer proc~interpolate_time_space->proc~call_hooks proc~imk_actually_sweep imk_actually_sweep proc~imk_actually_sweep->proc~end_timer proc~imk_actually_sweep->proc~pf_residual proc~interpolate_q0 interpolate_q0 proc~interpolate_q0->proc~end_timer proc~interpolate_q0->proc~call_hooks proc~pf_predictor pf_predictor proc~pf_predictor->proc~end_timer proc~pf_predictor->proc~restrict_time_space_fas proc~pf_predictor->proc~pf_residual proc~pf_predictor->proc~interpolate_time_space proc~pf_predictor->proc~interpolate_q0 proc~pf_predictor->proc~call_hooks proc~magpicard_sweep magpicard_sweep proc~magpicard_sweep->proc~end_timer proc~magpicard_sweep->proc~pf_residual proc~magpicard_sweep->proc~call_hooks proc~call_hooks->proc~end_timer proc~pf_block_run pf_block_run proc~pf_block_run->proc~end_timer proc~pf_block_run->proc~pf_predictor proc~pf_block_run->proc~call_hooks proc~pf_check_convergence_block pf_check_convergence_block proc~pf_block_run->proc~pf_check_convergence_block proc~pf_v_cycle pf_v_cycle proc~pf_block_run->proc~pf_v_cycle proc~pf_predictor_oc->proc~end_timer proc~pf_predictor_oc->proc~restrict_time_space_fas proc~pf_predictor_oc->proc~pf_residual proc~pf_predictor_oc->proc~interpolate_time_space proc~pf_predictor_oc->proc~call_hooks proc~imexq_oc_sweep imexQ_oc_sweep proc~imexq_oc_sweep->proc~end_timer proc~imexq_oc_sweep->proc~pf_residual proc~imexq_oc_sweep->proc~call_hooks proc~misdc_sweep misdc_sweep proc~misdc_sweep->proc~end_timer proc~misdcq_sweep misdcQ_sweep proc~misdcq_sweep->proc~end_timer proc~misdcq_sweep->proc~pf_residual proc~misdcq_sweep->proc~call_hooks proc~imexq_sweep imexQ_sweep proc~imexq_sweep->proc~end_timer proc~imexq_sweep->proc~pf_residual proc~imexq_sweep->proc~call_hooks proc~exp_sweep exp_sweep proc~exp_sweep->proc~pf_residual proc~exp_sweep->proc~call_hooks proc~pf_check_convergence_block->proc~call_hooks proc~pf_v_cycle->proc~restrict_time_space_fas proc~pf_v_cycle->proc~pf_residual proc~pf_v_cycle->proc~interpolate_time_space proc~pf_v_cycle->proc~interpolate_q0 proc~mkrk_step mkrk_step proc~mkrk_step->proc~pf_residual proc~mkrk_step->proc~call_hooks proc~pf_check_convergence_oc->proc~call_hooks proc~pf_v_cycle_oc->proc~restrict_time_space_fas proc~pf_v_cycle_oc->proc~pf_residual proc~pf_v_cycle_oc->proc~interpolate_time_space proc~amisdcq_sweep amisdcQ_sweep proc~amisdcq_sweep->proc~sweep_coupled_implicit_terms proc~rk_step rk_step proc~rk_step->proc~pf_residual proc~rk_step->proc~call_hooks proc~imk_sweep imk_sweep proc~imk_sweep->proc~imk_actually_sweep proc~imk_sweep->proc~mkrk_step proc~imk_sweep->proc~rk_step proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run proc~misdcq_oc_sweep misdcQ_oc_sweep proc~misdcq_oc_sweep->proc~pf_residual proc~misdcq_oc_sweep->proc~call_hooks proc~exp_sweep~2 exp_sweep proc~exp_sweep~2->proc~pf_residual proc~exp_sweep~2->proc~call_hooks var panprocend_timerCalledByGraph = svgPanZoom('#procend_timerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code end_timer Source Code subroutine end_timer ( pf , timer ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: timer double precision :: t t = MPI_Wtime () pf % runtimes ( timer ) = pf % runtimes ( timer ) + t - pf % timers ( timer ) if ( pf % echo_timings ) then write ( * , '(\"timer:\",a16,\", rank: \",i3,\", step: \",i4, \", level: \", i3,' & // '\", iter: \",i3, f23.8,f23.8,f23.8)' ) & timer_names ( timer ), pf % rank , & pf % state % step , pf % state % level , pf % state % iter , & t - pf % timers ( timer ), pf % runtimes ( timer ), t - pf % timers ( TTOTAL ) end if end subroutine end_timer","tags":"","loc":"proc/end_timer.html","title":"end_timer – LibPFASST"},{"text":"interface Interfaces for subroutines public function pf_encap_norm_p(this, flags) result(norm) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp)","tags":"","loc":"interface/pf_encap_norm_p.html","title":"pf_encap_norm_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_hook_p(pf, level, state) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level type( pf_state_t ), intent(in) :: state Description hooks subroutines","tags":"","loc":"interface/pf_hook_p.html","title":"pf_hook_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_sweep_p(this, pf, level_index, t0, dt, nsweeps, flags) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags Description SDC sweeper subroutines","tags":"","loc":"interface/pf_sweep_p.html","title":"pf_sweep_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_evaluate_p(this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"interface/pf_evaluate_p.html","title":"pf_evaluate_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_evaluate_all_p(this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"interface/pf_evaluate_all_p.html","title":"pf_evaluate_all_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_initialize_p(this, lev) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev","tags":"","loc":"interface/pf_initialize_p.html","title":"pf_initialize_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_destroy_sweeper_p(this) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this","tags":"","loc":"interface/pf_destroy_sweeper_p.html","title":"pf_destroy_sweeper_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_integrate_p(this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt Time step size class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_integrate_p.html","title":"pf_integrate_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_residual_p(this, Lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev real(kind=pfdp), intent(in) :: dt Time step size integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_residual_p.html","title":"pf_residual_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_spreadq0_p(this, Lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"interface/pf_spreadq0_p.html","title":"pf_spreadq0_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_destroy_p(this, Lev) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev","tags":"","loc":"interface/pf_destroy_p.html","title":"pf_destroy_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_do_n_steps_p(this, pf, level_index, t0, big_dt, nsteps_rk) Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: big_dt Time step size integer, intent(in) :: nsteps_rk Description time stepper interfaces","tags":"","loc":"interface/pf_do_n_steps_p.html","title":"pf_do_n_steps_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_initialize_stepper_p(this, lev) Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev","tags":"","loc":"interface/pf_initialize_stepper_p.html","title":"pf_initialize_stepper_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_destroy_stepper_p(this, Lev) Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev","tags":"","loc":"interface/pf_destroy_stepper_p.html","title":"pf_destroy_stepper_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_transfer_p(this, levelF, levelG, qF, qG, t, flags) Arguments Type Intent Optional Attributes Name class( pf_user_level_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: levelF class( pf_level_t ), intent(inout) :: levelG class( pf_encap_t ), intent(inout) :: qF class( pf_encap_t ), intent(inout) :: qG real(kind=pfdp), intent(in) :: t integer, intent(in), optional :: flags Description transfer interfaces used for restriction and interpolation","tags":"","loc":"interface/pf_transfer_p.html","title":"pf_transfer_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_create_single_p(this, x, level, shape) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) Description encapsulation interfaces","tags":"","loc":"interface/pf_encap_create_single_p.html","title":"pf_encap_create_single_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_create_array_p(this, x, n, level, shape) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:)","tags":"","loc":"interface/pf_encap_create_array_p.html","title":"pf_encap_create_array_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_destroy_single_p(this, x, level, shape) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:)","tags":"","loc":"interface/pf_encap_destroy_single_p.html","title":"pf_encap_destroy_single_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_destroy_array_p(this, x, n, level, shape) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:)","tags":"","loc":"interface/pf_encap_destroy_array_p.html","title":"pf_encap_destroy_array_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_setval_p(this, val, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_setval_p.html","title":"pf_encap_setval_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_copy_p(this, src, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_copy_p.html","title":"pf_encap_copy_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_pack_p(this, z, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_pack_p.html","title":"pf_encap_pack_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_unpack_p(this, z, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_unpack_p.html","title":"pf_encap_unpack_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_axpy_p(this, a, x, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_axpy_p.html","title":"pf_encap_axpy_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_encap_eprint_p(this, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_encap_eprint_p.html","title":"pf_encap_eprint_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_post_p(pf, level, tag, ierror, source) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag integer, intent(inout) :: ierror integer, intent(in) :: source Description communicator interfaces","tags":"","loc":"interface/pf_post_p.html","title":"pf_post_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_recv_p(pf, level, tag, blocking, ierror, source) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(inout) :: ierror integer, intent(in) :: source","tags":"","loc":"interface/pf_recv_p.html","title":"pf_recv_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_recv_status_p(pf, tag, istatus, ierror, source) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: tag integer, intent(inout) :: istatus integer, intent(inout) :: ierror integer, intent(in) :: source","tags":"","loc":"interface/pf_recv_status_p.html","title":"pf_recv_status_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_send_p(pf, level, tag, blocking, ierror, dest) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(inout) :: ierror integer, intent(in) :: dest","tags":"","loc":"interface/pf_send_p.html","title":"pf_send_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_send_status_p(pf, tag, istatus, ierror, dest) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in) :: istatus integer, intent(inout) :: ierror integer, intent(in) :: dest","tags":"","loc":"interface/pf_send_status_p.html","title":"pf_send_status_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_wait_p(pf, level, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf integer, intent(in) :: level integer, intent(inout) :: ierror","tags":"","loc":"interface/pf_wait_p.html","title":"pf_wait_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_broadcast_p(pf, y, nvar, root, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf real(kind=pfdp), intent(in) :: y (nvar) integer, intent(in) :: nvar integer, intent(in) :: root integer, intent(inout) :: ierror","tags":"","loc":"interface/pf_broadcast_p.html","title":"pf_broadcast_p – LibPFASST"},{"text":"interface Interfaces for subroutines public subroutine pf_results_p(this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this","tags":"","loc":"interface/pf_results_p.html","title":"pf_results_p – LibPFASST"},{"text":"public subroutine misdcQ_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks proc~~misdcq_sweep~~UsesGraph proc~misdcq_sweep misdcQ_sweep module~pf_mod_hooks pf_mod_hooks proc~misdcq_sweep->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~misdcq_sweep->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Assign level pointer Loop over sweeps Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Calls proc~~misdcq_sweep~~CallsGraph proc~misdcq_sweep misdcQ_sweep proc~call_hooks call_hooks proc~misdcq_sweep->proc~call_hooks proc~pf_residual pf_residual proc~misdcq_sweep->proc~pf_residual proc~start_timer start_timer proc~misdcq_sweep->proc~start_timer proc~end_timer end_timer proc~misdcq_sweep->proc~end_timer proc~call_hooks->proc~start_timer proc~call_hooks->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code misdcQ_sweep Source Code subroutine misdcQ_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_misdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev integer :: m , n , k real ( pfdp ) :: t call start_timer ( pf , TLEVEL + lev % index - 1 ) lev => pf % levels ( level_index ) !!  Assign level pointer do k = 1 , nsweeps !!  Loop over sweeps call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) call this % I3 ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 )) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( m , n ), lev % F ( n , 3 )) call this % I3 ( m )% axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 )) !  Note we have to leave off the -dt*Qtil here and put it in after f2comp end do if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do ! do the time-stepping if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 ) endif t = t0 do m = 1 , lev % nnodes - 1 t = t + dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m )) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 )) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( Lev % Q ( m + 1 )) do n = 1 , m call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m )) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 3 ), 3 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 ) end do call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine misdcQ_sweep","tags":"","loc":"proc/misdcq_sweep.html","title":"misdcQ_sweep – LibPFASST"},{"text":"public subroutine misdcQ_initialize(this, lev) Array of substep sizes Make space for rhs Make space for extra integration piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code misdcQ_initialize Source Code subroutine misdcQ_initialize ( this , lev ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , n , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) ! S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) ! S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) ! S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) ! S-BE allocate ( this % dtsdc ( nnodes - 1 )) this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp !>  Array of substep sizes this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) !>  Make space for extra integration piece call lev % ulevel % factory % create_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) end subroutine misdcQ_initialize","tags":"","loc":"proc/misdcq_initialize.html","title":"misdcQ_initialize – LibPFASST"},{"text":"public subroutine misdcQ_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code misdcQ_destroy Source Code subroutine misdcQ_destroy ( this , lev ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( this % rhs , lev % index , lev % shape ) end subroutine misdcQ_destroy","tags":"","loc":"proc/misdcq_destroy.html","title":"misdcQ_destroy – LibPFASST"},{"text":"public subroutine misdcQ_integrate(this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags Contents Source Code misdcQ_integrate Source Code subroutine misdcQ_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine misdcQ_integrate","tags":"","loc":"proc/misdcq_integrate.html","title":"misdcQ_integrate – LibPFASST"},{"text":"public subroutine misdcQ_evaluate(this, lev, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code misdcQ_evaluate Source Code subroutine misdcQ_evaluate ( this , lev , t , m , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 ) end subroutine misdcQ_evaluate","tags":"","loc":"proc/misdcq_evaluate.html","title":"misdcQ_evaluate – LibPFASST"},{"text":"public subroutine misdcQ_evaluate_all(this, lev, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~misdcq_evaluate_all~~CallsGraph proc~misdcq_evaluate_all misdcQ_evaluate_all proc~pf_generic_evaluate_all pf_generic_evaluate_all proc~misdcq_evaluate_all->proc~pf_generic_evaluate_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code misdcQ_evaluate_all Source Code subroutine misdcQ_evaluate_all ( this , lev , t , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine misdcQ_evaluate_all","tags":"","loc":"proc/misdcq_evaluate_all.html","title":"misdcQ_evaluate_all – LibPFASST"},{"text":"public subroutine misdcQ_residual(this, lev, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags Calls proc~~misdcq_residual~~CallsGraph proc~misdcq_residual misdcQ_residual proc~pf_generic_residual pf_generic_residual proc~misdcq_residual->proc~pf_generic_residual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code misdcQ_residual Source Code subroutine misdcQ_residual ( this , lev , dt , flags ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags call pf_generic_residual ( this , lev , dt ) end subroutine misdcQ_residual","tags":"","loc":"proc/misdcq_residual.html","title":"misdcQ_residual – LibPFASST"},{"text":"public subroutine misdcQ_spreadq0(this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~misdcq_spreadq0~~CallsGraph proc~misdcq_spreadq0 misdcQ_spreadq0 proc~pf_generic_spreadq0 pf_generic_spreadq0 proc~misdcq_spreadq0->proc~pf_generic_spreadq0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code misdcQ_spreadq0 Source Code subroutine misdcQ_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_misdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine misdcQ_spreadq0","tags":"","loc":"proc/misdcq_spreadq0.html","title":"misdcQ_spreadq0 – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate Description This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two","tags":"","loc":"interface/pf_f_eval_p~7.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate Description Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece","tags":"","loc":"interface/pf_f_comp_p~6.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine pf_predictor_oc(pf, t0, dt, flags) Step 1. Getting the  initial condition on the finest level at each processor\n         If we are doing multiple levels, then we need to coarsen to fine level\n  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction\n If RK_pred is true, just do some RK_steps Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf PFASST main data structure real(kind=pfdp), intent(in) :: t0 Initial time of this processor real(kind=pfdp), intent(in) :: dt time step integer, intent(in), optional :: flags (:) User defined flags Calls proc~~pf_predictor_oc~~CallsGraph proc~pf_predictor_oc pf_predictor_oc proc~end_timer end_timer proc~pf_predictor_oc->proc~end_timer proc~restrict_time_space_fas restrict_time_space_fas proc~pf_predictor_oc->proc~restrict_time_space_fas proc~pf_residual pf_residual proc~pf_predictor_oc->proc~pf_residual proc~pf_send pf_send proc~pf_predictor_oc->proc~pf_send proc~call_hooks call_hooks proc~pf_predictor_oc->proc~call_hooks proc~pf_recv pf_recv proc~pf_predictor_oc->proc~pf_recv proc~start_timer start_timer proc~pf_predictor_oc->proc~start_timer proc~interpolate_time_space interpolate_time_space proc~pf_predictor_oc->proc~interpolate_time_space mpi_wtime mpi_wtime proc~end_timer->mpi_wtime proc~restrict_time_space_fas->proc~end_timer proc~restrict_time_space_fas->proc~call_hooks proc~restrict_time_space_fas->proc~start_timer proc~restrict_sdc restrict_sdc proc~restrict_time_space_fas->proc~restrict_sdc proc~pf_residual->proc~end_timer proc~pf_residual->proc~start_timer start_timer start_timer proc~pf_send->start_timer end_timer end_timer proc~pf_send->end_timer proc~call_hooks->proc~end_timer proc~call_hooks->proc~start_timer proc~pf_recv->start_timer proc~pf_recv->end_timer proc~start_timer->mpi_wtime proc~interpolate_time_space->proc~end_timer proc~interpolate_time_space->proc~call_hooks proc~interpolate_time_space->proc~start_timer proc~pf_apply_mat pf_apply_mat proc~interpolate_time_space->proc~pf_apply_mat proc~restrict_sdc->proc~pf_apply_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_predictor_oc~~CalledByGraph proc~pf_predictor_oc pf_predictor_oc proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_predictor_oc Source Code subroutine pf_predictor_oc ( pf , t0 , dt , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! PFASST main data structure real ( pfdp ), intent ( in ) :: t0 !! Initial time of this processor real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ), optional :: flags (:) !!  User defined flags class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p integer :: k !!  Loop indices integer :: level_index !!  Local variable for looping over levels real ( pfdp ) :: t0k !!  Initial time at time step k integer :: which , dir , send_tag , burnin_sweeps , my_coarse_sweeps which = 1 ! standard: predict and sweep forward-in-time dir = 1 ! for MPI communication, standard is forward-in-time if ( present ( flags )) then if ( flags ( 1 ) == 2 ) then which = 2 ! if we are computing an adjoint, predict and sweep backward-in-time dir = 2 ! communication has to be backwards as well end if if ( flags ( 1 ) == 0 ) which = 0 ! sweep forward and backward simultaneously on two components, communication only forwards end if call call_hooks ( pf , 1 , PF_PRE_PREDICTOR ) call start_timer ( pf , TPREDICTOR ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'beginning predictor' !! Step 1. Getting the  initial condition on the finest level at each processor !!         If we are doing multiple levels, then we need to coarsen to fine level f_lev_p => pf % levels ( pf % nlevels ) if ( pf % q0_style < 2 ) then !  Spread q0 to all the nodes if ( ( which == 0 ) . or . ( which == 1 )) call f_lev_p % ulevel % sweeper % spreadq0 ( f_lev_p , t0 , 1 , pf % state % step + 1 ) if ( ( which == 0 ) . or . ( which == 2 )) call f_lev_p % ulevel % sweeper % spreadq0 ( f_lev_p , t0 + dt , 2 , pf % state % step + 1 ) endif !!  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do coarsen  in predictor' if ( pf % nlevels > 1 ) then do level_index = pf % nlevels , 2 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call pf_residual ( pf , f_lev_p , dt , which ) if ( ( which == 0 ) . or . ( which == 1 )) & call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % q0 , c_lev_p % q0 , t0 , flags = 1 ) if ( ( which == 0 ) . or . ( which == 2 )) & call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % qend , c_lev_p % qend , t0 + dt , flags = 2 ) call restrict_time_space_fas ( pf , t0 , dt , level_index , flags = which ) !  Restrict call save ( c_lev_p , which ) end do !  level_index = pf%nlevels, 2, -1 end if level_index = 1 c_lev_p => pf % levels ( 1 ) if ( pf % q0_style < 3 ) then ! Step 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent !         (this is skipped if the fine initial conditions are already consistent) ! The first processor does nothing, the second does one set of sweeps, the 2nd two, etc ! Hence, this is skipped completely if nprocs=1 if ( pf % q0_style . eq . 0 ) then !  The coarse level needs burn in if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do burnin in pred' , ' RK_pred' , pf % RK_pred , ' PFASST_pred' , pf % PFASST_pred !! If RK_pred is true, just do some RK_steps if ( pf % RK_pred . or . which == 2 ) then !  Use Runge-Kutta to get the coarse initial data !  Get new initial conditions call pf_recv ( pf , c_lev_p , 100000 + pf % rank , . true ., dir ) !  Do a RK_step call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 , which ) !  Send forward/backward if ( dir == 1 ) send_tag = 100000 + pf % rank + 1 if ( dir == 2 ) send_tag = 100000 + pf % rank - 1 call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) else !  Normal PFASST burn in burnin_sweeps = pf % rank + 1 if ( which == 2 ) then if ( pf % rank == 0 ) & print * , 'WARNING --- normal PFASST burn in is not suitable for adjoint as rhs cannot be evaluated for [t0k, t0k+dt]' burnin_sweeps = pf % comm % nproc - pf % rank end if if ( pf % debug ) print * , 'DEBUG ---' , pf % rank , 'which = ' , which , 'burnin_sweeps = ' , burnin_sweeps do k = 1 , burnin_sweeps !pf%rank + 1 pf % state % iter = - k t0k = t0 - ( pf % rank ) * dt + ( k - 1 ) * dt ! Remember t0=pf%rank*dt is the beginning of this time slice so t0-(pf%rank)*dt is 0 ! and we iterate up to the correct time step. ! for optimal control problem t, t0k has no influence on f_eval, so there this does something else if ( which == 2 ) t0k = t0 + ( burnin_sweeps - 1 ) * dt - ( k - 1 ) * dt if ( pf % debug ) print * , 'DEBUG ----' , pf % rank , 't0k = ' , t0k ! Get new initial value (skip on first iteration) if ( k > 1 ) then if (( which == 0 ) . or . ( which == 1 )) call c_lev_p % q0 % copy ( c_lev_p % qend , 1 ) !                 if ((which == 0) .or. (which == 2)) call c_lev_p%qend%copy(c_lev_p%q0, 2) ! for which==0, we solve with zero terminal conditions, ! but q0,2 is not zero (source term due to state sweeps) if ( which == 2 ) call c_lev_p % qend % copy ( c_lev_p % q0 , 2 ) ! If we are doing PFASST_pred, we use the old values at nodes, otherwise spread q0 if (. not . pf % PFASST_pred ) then if ( ( which == 0 ) . or . ( which == 1 )) call c_lev_p % ulevel % sweeper % spreadq0 ( c_lev_p , t0k , 1 , pf % state % step + 1 ) !                    if( (which == 0) .or. (which == 2)) call c_lev_p%ulevel%sweeper%spreadq0(c_lev_p, t0k+dt, 2, pf%state%step+1) if ( which == 2 ) call c_lev_p % ulevel % sweeper % spreadq0 ( c_lev_p , t0k + dt , 2 , pf % state % step + 1 ) end if end if !  Do some sweeps if ( which == 0 . or . which == 1 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn , 1 ) ! was: 1 not which if ( which == 2 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn , 2 ) end do endif !  RK_pred end if ! (q0_style .eq. 0) if ( pf % q0_style > 0 ) then my_coarse_sweeps = pf % rank + 1 ! for warm start do pipelining if ( which == 2 ) my_coarse_sweeps = pf % comm % nproc - pf % rank else my_coarse_sweeps = c_lev_p % nsweeps_pred end if ! Step 4: Now we have everyone burned in, so do some coarse sweeps ! Modification: each processor does sweeps according to its rank if ( pf % nlevels > 1 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do sweeps  in predictor' , ' Pipeline_pred' , pf % Pipeline_pred level_index = 1 c_lev_p => pf % levels ( level_index ) if ( pf % Pipeline_pred ) then do k = 1 , my_coarse_sweeps !c_lev_p%nsweeps_pred pf % state % iter =- ( pf % rank + 1 ) - k !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + k , . true ., dir ) !  Do a sweep call c_lev_p % ulevel % sweeper % sweep ( pf , c_lev_p % index , t0 , dt , 1 , which ) !  Send forward/backward if ( dir == 1 ) send_tag = c_lev_p % index * 1110000 + pf % rank + 1 + k if ( dir == 2 ) send_tag = c_lev_p % index * 1110000 + pf % rank - 1 + k call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) end do ! k = 1, c_lev_p%nsweeps_pred-1 else !  Don't pipeline !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 100000 + pf % rank , . true ., dir ) !  Do sweeps !         if(which == 0 .or. which == 1) call c_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, c_lev_p%nsweeps_pred, 1) !1 ! why only state? if ( which == 0 . or . which == 1 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , my_coarse_sweeps , which ) !1 ! why only state? !         if(which == 2)                 call c_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, c_lev_p%nsweeps_pred, 2) !which if ( which == 2 ) call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , my_coarse_sweeps , 2 ) !which !  Send forward/backward if ( dir == 1 ) send_tag = c_lev_p % index * 100000 + pf % rank + 1 if ( dir == 2 ) send_tag = c_lev_p % index * 100000 + pf % rank - 1 call pf_send ( pf , c_lev_p , send_tag , . false ., dir ) endif ! (Pipeline_pred .eq. .true) then end if ! pf%nlevels > 1 !  Step 5:  Return to fine level sweeping on any level in between coarsest and finest if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'returning to fine level in predictor' do level_index = 2 , pf % nlevels !  Will do nothing with one level f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp , flags = which ) if (( which == 0 ) . or . ( which == 1 )) then call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 1 ) if ( pf % rank /= 0 ) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 1 ) end if if ( which == 2 ) then ! for which==0, qend never changes, so don't need to interpolate call f_lev_p % q0 % copy ( f_lev_p % Q ( 1 ), flags = 2 ) if ( pf % rank /= pf % comm % nproc - 1 ) call interpolate_qend ( pf , f_lev_p , c_lev_p ) end if !  Do sweeps on level unless we are at the finest level if ( level_index < pf % nlevels ) then if (( which == 0 ) . or . ( which == 1 )) & call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred , which ) !which was 1 if ( which == 2 ) & call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred , 2 ) end if end do end if call end_timer ( pf , TPREDICTOR ) call call_hooks ( pf , - 1 , PF_POST_PREDICTOR ) pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ending predictor' end subroutine pf_predictor_oc","tags":"","loc":"proc/pf_predictor_oc.html","title":"pf_predictor_oc – LibPFASST"},{"text":"public subroutine pf_check_residual_oc(pf, residual_converged) Subroutine to test residuals to determine if the current processor has converged. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf logical, intent(out) :: residual_converged Return true if residual is below tolerances Called by proc~~pf_check_residual_oc~~CalledByGraph proc~pf_check_residual_oc pf_check_residual_oc proc~pf_check_convergence_oc pf_check_convergence_oc proc~pf_check_convergence_oc->proc~pf_check_residual_oc proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_check_convergence_oc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_check_residual_oc Source Code subroutine pf_check_residual_oc ( pf , residual_converged ) type ( pf_pfasst_t ), intent ( inout ) :: pf logical , intent ( out ) :: residual_converged !! Return true if residual is below tolerances residual_converged = . false . ! Check to see if relative tolerance is met if ( pf % levels ( pf % nlevels )% residual_rel < pf % rel_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , ' residual relative tol met' , pf % levels ( pf % nlevels )% residual_rel residual_converged = . true . end if ! Check to see if relative tolerance is met if ( pf % levels ( pf % nlevels )% residual < pf % abs_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( pf % nlevels )% residual residual_converged = . true . end if end subroutine pf_check_residual_oc","tags":"","loc":"proc/pf_check_residual_oc.html","title":"pf_check_residual_oc – LibPFASST"},{"text":"public subroutine pf_check_convergence_oc(pf, send_tag, flags) Test residuals to determine if the current processor has converged,\n adapted to optimal control. Can probably be removed, when pf_pfasst_block_oc\n is changed to use pf_check_convergence of pf_check_convergence_old. Note that if the previous processor hasn't converged yet\n (pstatus), the current processor hasn't converged yet either,\n regardless of the residual. Check to see if tolerances are met Until I hear the previous processor is done, recieve it's status Check to see if I am converged\n Assign status and send it forward\n! old code below Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: send_tag integer, intent(in), optional :: flags Calls proc~~pf_check_convergence_oc~~CallsGraph proc~pf_check_convergence_oc pf_check_convergence_oc proc~call_hooks call_hooks proc~pf_check_convergence_oc->proc~call_hooks proc~pf_send_status pf_send_status proc~pf_check_convergence_oc->proc~pf_send_status proc~pf_check_residual_oc pf_check_residual_oc proc~pf_check_convergence_oc->proc~pf_check_residual_oc proc~start_timer start_timer proc~call_hooks->proc~start_timer proc~end_timer end_timer proc~call_hooks->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_check_convergence_oc~~CalledByGraph proc~pf_check_convergence_oc pf_check_convergence_oc proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_check_convergence_oc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_check_convergence_oc Source Code subroutine pf_check_convergence_oc ( pf , send_tag , flags ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: send_tag !     real(pfdp),        intent(inout) :: residual !     integer,           intent(in)    :: k !     logical,           intent(out)   :: converged   !!  True if this processor is done integer , optional , intent ( in ) :: flags !     real(pfdp)     :: residual1 integer :: dir , which logical :: residual_converged , converged converged = . false . ! shortcut for fixed block mode if ( pf % abs_res_tol == 0 . and . pf % rel_res_tol == 0 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if ! in first sweep: always continue if ( pf % state % iter == 1 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 call call_hooks ( pf , 1 , PF_PRE_CONVERGENCE ) !> Check to see if tolerances are met call pf_check_residual_oc ( pf , residual_converged ) !>  Until I hear the previous processor is done, recieve it's status if ( pf % state % pstatus /= PF_STATUS_CONVERGED ) call pf_recv_status ( pf , send_tag , dir ) !>  Check to see if I am converged converged = . false . if ( residual_converged ) then if ( pf % rank == 0 . and . dir == 1 ) then converged = . true . elseif ( pf % rank == pf % comm % nproc - 1 . and . dir == 2 ) then converged = . true . else !  I am not the first/last processor, so I need to check the previous one if ( pf % state % pstatus == PF_STATUS_CONVERGED ) converged = . true . end if end if ! (residual_converged) !> Assign status and send it forward if ( converged ) then if ( pf % state % status == PF_STATUS_ITERATING ) then !  If I am converged for the first time !  then flip my flag and send the last status update pf % state % status = PF_STATUS_CONVERGED call pf_send_status ( pf , send_tag , dir ) end if else !  I am not converged, send the news pf % state % status = PF_STATUS_ITERATING call pf_send_status ( pf , send_tag , dir ) end if call call_hooks ( pf , 1 , PF_POST_CONVERGENCE ) !!! old code below ! Check to see if tolerances are met !     residual1 = pf%levels(pf%nlevels)%residual !     if (pf%state%status == PF_STATUS_ITERATING .and. residual > 0.0d0) then !        if ( (abs(1.0_pfdp - abs(residual1/residual)) < pf%rel_res_tol) .or. & !             (abs(residual1)                          < pf%abs_res_tol) ) then !           pf%state%status = PF_STATUS_CONVERGED !        end if !     end if ! !     !->why? how to do that more cleanly? !     if (pf%state%status == PF_STATUS_ITERATING .and. residual >= 0.0d0) then !                 ! if do_mixed, adjoint on last time step will be constant zero, so residual will be zero !                 ! need to stop in that case as well, but not in the very first iteration !       if( abs(residual1) < pf%abs_res_tol ) then !           pf%state%status = PF_STATUS_CONVERGED !       end if !     end if !     !!- ! !     residual = residual1 ! !     call call_hooks(pf, 1, PF_PRE_CONVERGENCE) !     if (pf%state%pstatus /= PF_STATUS_CONVERGED) call pf_recv_status(pf, 1+k, dir) ! !     if (pf%rank /= 0 .and. pf%state%pstatus == PF_STATUS_ITERATING .and. dir == 1) & !          pf%state%status = PF_STATUS_ITERATING !     if (pf%rank /= pf%comm%nproc-1 .and. pf%state%pstatus == PF_STATUS_ITERATING .and. dir == 2) & !          pf%state%status = PF_STATUS_ITERATING ! ! !     if (pf%state%status .ne. PF_STATUS_CONVERGED) !     call pf_send_status(pf, 1+k, dir) !     call call_hooks(pf, 1, PF_POST_CONVERGENCE) ! !     ! XXX: this ain't so pretty, perhaps we should use the !     ! 'nmoved' thinger to break this cycle if everyone is !     ! done... ! !     if (pf%state%status == PF_STATUS_CONVERGED) then !        converged = .true. !        return !     end if ! !     if (0 == pf%comm%nproc) then !        pf%state%status = PF_STATUS_PREDICTOR !        converged = .true. !        return !     end if end subroutine pf_check_convergence_oc","tags":"","loc":"proc/pf_check_convergence_oc.html","title":"pf_check_convergence_oc – LibPFASST"},{"text":"public subroutine pf_pfasst_block_oc(pf, dt, nsteps, predict, flags, step) Routine to do the pfasst iterations for optimal control problems on one block of processors until completion.\n  Each processor will do either a fixed number of iterations, or iterate until a tolerance is met\n  On calling, it is assumed that the levels are already loaded with the initial guesses Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsteps logical, intent(in) :: predict integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~pf_pfasst_block_oc~~CallsGraph proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~end_timer end_timer proc~pf_pfasst_block_oc->proc~end_timer proc~pf_check_convergence_oc pf_check_convergence_oc proc~pf_pfasst_block_oc->proc~pf_check_convergence_oc proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~pf_dump_results pf_dump_results proc~pf_pfasst_block_oc->proc~pf_dump_results proc~call_hooks call_hooks proc~pf_pfasst_block_oc->proc~call_hooks proc~pf_predictor_oc pf_predictor_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~start_timer start_timer proc~pf_pfasst_block_oc->proc~start_timer mpi_wtime mpi_wtime proc~end_timer->mpi_wtime proc~pf_check_convergence_oc->proc~call_hooks proc~pf_check_residual_oc pf_check_residual_oc proc~pf_check_convergence_oc->proc~pf_check_residual_oc proc~pf_send_status pf_send_status proc~pf_check_convergence_oc->proc~pf_send_status proc~restrict_time_space_fas restrict_time_space_fas proc~pf_v_cycle_oc->proc~restrict_time_space_fas proc~pf_post pf_post proc~pf_v_cycle_oc->proc~pf_post proc~pf_residual pf_residual proc~pf_v_cycle_oc->proc~pf_residual proc~interpolate_time_space interpolate_time_space proc~pf_v_cycle_oc->proc~interpolate_time_space proc~pf_send pf_send proc~pf_v_cycle_oc->proc~pf_send proc~pf_recv pf_recv proc~pf_v_cycle_oc->proc~pf_recv proc~dump_timings dump_timings proc~pf_dump_results->proc~dump_timings proc~dump_results dump_results proc~pf_dump_results->proc~dump_results proc~call_hooks->proc~end_timer proc~call_hooks->proc~start_timer proc~pf_predictor_oc->proc~end_timer proc~pf_predictor_oc->proc~call_hooks proc~pf_predictor_oc->proc~start_timer proc~pf_predictor_oc->proc~restrict_time_space_fas proc~pf_predictor_oc->proc~pf_residual proc~pf_predictor_oc->proc~interpolate_time_space proc~pf_predictor_oc->proc~pf_send proc~pf_predictor_oc->proc~pf_recv proc~start_timer->mpi_wtime timer_names timer_names proc~dump_timings->timer_names proc~restrict_time_space_fas->proc~end_timer proc~restrict_time_space_fas->proc~call_hooks proc~restrict_time_space_fas->proc~start_timer proc~restrict_sdc restrict_sdc proc~restrict_time_space_fas->proc~restrict_sdc proc~pf_residual->proc~end_timer proc~pf_residual->proc~start_timer proc~interpolate_time_space->proc~end_timer proc~interpolate_time_space->proc~call_hooks proc~interpolate_time_space->proc~start_timer proc~pf_apply_mat pf_apply_mat proc~interpolate_time_space->proc~pf_apply_mat end_timer end_timer proc~pf_send->end_timer start_timer start_timer proc~pf_send->start_timer proc~pf_recv->end_timer proc~pf_recv->start_timer proc~restrict_sdc->proc~pf_apply_mat var panprocpf_pfasst_block_ocCallsGraph = svgPanZoom('#procpf_pfasst_block_ocCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_pfasst_block_oc Source Code subroutine pf_pfasst_block_oc ( pf , dt , nsteps , predict , flags , step ) type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsteps logical , intent ( in ) :: predict integer , optional , intent ( in ) :: flags !0 (default): sweep on y and p, 1: just y, 2: just p integer , optional , intent ( in ) :: step ! not yet clear how to handle send and receive for forward and backward combined type ( pf_level_t ), pointer :: fine_lev_p , coarse_lev_p integer :: k , j , l , which , pred_flags ( 1 ), dir , ierror !dir to choose forward or backward send real ( pfdp ) :: residual logical :: converged , qbroadcast logical :: did_post_step_hook call start_timer ( pf , TTOTAL ) which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 pred_flags ( 1 ) = which if ( present ( step ) ) then pf % state % step = step else pf % state % step = pf % rank end if !     print *, pf%state%step pf % state % dt = dt pf % state % proc = pf % rank + 1 pf % state % t0 = pf % state % step * dt pf % state % iter = - 1 !     pf%state%itcnt   = 0 pf % state % mysteps = 0 pf % state % status = PF_STATUS_PREDICTOR pf % state % pstatus = PF_STATUS_PREDICTOR pf % comm % statreq = - 66 pf % state % nsteps = nsteps !     pf%state%component = which residual = - 1 did_post_step_hook = . false . !    call pf%results%initialize(nsteps, pf%niters, pf%comm%nproc, pf%nlevels) !    call pf_initialize_results(pf)   !  This one is the correct way !     do k = 1, 666666666 ! !        qbroadcast = .false. ! !        if (pf%state%status == PF_STATUS_CONVERGED .and. .not. did_post_step_hook) then !          call call_hooks(pf, -1, PF_POST_STEP) !          did_post_step_hook = .true. !          pf%state%itcnt = pf%state%itcnt + pf%state%iter !          pf%state%mysteps = pf%state%mysteps + 1 !          exit !        end if ! !        ! jump to next block if we've reached the max iteration count !        if (pf%state%iter >= pf%niters) then ! !           print *, pf%rank, 'pf%state%iter >= pf%niters' !           if (.not. did_post_step_hook) then !             call call_hooks(pf, -1, PF_POST_STEP) !             pf%state%itcnt = pf%state%itcnt + pf%state%iter !             pf%state%mysteps = pf%state%mysteps + 1 !           end if !           did_post_step_hook = .false. ! !           pf%state%step = pf%state%step + pf%comm%nproc !           pf%state%t0   = pf%state%step * dt ! !           if (pf%state%step >= pf%state%nsteps) exit  ! for optimal control this exit should always happen ! !           pf%state%status = PF_STATUS_PREDICTOR !           !pf%state%block  = pf%state%block + 1 !           residual = -1 !           qbroadcast = .true. !        end if ! !        if (k > 1 .and. qbroadcast) then !           if (pf%comm%nproc > 1) then !              stop \"broadcast not supported\" !              !fine_lev_p => pf%levels(pf%nlevels) !              !call pf%comm%wait(pf, pf%nlevels) !              !call fine_lev_p%encap%pack(fine_lev_p%send, fine_lev_p%qend) !              !call pf_broadcast(pf, fine_lev_p%send, fine_lev_p%nvars, pf%comm%nproc-1) !              !call fine_lev_p%encap%unpack(fine_lev_p%q0,fine_lev_p%send) !           else !              stop \"we should not be here I guess\" !              ! for sequential optimal control, we need to save the Q(m) values for state solution !              ! and load them when solving the adjoint !              ! additionally, state solution is needed for objective, adjoint for gradient ! !              !print *, 'copying initial/terminal value' !              fine_lev_p => pf%levels(pf%nlevels) !              if ((which .eq. 0) .or. (which .eq. 1)) call fine_lev_p%q0%copy(fine_lev_p%qend, 1) !              if (which .eq. 2) call fine_lev_p%qend%copy(fine_lev_p%q0, 2) !           end if !        end if !       if (pf%state%status == PF_STATUS_PREDICTOR) then !         !print *, 'pf%state%status == PF_STATUS_PREDICTOR', pf%state%t0, dt, which if ( predict ) then !print *, 'calling predictor' call pf_predictor_oc ( pf , pf % state % t0 , dt , pred_flags ) else pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING end if !       end if call call_hooks ( pf , - 1 , PF_POST_ITERATION ) !       pf%state%iter  = pf%state%iter + 1 ! ! !       exit! just do predictor ! !       call start_timer(pf, TITERATION) !       call call_hooks(pf, -1, PF_PRE_ITERATION) ! !       if (pf%state%status /= PF_STATUS_CONVERGED) then !           fine_lev_p => pf%levels(pf%nlevels) !           call fine_lev_p%ulevel%sweeper%sweep(pf, pf%nlevels, pf%state%t0, dt, fine_lev_p%nsweeps, which) !        end if ! !       ! check convergence  (should always be not converged) !       call pf_check_convergence_oc(pf, k,  residual, converged, dir) ! !       if (pf%state%step >= pf%state%nsteps) exit ! !       if (.not. converged) then !         !   non-blocking receive at all but the coarsest level !         do l = 2, pf%nlevels !           fine_lev_p => pf%levels(l) !           call pf_post(pf, fine_lev_p, fine_lev_p%index*10000+k, dir) !         end do ! !         if (pf%state%status /= PF_STATUS_CONVERGED) then !           fine_lev_p => pf%levels(pf%nlevels) !           call pf_send(pf, fine_lev_p, fine_lev_p%index*10000+k, .false., dir) !           if (pf%nlevels > 1) then !             coarse_lev_p => pf%levels(pf%nlevels-1) !             call restrict_time_space_fas(pf, pf%state%t0, dt, pf%nlevels, flags=which) !             call save(coarse_lev_p, which) !           end if !         end if ! !         call pf_v_cycle_oc(pf, k, pf%state%t0, dt, which) !         call call_hooks(pf, -1, PF_POST_ITERATION) !         call end_timer(pf, TITERATION) !       end if !     end do  !  Niter loop ! !     pf%state%iter = -1 !     call end_timer(pf, TTOTAL) k = 1 ! always one block  TO DO:  fix this pf % state % pfblock = k do j = 1 , pf % niters call start_timer ( pf , TITERATION ) call call_hooks ( pf , - 1 , PF_PRE_ITERATION ) pf % state % iter = j !  Do a v_cycle !       call pf_v_cycle(pf, k, pf%state%t0, dt, 1 ,pf%nlevels) call pf_v_cycle_oc ( pf , j , pf % state % t0 , dt , 1 , pf % nlevels , which ) !  Check for convergence call pf_check_convergence_oc ( pf , send_tag = 1111 * k + j , flags = dir ) call call_hooks ( pf , - 1 , PF_POST_ITERATION ) call end_timer ( pf , TITERATION ) !  If we are converged, exit block if ( pf % state % status == PF_STATUS_CONVERGED ) exit end do !  Loop over the iteration in this block call call_hooks ( pf , - 1 , PF_POST_CONVERGENCE ) pf % state % itcnt = pf % state % itcnt + pf % state % iter call call_hooks ( pf , - 1 , PF_POST_STEP ) call pf_dump_results ( pf ) call end_timer ( pf , TTOTAL ) end subroutine pf_pfasst_block_oc","tags":"","loc":"proc/pf_pfasst_block_oc.html","title":"pf_pfasst_block_oc – LibPFASST"},{"text":"public subroutine pf_v_cycle_oc(pf, iteration, t0, dt, level_index_c, level_index_f, flags) Post the nonblocking receives on the all the levels that will be recieving later\n    (for single level this will be skipped)\n move from fine to coarse doing sweeps Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: iteration real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: level_index_c Coarsest level of V-cycle integer, intent(in) :: level_index_f Finest level of V-cycle integer, intent(in), optional :: flags Calls proc~~pf_v_cycle_oc~~CallsGraph proc~pf_v_cycle_oc pf_v_cycle_oc proc~restrict_time_space_fas restrict_time_space_fas proc~pf_v_cycle_oc->proc~restrict_time_space_fas proc~pf_post pf_post proc~pf_v_cycle_oc->proc~pf_post proc~pf_residual pf_residual proc~pf_v_cycle_oc->proc~pf_residual proc~pf_send pf_send proc~pf_v_cycle_oc->proc~pf_send proc~pf_recv pf_recv proc~pf_v_cycle_oc->proc~pf_recv proc~interpolate_time_space interpolate_time_space proc~pf_v_cycle_oc->proc~interpolate_time_space proc~restrict_sdc restrict_sdc proc~restrict_time_space_fas->proc~restrict_sdc proc~end_timer end_timer proc~restrict_time_space_fas->proc~end_timer proc~call_hooks call_hooks proc~restrict_time_space_fas->proc~call_hooks proc~start_timer start_timer proc~restrict_time_space_fas->proc~start_timer proc~pf_residual->proc~end_timer proc~pf_residual->proc~start_timer end_timer end_timer proc~pf_send->end_timer start_timer start_timer proc~pf_send->start_timer proc~pf_recv->end_timer proc~pf_recv->start_timer proc~interpolate_time_space->proc~end_timer proc~interpolate_time_space->proc~call_hooks proc~pf_apply_mat pf_apply_mat proc~interpolate_time_space->proc~pf_apply_mat proc~interpolate_time_space->proc~start_timer proc~restrict_sdc->proc~pf_apply_mat mpi_wtime mpi_wtime proc~end_timer->mpi_wtime proc~call_hooks->proc~end_timer proc~call_hooks->proc~start_timer proc~start_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_v_cycle_oc~~CalledByGraph proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_v_cycle_oc Source Code subroutine pf_v_cycle_oc ( pf , iteration , t0 , dt , level_index_c , level_index_f , flags ) ! Execute a V-cycle between levels nfine and ncoarse type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 , dt integer , intent ( in ) :: iteration integer , intent ( in ) :: level_index_c !! Coarsest level of V-cycle integer , intent ( in ) :: level_index_f !! Finest level of V-cycle integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: f_lev_p , c_lev_p integer :: level_index , j , which , dir which = 1 if ( present ( flags )) which = flags ! send forward by default, even if sweeping on both components; send backwards if sweeping on p only dir = 1 if ( which == 2 ) dir = 2 ! !     !  For a single level, just get new initial conditions and return !     if (pf%nlevels == 1) then !        f_lev_p => pf%levels(1) !        call pf_recv(pf, f_lev_p, f_lev_p%index*10000+iteration, .true., dir) !        return !     end if !>  Post the nonblocking receives on the all the levels that will be recieving later !>    (for single level this will be skipped) do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ) call pf_post ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , dir ) end do !     ! !     ! down (fine to coarse) !     ! !     do level_index = pf%nlevels-1, 2, -1 !       f_lev_p => pf%levels(level_index); !       c_lev_p => pf%levels(level_index-1) !       call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, f_lev_p%nsweeps, which) !       call pf_send(pf, f_lev_p, level_index*10000+iteration, .false., dir) !       call restrict_time_space_fas(pf, t0, dt, level_index, flags=which) !       call save(c_lev_p, which) !     end do !> move from fine to coarse doing sweeps do level_index = level_index_f , level_index_c + 1 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false ., dir ) call restrict_time_space_fas ( pf , t0 , dt , level_index , flags = which ) call save ( c_lev_p , which ) end do !     ! !     ! bottom  (coarsest level) !     ! !     level_index=1 !     f_lev_p => pf%levels(level_index) !     if (pf%pipeline_pred) then !        do j = 1, f_lev_p%nsweeps !           call pf_recv(pf, f_lev_p, f_lev_p%index*10000+iteration+j, .true., dir) !           call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, 1, which) !           call pf_send(pf, f_lev_p, f_lev_p%index*10000+iteration+j, .false., dir) !        end do !     else ! !       if (which == 0) then ! !         call pf_recv(pf, f_lev_p, f_lev_p%index*10000+iteration, .true., dir) ! !         call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, f_lev_p%nsweeps, 1) ! !         call pf_send(pf, f_lev_p, level_index*10000+iteration, .false., dir) ! !         call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, f_lev_p%nsweeps, 2) ! this interferes with skipping y sweeps: have to check ! !                                                                                        ! state residual in case of which==1 in sweeper as well ! !       else !         call pf_recv(pf, f_lev_p, f_lev_p%index*10000+iteration, .true., dir) !         call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, f_lev_p%nsweeps, which) !         call pf_send(pf, f_lev_p, level_index*10000+iteration, .false., dir) ! !       endif !     endif ! Do the coarsest level level_index = level_index_c f_lev_p => pf % levels ( level_index ) if ( pf % pipeline_pred ) then do j = 1 , f_lev_p % nsweeps call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . true ., dir ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 , which ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . false ., dir ) end do else call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . true ., dir ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false ., dir ) endif !     ! !     ! up  (coarse to fine) !     ! !     do level_index = 2, pf%nlevels !       f_lev_p => pf%levels(level_index); !       c_lev_p => pf%levels(level_index-1) !       call interpolate_time_space(pf, t0, dt, level_index, c_lev_p%Finterp, flags=which) !       call pf_recv(pf, f_lev_p, level_index*10000+iteration, .false., dir) ! !        if (pf%rank /= 0) then !           ! interpolate increment to q0 -- the fine initial condition !           ! needs the same increment that Q(1) got, but applied to the !           ! new fine initial condition !           if ((which .eq. 0) .or. (which .eq. 1)) call interpolate_q0(pf, f_lev_p, c_lev_p, flags=1) !        end if !        if (pf%rank /= pf%comm%nproc-1) then !           if (which .eq. 2) call interpolate_qend(pf, f_lev_p, c_lev_p) !        end if ! !        if (level_index < pf%nlevels) then !           call call_hooks(pf, level_index, PF_PRE_SWEEP) !           ! compute residual !           ! do while residual > tol and j < nswps !           ! assuming residual computed at end of sweep !           call f_lev_p%ulevel%sweeper%sweep(pf, level_index, t0, dt, f_lev_p%nsweeps, which) !        end if !     end do ! Now move coarse to fine interpolating and sweeping do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp , flags = which ) if (( flags . eq . 0 ) . or . ( flags . eq . 1 )) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 1 ) if ( flags . eq . 2 ) call f_lev_p % q0 % copy ( f_lev_p % Q ( 1 ), flags = 2 ) call pf_recv ( pf , f_lev_p , level_index * 10000 + iteration , . false ., dir ) if ( pf % rank /= 0 ) then ! interpolate increment to q0 -- the fine initial condition ! needs the same increment that Q(1) got, but applied to the ! new fine initial condition if (( which . eq . 0 ) . or . ( which . eq . 1 )) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 1 ) end if if ( pf % rank /= pf % comm % nproc - 1 ) then if ( which . eq . 2 ) call interpolate_qend ( pf , f_lev_p , c_lev_p ) end if ! don't sweep on the finest level since that is only done at beginning if ( level_index < level_index_f ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps , which ) else !  compute residual for diagnostics since we didn't sweep call pf_residual ( pf , f_lev_p , dt , which ) end if end do end subroutine pf_v_cycle_oc","tags":"","loc":"proc/pf_v_cycle_oc.html","title":"pf_v_cycle_oc – LibPFASST"},{"text":"public subroutine pf_residual(pf, lev, dt, flag) Compute full residual at each node and measure its size Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flag Calls proc~~pf_residual~~CallsGraph proc~pf_residual pf_residual proc~start_timer start_timer proc~pf_residual->proc~start_timer proc~end_timer end_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_residual~~CalledByGraph proc~pf_residual pf_residual proc~exp_sweep exp_sweep proc~exp_sweep->proc~pf_residual proc~pf_v_cycle pf_v_cycle proc~pf_v_cycle->proc~pf_residual proc~pf_predictor pf_predictor proc~pf_predictor->proc~pf_residual proc~mkrk_step mkrk_step proc~mkrk_step->proc~pf_residual proc~imk_actually_sweep imk_actually_sweep proc~imk_actually_sweep->proc~pf_residual proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_v_cycle_oc->proc~pf_residual proc~magpicard_sweep magpicard_sweep proc~magpicard_sweep->proc~pf_residual proc~rk_step rk_step proc~rk_step->proc~pf_residual proc~imexq_oc_sweep imexQ_oc_sweep proc~imexq_oc_sweep->proc~pf_residual proc~imexq_sweep imexQ_sweep proc~imexq_sweep->proc~pf_residual proc~pf_predictor_oc pf_predictor_oc proc~pf_predictor_oc->proc~pf_residual proc~misdcq_oc_sweep misdcQ_oc_sweep proc~misdcq_oc_sweep->proc~pf_residual proc~verlet_sweep verlet_sweep proc~verlet_sweep->proc~pf_residual proc~misdcq_sweep misdcQ_sweep proc~misdcq_sweep->proc~pf_residual proc~exp_sweep~2 exp_sweep proc~exp_sweep~2->proc~pf_residual proc~imk_sweep imk_sweep proc~imk_sweep->proc~mkrk_step proc~imk_sweep->proc~imk_actually_sweep proc~imk_sweep->proc~rk_step proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_v_cycle proc~pf_block_run->proc~pf_predictor proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_residual Source Code subroutine pf_residual ( pf , lev , dt , flag ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flag real ( pfdp ) :: res_norms ( lev % nnodes - 1 ) !!  Holds norms of residual real ( pfdp ) :: sol_norms ( lev % nnodes ) !!  Holds norms of solution ! for adjoint: need sol at t0 as well, not only t0+dt integer :: m call start_timer ( pf , TRESIDUAL ) call lev % ulevel % sweeper % residual ( lev , dt , flag ) ! compute max residual norm sol_norms ( 1 ) = lev % Q ( 1 )% norm ( flag ) ! for adjoint do m = 1 , lev % nnodes - 1 res_norms ( m ) = lev % R ( m )% norm ( flag ) sol_norms ( m + 1 ) = lev % Q ( m + 1 )% norm ( flag ) ! only the value at lev%nnodes is needed for forward integration, right? end do !    lev%residual = res_norms(lev%nnodes-1) m = lev % nnodes ! for usual forward integration if ( present ( flag )) then if ( flag == 2 ) m = 1 end if lev % residual = maxval ( res_norms ) if ( sol_norms ( m ) > 0.0d0 ) then lev % residual_rel = lev % residual / sol_norms ( m ) else lev % residual_rel = 0.0d0 end if if ( pf % save_residuals . and . pf % state % iter > 0 ) then pf % results ( lev % index )% residuals ( pf % state % iter , pf % state % pfblock , pf % state % sweep ) = lev % residual end if call end_timer ( pf , TRESIDUAL ) end subroutine pf_residual","tags":"","loc":"proc/pf_residual.html","title":"pf_residual – LibPFASST"},{"text":"public subroutine pf_generic_residual(this, lev, dt, flags) Generic residual\n Each sweeper can define its own residual, or use this generic one\n This routine is in the \"Q\" form, so the residual approximates\n R(m)=y(t_n) + \\int_{t_n}&#94;t_m f(y,s) ds - y(t_m)\n  Compute the integral of F from t_n to t_m at each node add tau if it exists\n subtract out the solution value Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Called by proc~~pf_generic_residual~~CalledByGraph proc~pf_generic_residual pf_generic_residual proc~imexq_residual imexQ_residual proc~imexq_residual->proc~pf_generic_residual proc~misdc_residual misdc_residual proc~misdc_residual->proc~pf_generic_residual proc~amisdc_residual amisdc_residual proc~amisdc_residual->proc~pf_generic_residual proc~misdcq_residual misdcQ_residual proc~misdcq_residual->proc~pf_generic_residual proc~imex_residual imex_residual proc~imex_residual->proc~pf_generic_residual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_generic_residual Source Code subroutine pf_generic_residual ( this , lev , dt , flags ) class ( pf_sweeper_t ), intent ( in ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , intent ( in ), optional :: flags integer :: m !>  Compute the integral of F from t_n to t_m at each node call lev % ulevel % sweeper % integrate ( lev , lev % Q , lev % F , dt , lev % I , flags ) !> add tau if it exists if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if !> subtract out the solution value if ( present ( flags )) then do m = 1 , lev % nnodes - 1 if ( ( flags . eq . 0 ) . or . ( flags . eq . 1 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 1 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 ), 1 ) end if if ( ( flags . eq . 0 ) . or . ( flags . eq . 2 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 2 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( lev % nnodes ), 2 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m ), 2 ) end if end do else do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end if end subroutine pf_generic_residual","tags":"","loc":"proc/pf_generic_residual.html","title":"pf_generic_residual – LibPFASST"},{"text":"public subroutine pf_generic_evaluate_all(this, lev, t, flags, step) Generic evaluate all\n Each sweeper can define its own evaluate_all or use this generic one Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step Called by proc~~pf_generic_evaluate_all~~CalledByGraph proc~pf_generic_evaluate_all pf_generic_evaluate_all proc~imexq_evaluate_all imexQ_evaluate_all proc~imexq_evaluate_all->proc~pf_generic_evaluate_all proc~exp_evaluate_all exp_evaluate_all proc~exp_evaluate_all->proc~pf_generic_evaluate_all proc~imex_evaluate_all imex_evaluate_all proc~imex_evaluate_all->proc~pf_generic_evaluate_all proc~magpicard_evaluate_all magpicard_evaluate_all proc~magpicard_evaluate_all->proc~pf_generic_evaluate_all proc~misdc_evaluate_all misdc_evaluate_all proc~misdc_evaluate_all->proc~pf_generic_evaluate_all proc~verlet_evaluate_all verlet_evaluate_all proc~verlet_evaluate_all->proc~pf_generic_evaluate_all proc~amisdc_evaluate_all amisdc_evaluate_all proc~amisdc_evaluate_all->proc~pf_generic_evaluate_all proc~exp_evaluate_all~2 exp_evaluate_all proc~exp_evaluate_all~2->proc~pf_generic_evaluate_all proc~misdcq_evaluate_all misdcQ_evaluate_all proc~misdcq_evaluate_all->proc~pf_generic_evaluate_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_generic_evaluate_all Source Code subroutine pf_generic_evaluate_all ( this , lev , t , flags , step ) class ( pf_sweeper_t ), intent ( in ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step integer :: m !     which = 1 !     if(present(flags)) which = flags !     mystep = 1 !     if(present(step)) mystep = step do m = 1 , lev % nnodes call lev % ulevel % sweeper % evaluate ( lev , t ( m ), m , flags = flags , step = step ) end do end subroutine pf_generic_evaluate_all","tags":"","loc":"proc/pf_generic_evaluate_all.html","title":"pf_generic_evaluate_all – LibPFASST"},{"text":"public subroutine pf_generic_spreadq0(this, lev, t0) Generic routine to spread initial conditions\n Each sweeper can define its own spreadq0 or use this generic one Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this class( pf_level_t ), intent(inout) :: lev Level on which to spread real(kind=pfdp), intent(in) :: t0 time at beginning of interval Called by proc~~pf_generic_spreadq0~~CalledByGraph proc~pf_generic_spreadq0 pf_generic_spreadq0 proc~magpicard_spreadq0 magpicard_spreadq0 proc~magpicard_spreadq0->proc~pf_generic_spreadq0 proc~exp_spreadq0 exp_spreadq0 proc~exp_spreadq0->proc~pf_generic_spreadq0 proc~exp_spreadq0~2 exp_spreadq0 proc~exp_spreadq0~2->proc~pf_generic_spreadq0 proc~imex_spreadq0 imex_spreadq0 proc~imex_spreadq0->proc~pf_generic_spreadq0 proc~imexq_spreadq0 imexQ_spreadq0 proc~imexq_spreadq0->proc~pf_generic_spreadq0 proc~misdcq_spreadq0 misdcQ_spreadq0 proc~misdcq_spreadq0->proc~pf_generic_spreadq0 proc~verlet_spreadq0 verlet_spreadq0 proc~verlet_spreadq0->proc~pf_generic_spreadq0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_generic_spreadq0 Source Code subroutine pf_generic_spreadq0 ( this , lev , t0 ) class ( pf_sweeper_t ), intent ( in ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Level on which to spread real ( pfdp ), intent ( in ) :: t0 !!  time at beginning of interval integer :: m , p !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , 1 ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 )) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p )) end do end do end subroutine pf_generic_spreadq0","tags":"","loc":"proc/pf_generic_spreadq0.html","title":"pf_generic_spreadq0 – LibPFASST"},{"text":"public subroutine pf_stop(pf_file, Nline, msg, N) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: pf_file integer, intent(in) :: Nline character(len=*), intent(in) :: msg integer, intent(in), optional :: N Called by proc~~pf_stop~~CalledByGraph proc~pf_stop pf_stop proc~pf_quadrature pf_quadrature proc~pf_quadrature->proc~pf_stop proc~sdc_qnodes sdc_qnodes proc~pf_quadrature->proc~sdc_qnodes proc~ndarray_oc_unpack ndarray_oc_unpack proc~ndarray_oc_unpack->proc~pf_stop proc~imexq_oc_spreadq0 imexQ_oc_spreadq0 proc~imexq_oc_spreadq0->proc~pf_stop proc~ndarray_axpy ndarray_axpy proc~ndarray_axpy->proc~pf_stop proc~ndarray_copy ndarray_copy proc~ndarray_copy->proc~pf_stop proc~fftf fftf proc~fftf->proc~pf_stop proc~myluq myLUq proc~myluq->proc~pf_stop proc~fftb fftb proc~fftb->proc~pf_stop proc~ndarray_oc_build ndarray_oc_build proc~ndarray_oc_build->proc~pf_stop proc~fftf~2 fftf proc~fftf~2->proc~pf_stop proc~ndarray_oc_destroy_single ndarray_oc_destroy_single proc~ndarray_oc_destroy_single->proc~pf_stop proc~verlet_initialize verlet_initialize proc~verlet_initialize->proc~pf_stop proc~fft_destroy fft_destroy proc~fft_destroy->proc~pf_stop proc~ndarray_oc_norm ndarray_oc_norm proc~ndarray_oc_norm->proc~pf_stop proc~pf_pfasst_create pf_pfasst_create proc~pf_pfasst_create->proc~pf_stop proc~pf_read_opts pf_read_opts proc~pf_pfasst_create->proc~pf_read_opts proc~ndarray_oc_copy ndarray_oc_copy proc~ndarray_oc_copy->proc~pf_stop proc~pf_print_options pf_print_options proc~pf_print_options->proc~pf_stop proc~get_array1d_oc get_array1d_oc proc~get_array1d_oc->proc~pf_stop proc~ndarray_oc_setval ndarray_oc_setval proc~ndarray_oc_setval->proc~pf_stop proc~fft_setup fft_setup proc~fft_setup->proc~pf_stop proc~fftb~2 fftb proc~fftb~2->proc~pf_stop proc~make_deriv_3d make_deriv_3d proc~make_deriv_3d->proc~pf_stop proc~ndarray_oc_destroy_array ndarray_oc_destroy_array proc~ndarray_oc_destroy_array->proc~pf_stop proc~ndarray_oc_pack ndarray_oc_pack proc~ndarray_oc_pack->proc~pf_stop proc~make_deriv_3d~2 make_deriv_3d proc~make_deriv_3d~2->proc~pf_stop proc~misdcq_oc_spreadq0 misdcQ_oc_spreadq0 proc~misdcq_oc_spreadq0->proc~pf_stop proc~fft_destroy~2 fft_destroy proc~fft_destroy~2->proc~pf_stop proc~sdc_qnodes->proc~pf_stop proc~fft_setup~2 fft_setup proc~fft_setup~2->proc~pf_stop proc~get_array3d_oc get_array3d_oc proc~get_array3d_oc->proc~pf_stop proc~ndarray_oc_axpy ndarray_oc_axpy proc~ndarray_oc_axpy->proc~pf_stop proc~get_array2d_oc get_array2d_oc proc~get_array2d_oc->proc~pf_stop proc~cast_as_ndarray_oc cast_as_ndarray_oc proc~cast_as_ndarray_oc->proc~pf_stop proc~pf_read_opts->proc~pf_stop proc~conv_1d conv_1d proc~conv_1d->proc~fftf proc~conv_1d->proc~fftb proc~conv_3d~2 conv_3d proc~conv_3d~2->proc~fftf~2 proc~conv_3d~2->proc~fftb~2 proc~pf_make_matrices pf_make_matrices proc~pf_make_matrices->proc~myluq proc~conv_1d~2 conv_1d proc~conv_1d~2->proc~fftf~2 proc~conv_1d~2->proc~fftb~2 proc~conv_2d conv_2d proc~conv_2d->proc~fftf proc~conv_2d->proc~fftb proc~ndarray_oc_destroy ndarray_oc_destroy proc~ndarray_oc_destroy->proc~cast_as_ndarray_oc proc~ndarray_oc_dump_all_hook ndarray_oc_dump_all_hook proc~ndarray_oc_dump_all_hook->proc~cast_as_ndarray_oc proc~ndarray_oc_create_single ndarray_oc_create_single proc~ndarray_oc_create_single->proc~ndarray_oc_build proc~ndarray_oc_dump_hook ndarray_oc_dump_hook proc~ndarray_oc_dump_hook->proc~cast_as_ndarray_oc proc~conv_3d conv_3d proc~conv_3d->proc~fftf proc~conv_3d->proc~fftb proc~conv_2d~2 conv_2d proc~conv_2d~2->proc~fftf~2 proc~conv_2d~2->proc~fftb~2 proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->proc~pf_quadrature proc~pf_init_sdcmats->proc~pf_make_matrices proc~pf_level_setup pf_level_setup proc~pf_level_setup->proc~pf_init_sdcmats proc~pf_pfasst_setup pf_pfasst_setup proc~pf_pfasst_setup->proc~pf_level_setup var panprocpf_stopCalledByGraph = svgPanZoom('#procpf_stopCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_stop Source Code subroutine pf_stop ( pf_file , Nline , msg , N ) character ( len =* ), intent ( in ) :: pf_file integer , intent ( in ) :: Nline character ( len =* ), intent ( in ) :: msg integer , intent ( in ), optional :: N print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' print * , 'Stopping in File: ' , pf_file print * , 'Line number: ' , Nline print * , msg if ( present ( N )) print * , 'value=' , N print * , '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' stop end subroutine pf_stop","tags":"","loc":"proc/pf_stop.html","title":"pf_stop – LibPFASST"},{"text":"public subroutine imexQ_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks proc~~imexq_sweep~~UsesGraph proc~imexq_sweep imexQ_sweep module~pf_mod_hooks pf_mod_hooks proc~imexq_sweep->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~imexq_sweep->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Perform nsweep SDC sweeps on level level_index and set qend appropriately.\n  Assign level pointer Loop over sweeps\n  Loop over substeps\n  Accumulate rhs\n  Add the integral term Add the starting value Solve for the implicit piece\n  Compute explicit function on new value End substep loop Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Calls proc~~imexq_sweep~~CallsGraph proc~imexq_sweep imexQ_sweep proc~call_hooks call_hooks proc~imexq_sweep->proc~call_hooks proc~pf_residual pf_residual proc~imexq_sweep->proc~pf_residual proc~start_timer start_timer proc~imexq_sweep->proc~start_timer proc~end_timer end_timer proc~imexq_sweep->proc~end_timer proc~call_hooks->proc~start_timer proc~call_hooks->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imexQ_sweep Source Code subroutine imexQ_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imexQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: m , n , k !!  Loop variables real ( pfdp ) :: t !!  Time at nodes lev => pf % levels ( level_index ) !!  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps !!  Loop over sweeps pf % state % sweep = k call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) if ( this % explicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) end do end if if ( this % implicit ) then do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 )) end do end if if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% copy ( lev % q0 ) if ( this % explicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 ) end if t = t0 ! do the sub-stepping in sweep do m = 1 , lev % nnodes - 1 !!  Loop over substeps t = t + dt * this % dtsdc ( m ) !>  Accumulate rhs call this % rhs % setval ( 0.0_pfdp ) do n = 1 , m if ( this % explicit ) & call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) if ( this % implicit ) & call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do !>  Add the integral term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m )) !>  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 )) !>  Solve for the implicit piece if ( this % implicit ) then call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 ) else call lev % Q ( m + 1 )% copy ( this % rhs ) end if !>  Compute explicit function on new value if ( this % explicit ) & call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 ) end do !!  End substep loop call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes )) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imexQ_sweep","tags":"","loc":"proc/imexq_sweep.html","title":"imexQ_sweep – LibPFASST"},{"text":"public subroutine imexQ_initialize(this, lev) Uses pf_mod_quadrature proc~~imexq_initialize~~UsesGraph proc~imexq_initialize imexQ_initialize module~pf_mod_quadrature pf_mod_quadrature proc~imexq_initialize->module~pf_mod_quadrature module~pf_mod_utils pf_mod_utils module~pf_mod_quadrature->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_quadrature->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi var panprocimexq_initializeUsesGraph = svgPanZoom('#procimexq_initializeUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to initialize matrices and space for sweeper\n  Array of substep sizes Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level Contents Source Code imexQ_initialize Source Code subroutine imexQ_initialize ( this , lev ) use pf_mod_quadrature class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level integer :: nnodes , ierr this % npieces = 2 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imexQ_initialize for QdiffE\" allocate ( this % QdiffI ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imexQ_initialize for QdiffI\" allocate ( this % QtilE ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imexQ_initialize for QtilE\" allocate ( this % QtilI ( nnodes - 1 , nnodes ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imexQ_initialize for QtilI\" allocate ( this % dtsdc ( nnodes - 1 ), stat = ierr ) if ( ierr /= 0 ) stop \"allocate fail in imexQ_initialize for dtsdc\" this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp !>  Array of substep sizes this % dtsdc = lev % sdcmats % qnodes ( 2 : nnodes ) - lev % sdcmats % qnodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) end subroutine imexQ_initialize","tags":"","loc":"proc/imexq_initialize.html","title":"imexQ_initialize – LibPFASST"},{"text":"public subroutine imexQ_destroy(this, lev) Subroutine to deallocate sweeper Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level Contents Source Code imexQ_destroy Source Code subroutine imexQ_destroy ( this , lev ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_single ( this % rhs , lev % index , lev % shape ) end subroutine imexQ_destroy","tags":"","loc":"proc/imexq_destroy.html","title":"imexQ_destroy – LibPFASST"},{"text":"public subroutine imexQ_integrate(this, lev, qSDC, fSDC, dt, fintSDC, flags) Subroutine to compute  Picard integral of function values Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags Contents Source Code imexQ_integrate Source Code subroutine imexQ_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev !!  Current level class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags integer :: n , m do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes if ( this % explicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 1 )) if ( this % implicit ) & call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , 2 )) end do end do end subroutine imexQ_integrate","tags":"","loc":"proc/imexq_integrate.html","title":"imexQ_integrate – LibPFASST"},{"text":"public subroutine imexQ_residual(this, lev, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags Calls proc~~imexq_residual~~CallsGraph proc~imexq_residual imexQ_residual proc~pf_generic_residual pf_generic_residual proc~imexq_residual->proc~pf_generic_residual Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imexQ_residual Source Code subroutine imexQ_residual ( this , lev , dt , flags ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags call pf_generic_residual ( this , lev , dt ) end subroutine imexQ_residual","tags":"","loc":"proc/imexq_residual.html","title":"imexQ_residual – LibPFASST"},{"text":"public subroutine imexQ_spreadq0(this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~imexq_spreadq0~~CallsGraph proc~imexq_spreadq0 imexQ_spreadq0 proc~pf_generic_spreadq0 pf_generic_spreadq0 proc~imexq_spreadq0->proc~pf_generic_spreadq0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imexQ_spreadq0 Source Code subroutine imexQ_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine imexQ_spreadq0","tags":"","loc":"proc/imexq_spreadq0.html","title":"imexQ_spreadq0 – LibPFASST"},{"text":"public subroutine imexQ_evaluate(this, lev, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imexQ_evaluate Source Code subroutine imexQ_evaluate ( this , lev , t , m , flags , step ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step if ( this % explicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 ) if ( this % implicit ) & call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 ) end subroutine imexQ_evaluate","tags":"","loc":"proc/imexq_evaluate.html","title":"imexQ_evaluate – LibPFASST"},{"text":"public subroutine imexQ_evaluate_all(this, lev, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~imexq_evaluate_all~~CallsGraph proc~imexq_evaluate_all imexQ_evaluate_all proc~pf_generic_evaluate_all pf_generic_evaluate_all proc~imexq_evaluate_all->proc~pf_generic_evaluate_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imexQ_evaluate_all Source Code subroutine imexQ_evaluate_all ( this , lev , t , flags , step ) class ( pf_imexQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine imexQ_evaluate_all","tags":"","loc":"proc/imexq_evaluate_all.html","title":"imexQ_evaluate_all – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate Description This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two","tags":"","loc":"interface/pf_f_eval_p~8.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate Description Solve the equation y - dtq*f_2(y) =rhs","tags":"","loc":"interface/pf_f_comp_p~7.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine exp_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code exp_initialize Source Code subroutine exp_initialize ( this , lev ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev ! local variables integer :: i , nnodes real ( pfdp ), allocatable :: q (:) nnodes = lev % nnodes allocate ( this % eta ( nnodes - 1 )) allocate ( this % nodes ( nnodes )) allocate ( q ( nnodes )) ! set nodes and substeps this % nodes = lev % sdcmats % qnodes this % eta = this % nodes ( 2 : nnodes ) - this % nodes ( 1 : nnodes - 1 ) ! substeps ! compute weights allocate ( this % w ( nnodes - 1 , nnodes , nnodes )) do i = 1 , nnodes - 1 q = this % nodes - this % nodes ( i ); call weights ( this , real ( 0.0 , pfdp ), q , nnodes - 1 , this % W ( i , :, :)); end do ! set number of rhs components this % npieces = 1 ! initialize temporary storage objects call lev % ulevel % factory % create_single ( this % newF , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % b , nnodes + 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % f_old , nnodes , lev % index , lev % shape ) end subroutine exp_initialize","tags":"","loc":"proc/exp_initialize~2.html","title":"exp_initialize – LibPFASST"},{"text":"public subroutine exp_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks proc~~exp_sweep~2~~UsesGraph proc~exp_sweep~2 exp_sweep module~pf_mod_hooks pf_mod_hooks proc~exp_sweep~2->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~exp_sweep~2->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Calls proc~~exp_sweep~2~~CallsGraph proc~exp_sweep~2 exp_sweep proc~call_hooks call_hooks proc~exp_sweep~2->proc~call_hooks proc~pf_residual pf_residual proc~exp_sweep~2->proc~pf_residual proc~localderivsatnode~2 LocalDerivsAtNode proc~exp_sweep~2->proc~localderivsatnode~2 proc~start_timer start_timer proc~call_hooks->proc~start_timer proc~end_timer end_timer proc~call_hooks->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code exp_sweep Source Code subroutine exp_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks ! arguments class ( pf_exp_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags ! local variables class ( pf_level_t ), pointer :: lev integer :: m , nnodes , j , k , i real ( pfdp ) :: t lev => pf % levels ( level_index ) nnodes = lev % nnodes call lev % Q ( 1 )% copy ( lev % q0 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) ! compute F_j&#94;{[k+1]} ! error sweeps do k = 1 , nsweeps call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! NOTE: ensure that lev%F has been properly initialized here t = t0 do j = 1 , nnodes call this % f_old ( j )% copy ( lev % F ( j , 1 )) ! Save old f end do do j = 1 , nnodes - 1 t = t0 + dt * this % eta ( j ) ! form b vectors call LocalDerivsAtNode ( this , 1 , nnodes , this % f_old (:), this % b ( 2 : nnodes + 1 )) ! phi expansion for exponential picard integral !              call LocalDerivsAtNode(this, 1, nnodes, lev%F(:,1), this%b(2:nnodes+1))  ! phi expansion for exponential picard integral call this % b ( 1 )% copy ( lev % Q ( 1 )) ! add term \\phi_0(tL) y_n do i = 1 , j !                 call this%b(2)%axpy(-this%eta(i), this%f_old(i))         ! add -\\phi_1(tL) F_j&#94;{[k]} !                 call this%b(2)%axpy(this%eta(i), lev%F(i,1))          ! add \\phi_1(tL) F_j&#94;{[k+1]} end do ! compute phi products if ( this % use_phib ) then call this % phib ( this % nodes ( j + 1 ), dt , this % b , lev % Q ( j + 1 )) else call this % swpPhib ( j + 1 , dt , this % b , lev % Q ( j + 1 )) end if !              !  Now we have to add in the tauQ if ( allocated ( lev % tauQ )) then call lev % Q ( j + 1 )% axpy ( 1.0_pfdp , lev % tauQ ( j )) end if call this % f_eval ( lev % Q ( j + 1 ), t , lev % index , lev % F ( j + 1 , 1 )) ! eval last nonlinear term ! end do call lev % qend % copy ( lev % Q ( lev % nnodes )) call pf_residual ( pf , lev , dt ) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do end subroutine exp_sweep","tags":"","loc":"proc/exp_sweep~2.html","title":"exp_sweep – LibPFASST"},{"text":"public subroutine exp_integrate(this, lev, qSDC, fSDC, dt, fintsdc, flags) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintsdc (:) Integral from t_n to t_m integer, intent(in), optional :: flags Contents Source Code exp_integrate Source Code subroutine exp_integrate ( this , lev , qSDC , fSDC , dt , fintsdc , flags ) ! parameters class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev !!  Current level class ( pf_encap_t ), intent ( in ) :: qSDC (:) !!  Solution values class ( pf_encap_t ), intent ( in ) :: fSDC (:, :) !!  RHS Function values real ( pfdp ), intent ( in ) :: dt !!  Time step class ( pf_encap_t ), intent ( inout ) :: fintsdc (:) !!  Integral from t_n to t_m integer , optional , intent ( in ) :: flags ! local variables integer :: i , nnodes nnodes = lev % nnodes call LocalDerivsAtNode ( this , 1 , nnodes , fSDC (:, 1 ), this % b ( 2 : nnodes + 1 )) ! compute derivatives call this % b ( 1 )% setval ( real ( 0.0 , pfdp )) call this % b ( 1 )% axpy ( real ( 1.0 , pfdp ), qSDC ( 1 )) do i = 1 , nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}} if ( this % use_phib ) then call this % phib ( this % nodes ( i + 1 ), dt , this % b , fintsdc ( i )) else call this % resPhib ( i , dt , this % b , fintsdc ( i )) end if end do end subroutine exp_integrate","tags":"","loc":"proc/exp_integrate~2.html","title":"exp_integrate – LibPFASST"},{"text":"public subroutine exp_residual(this, lev, dt, flags) Compute the integral of F from t_n to t_m at each node add tau if it exists\n subtract out the solution value Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags Contents Source Code exp_residual Source Code subroutine exp_residual ( this , lev , dt , flags ) class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: dt !!  Time step integer , intent ( in ), optional :: flags integer :: m !>  Compute the integral of F from t_n to t_m at each node call lev % ulevel % sweeper % integrate ( lev , lev % Q , lev % F , dt , lev % I , flags ) !> add tau if it exists if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), flags ) end do end if !> subtract out the solution value do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end subroutine exp_residual","tags":"","loc":"proc/exp_residual~2.html","title":"exp_residual – LibPFASST"},{"text":"public subroutine exp_spreadq0(this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~exp_spreadq0~2~~CallsGraph proc~exp_spreadq0~2 exp_spreadq0 proc~pf_generic_spreadq0 pf_generic_spreadq0 proc~exp_spreadq0~2->proc~pf_generic_spreadq0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code exp_spreadq0 Source Code subroutine exp_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine exp_spreadq0","tags":"","loc":"proc/exp_spreadq0~2.html","title":"exp_spreadq0 – LibPFASST"},{"text":"public subroutine exp_evaluate(this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code exp_evaluate Source Code subroutine exp_evaluate ( this , lev , t , m , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t !!  Time at which to evaluate integer , intent ( in ) :: m !!  Node at which to evaluate integer , intent ( in ), optional :: flags , step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine exp_evaluate","tags":"","loc":"proc/exp_evaluate~2.html","title":"exp_evaluate – LibPFASST"},{"text":"public subroutine exp_evaluate_all(this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~exp_evaluate_all~2~~CallsGraph proc~exp_evaluate_all~2 exp_evaluate_all proc~pf_generic_evaluate_all pf_generic_evaluate_all proc~exp_evaluate_all~2->proc~pf_generic_evaluate_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code exp_evaluate_all Source Code subroutine exp_evaluate_all ( this , lev , t , flags , step ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level real ( pfdp ), intent ( in ) :: t (:) !!  Array of times at each node integer , intent ( in ), optional :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine exp_evaluate_all","tags":"","loc":"proc/exp_evaluate_all~2.html","title":"exp_evaluate_all – LibPFASST"},{"text":"public subroutine exp_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level Contents Source Code exp_destroy Source Code subroutine exp_destroy ( this , lev ) ! arguments class ( pf_exp_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev !!  Current level deallocate ( this % w ) deallocate ( this % eta ) deallocate ( this % newF ) call lev % ulevel % factory % destroy_array ( this % b , lev % index , lev % nnodes , lev % shape ) call lev % ulevel % factory % destroy_array ( this % f_old , lev % index , lev % nnodes , lev % shape ) end subroutine exp_destroy","tags":"","loc":"proc/exp_destroy~2.html","title":"exp_destroy – LibPFASST"},{"text":"public subroutine LocalDerivsAtNode(this, i, nnodes, N_eval, N_deriv) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: nnodes class( pf_encap_t ), intent(in) :: N_eval (:) class( pf_encap_t ), intent(inout) :: N_deriv (:) Called by proc~~localderivsatnode~2~~CalledByGraph proc~localderivsatnode~2 LocalDerivsAtNode proc~exp_sweep~2 exp_sweep proc~exp_sweep~2->proc~localderivsatnode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/localderivsatnode~2.html","title":"LocalDerivsAtNode – LibPFASST"},{"text":"public subroutine weights(this, z, x, m, W) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z real(kind=pfdp), intent(in) :: x (:) integer, intent(in) :: m real(kind=pfdp), intent(out) :: W (size(x),m+1) Contents Source Code weights Source Code subroutine weights ( this , z , x , m , W ) ! Arguments class ( pf_exp_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: z real ( pfdp ), intent ( in ) :: x (:) integer , intent ( in ) :: m real ( pfdp ), intent ( out ) :: W ( size ( x ), m + 1 ) ! Variable Declarations real ( pfdp ) :: c1 , c2 , c3 , c4 , c5 integer :: i , j , k , n , mn c1 = 1.0_pfdp c4 = x ( 1 ) - z W = 0.0_pfdp W ( 1 , 1 ) = 1.0_pfdp n = size ( x ) do i = 2 , n mn = min ( i , m + 1 ) c2 = 1.0_pfdp c5 = c4 c4 = x ( i ) - z do j = 1 , i - 1 c3 = x ( i ) - x ( j ) c2 = c2 * c3 ; if ( j == i - 1 ) then do k = mn , 2 , - 1 W ( i , k ) = c1 * ( real ( k - 1 , pfdp ) * W ( i - 1 , k - 1 ) - c5 * W ( i - 1 , k )) / c2 ; enddo W ( i , 1 ) = - c1 * c5 * W ( i - 1 , 1 ) / c2 ; endif do k = mn , 2 , - 1 W ( j , k ) = ( c4 * W ( j , k ) - real ( k - 1 , pfdp ) * W ( j , k - 1 )) / c3 ; enddo W ( j , 1 ) = c4 * W ( j , 1 ) / c3 ; enddo c1 = c2 ; enddo end subroutine weights","tags":"","loc":"proc/weights~2.html","title":"weights – LibPFASST"},{"text":"interface public subroutine pf_phib(this, t, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y","tags":"","loc":"interface/pf_phib~2.html","title":"pf_phib – LibPFASST"},{"text":"interface public subroutine pf_swpPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y","tags":"","loc":"interface/pf_swpphib~2.html","title":"pf_swpPhib – LibPFASST"},{"text":"interface public subroutine pf_resPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y","tags":"","loc":"interface/pf_resphib~2.html","title":"pf_resPhib – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level, n) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: n","tags":"","loc":"interface/pf_f_eval_p~9.html","title":"pf_f_eval_p – LibPFASST"},{"text":"public subroutine sweep_coupled_implicit_terms(this, pf, lev, t0, dt) Uses pf_mod_timer proc~~sweep_coupled_implicit_terms~~UsesGraph proc~sweep_coupled_implicit_terms sweep_coupled_implicit_terms module~pf_mod_timer pf_mod_timer proc~sweep_coupled_implicit_terms->module~pf_mod_timer module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Calls proc~~sweep_coupled_implicit_terms~~CallsGraph proc~sweep_coupled_implicit_terms sweep_coupled_implicit_terms proc~start_timer start_timer proc~sweep_coupled_implicit_terms->proc~start_timer proc~end_timer end_timer proc~sweep_coupled_implicit_terms->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~sweep_coupled_implicit_terms~~CalledByGraph proc~sweep_coupled_implicit_terms sweep_coupled_implicit_terms proc~amisdcq_sweep amisdcQ_sweep proc~amisdcq_sweep->proc~sweep_coupled_implicit_terms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sweep_coupled_implicit_terms Source Code subroutine sweep_coupled_implicit_terms ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev integer :: m , n real ( pfdp ) :: t real ( pfdp ) :: dtsdc ( 1 : lev % nnodes - 1 ) class ( pf_encap_t ), allocatable :: rhsA , rhsB , QA , QB class ( pf_encap_t ), allocatable :: S2 (:), S3 (:) call start_timer ( pf , TLEVEL + lev % index - 1 ) call lev % ulevel % factory % create_array ( S2 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % create_array ( S3 , lev % nnodes - 1 , lev % index , lev % shape ) ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % S ( m )% setval ( 0.0_pfdp ) call S2 ( m )% setval ( 0.0d0 ) call S3 ( m )% setval ( 0.0d0 ) do n = 1 , lev % nnodes call lev % S ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) call lev % S ( m )% axpy ( 1.0_pfdp * dt * lev % qmat ( m , n ), lev % F ( n , 2 )) call lev % S ( m )% axpy ( 1.0_pfdp * dt * lev % qmat ( m , n ), lev % F ( n , 3 )) call S2 ( m )% axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 2 )) call S3 ( m )% axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do if ( allocated ( lev % tauQ )) then call lev % S ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do ! do the time-stepping call lev % Q ( 1 )% copy ( lev % q0 ) call this % f1eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 )) call this % f2eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 )) call this % f3eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 )) call lev % ulevel % factory % create_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % create_single ( QB , lev % index , lev % shape ) call QA % setval ( 0.0_pfdp ) call QB % setval ( 0.0_pfdp ) t = t0 dtsdc = dt * ( lev % nodes ( 2 : lev % nnodes ) - lev % nodes ( 1 : lev % nnodes - 1 )) do m = 1 , lev % nnodes - 1 t = t + dtsdc ( m ) call rhsA % copy ( lev % Q ( 1 )) ! First compute the explicit part of the right-hand side do n = 1 , m call rhsA % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) end do call rhsA % axpy ( 1.0_pfdp , lev % S ( m )) ! Save the right-hand side with only the explicit contribution call rhsB % copy ( rhsA ) ! Add the first implicit part to the right-hand side and solve for the first asynchronous update do n = 1 , m call rhsA % axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 2 )) end do call rhsA % axpy ( - 1.0_pfdp , S2 ( m )) call this % f2comp ( QA , t , 2.0_pfdp * dt * this % QtilI ( m , m + 1 ), rhsA , lev % index , lev % F ( m + 1 , 2 )) ! Add the second implicit part to the right-hand side and solve for the second asynchronous update do n = 1 , m call rhsB % axpy ( 2.0_pfdp * dt * this % QtilI ( m , n ), lev % F ( n , 3 )) end do call rhsB % axpy ( - 1.0_pfdp , S3 ( m )) call this % f3comp ( QB , t , 2.0_pfdp * dt * this % QtilI ( m , m + 1 ), rhsB , lev % index , lev % F ( m + 1 , 3 )) ! Now we average the two asynchronous updates call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QA ) call lev % Q ( m + 1 )% axpy ( 0.5_pfdp , QB ) ! Evaluate the three right-hand sides with the updated variables call this % f1eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 )) call this % f2eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 )) call this % f3eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 3 )) end do call lev % qend % copy ( lev % Q ( lev % nnodes )) call lev % ulevel % factory % destroy_array ( S2 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( S3 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( rhsA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( rhsB , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QA , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( QB , lev % index , lev % shape ) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine sweep_coupled_implicit_terms","tags":"","loc":"proc/sweep_coupled_implicit_terms.html","title":"sweep_coupled_implicit_terms – LibPFASST"},{"text":"public subroutine sweep_decoupled_implicit_terms(this, pf, lev, t0, dt) Uses pf_mod_timer proc~~sweep_decoupled_implicit_terms~~UsesGraph proc~sweep_decoupled_implicit_terms sweep_decoupled_implicit_terms module~pf_mod_timer pf_mod_timer proc~sweep_decoupled_implicit_terms->module~pf_mod_timer module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Contents Source Code sweep_decoupled_implicit_terms Source Code subroutine sweep_decoupled_implicit_terms ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev ! integer                        :: m, n ! real(pfdp)                     :: t ! real(pfdp)                     :: dtsdc(1:lev%nnodes-1) ! class(pf_encap_t), allocatable :: rhsA, rhsB, QA, QB ! class(pf_encap_t), allocatable :: S2(:), S3(:) ! call start_timer(pf, TLEVEL+lev%index-1) ! call lev%ulevel%factory%create_array(S2,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%create_array(S3,lev%nnodes-1,lev%index,lev%shape) ! ! compute integrals and add fas correction ! do m = 1, lev%nnodes-1 !    call lev%S(m)%setval(0.0_pfdp) !    call S2(m)%setval(0.0d0) !    call S3(m)%setval(0.0d0) !    do n = 1, lev%nnodes !       call lev%S(m)%axpy(dt*this%QdiffE(m,n),       lev%F(n,1)) !       call S2(m)%axpy( 2.0_pfdp*dt*lev%qmat(m,n),   lev%F(n,2)) !       call S3(m)%axpy( 2.0_pfdp*dt*lev%qmat(m,n),   lev%F(n,3)) !       call S2(m)%axpy(-2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,2)) !       call S3(m)%axpy(-2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,3)) !    end do !    if (allocated(lev%tauQ)) then !       call lev%S(m)%axpy(1.0_pfdp, lev%tauQ(m)) !    end if ! end do ! ! do the time-stepping ! call lev%Q(1)%unpack(lev%q0) ! call this%f1eval(lev%Q(1), t0, lev%index, lev%F(1,1)) ! call this%f2eval(lev%Q(1), t0, lev%index, lev%F(1,2)) ! call this%f3eval(lev%Q(1), t0, lev%index, lev%F(1,3)) ! call lev%ulevel%factory%create_single(rhsA, lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(rhsB, lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(QA,   lev%index,  lev%shape) ! call lev%ulevel%factory%create_single(QB,   lev%index,  lev%shape) ! call QA%setval(0.0_pfdp) ! call QB%setval(0.0_pfdp) ! t = t0 ! dtsdc = dt * (lev%nodes(2:lev%nnodes) - lev%nodes(1:lev%nnodes-1)) ! do m = 1, lev%nnodes-1 !    t = t + dtsdc(m) !    call rhsA%copy(lev%Q(1)) !    ! First compute the explicit part of the right-hand side !    do n = 1, m !       call rhsA%axpy(dt*this%QtilE(m,n), lev%F(n,1)) !    end do !    call rhsA%axpy(1.0_pfdp, lev%S(m)) !    ! Save the right-hand side with only the explicit contribution !    call rhsB%copy(rhsA) !    ! Add the first implicit part to the right-hand side and solve for the first asynchronous update !    do n = 1, m !       call rhsA%axpy(2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,2)) !    end do !    call rhsA%axpy(1.0_pfdp, S2(m)) !    call this%f2comp(QA, t, 2.0_pfdp*dt*this%QtilI(m,m+1), rhsA, lev%index, lev%F(m+1,2)) !    ! Add the second implicit part to the right-hand side and solve for the second asynchronous update !    do n = 1, m !       call rhsB%axpy(2.0_pfdp*dt*this%QtilI(m,n), lev%F(n,3)) !    end do !    call rhsB%axpy(1.0_pfdp, S3(m)) !    call this%f3comp(QB, t, 2.0_pfdp*dt*this%QtilI(m,m+1), rhsB, lev%index, lev%F(m+1,3)) !    ! Now we average the two asynchronous updates !    call lev%Q(m+1)%setval(0.0_pfdp) !    call lev%Q(m+1)%axpy(0.5_pfdp, QA) !    call lev%Q(m+1)%axpy(0.5_pfdp, QB) !    ! Evaluate the three right-hand sides with the updated variables !    call this%f1eval(lev%Q(m+1), t, lev%index, lev%F(m+1,1)) !    call this%f2eval(lev%Q(m+1), t, lev%index, lev%F(m+1,2)) !    call this%f3eval(lev%Q(m+1), t, lev%index, lev%F(m+1,3)) ! end do ! call lev%qend%copy(lev%Q(lev%nnodes)) ! call lev%ulevel%factory%destroy_array(S2,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%destroy_array(S3,lev%nnodes-1,lev%index,lev%shape) ! call lev%ulevel%factory%destroy_single(rhsA, lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(rhsB, lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(QA,   lev%index,   lev%shape) ! call lev%ulevel%factory%destroy_single(QB,   lev%index,   lev%shape) ! call end_timer(pf, TLEVEL+lev%index-1) end subroutine sweep_decoupled_implicit_terms","tags":"","loc":"proc/sweep_decoupled_implicit_terms.html","title":"sweep_decoupled_implicit_terms – LibPFASST"},{"text":"public subroutine amisdcQ_sweep(this, pf, lev, t0, dt) Uses pf_mod_timer proc~~amisdcq_sweep~~UsesGraph proc~amisdcq_sweep amisdcQ_sweep module~pf_mod_timer pf_mod_timer proc~amisdcq_sweep->module~pf_mod_timer module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt Calls proc~~amisdcq_sweep~~CallsGraph proc~amisdcq_sweep amisdcQ_sweep proc~sweep_coupled_implicit_terms sweep_coupled_implicit_terms proc~amisdcq_sweep->proc~sweep_coupled_implicit_terms proc~start_timer start_timer proc~sweep_coupled_implicit_terms->proc~start_timer proc~end_timer end_timer proc~sweep_coupled_implicit_terms->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code amisdcQ_sweep Source Code subroutine amisdcQ_sweep ( this , pf , lev , t0 , dt ) use pf_mod_timer class ( pf_amisdcQ_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ) :: pf real ( pfdp ), intent ( in ) :: dt , t0 class ( pf_level_t ), intent ( inout ) :: lev call sweep_coupled_implicit_terms ( this , pf , lev , t0 , dt ) end subroutine amisdcQ_sweep","tags":"","loc":"proc/amisdcq_sweep.html","title":"amisdcQ_sweep – LibPFASST"},{"text":"public subroutine amisdcQ_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev Calls proc~~amisdcq_initialize~~CallsGraph proc~amisdcq_initialize amisdcQ_initialize myluq myluq proc~amisdcq_initialize->myluq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code amisdcQ_initialize Source Code subroutine amisdcQ_initialize ( this , lev ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , n , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) !  S-BE this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq_ ) then ! Get the LU call myLUq ( lev % qmat , lev % LUmat , lev % nnodes , 1 ) this % QtilI = lev % LUmat else do m = 1 , nnodes - 1 do n = 1 , m this % QtilI ( m , n + 1 ) = dsdc ( n ) end do end do end if ! Explicit matrix do m = 1 , nnodes - 1 do n = 1 , m this % QtilE ( m , n ) = dsdc ( n ) end do end do this % QdiffE = lev % qmat - this % QtilE this % QdiffI = lev % qmat - this % QtilI end subroutine amisdcQ_initialize","tags":"","loc":"proc/amisdcq_initialize.html","title":"amisdcQ_initialize – LibPFASST"},{"text":"public subroutine amisdcQ_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev Contents Source Code amisdcQ_destroy Source Code subroutine amisdcQ_destroy ( this , lev ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) end subroutine amisdcQ_destroy","tags":"","loc":"proc/amisdcq_destroy.html","title":"amisdcQ_destroy – LibPFASST"},{"text":"public subroutine amisdcQ_integrate(this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(in) :: lev class(pf_encap_t), intent(in) :: qSDC (:) class(pf_encap_t), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class(pf_encap_t), intent(inout) :: fintSDC (:) Contents Source Code amisdcQ_integrate Source Code subroutine amisdcQ_integrate ( this , lev , qSDC , fSDC , dt , fintSDC ) class ( pf_amisdcQ_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer :: n , m , p do n = 1 , lev % nnodes - 1 call fintSDC ( n )% setval ( 0.0_pfdp ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % qmat ( n , m ), fSDC ( m , p )) end do end do end do end subroutine amisdcQ_integrate","tags":"","loc":"proc/amisdcq_integrate.html","title":"amisdcQ_integrate – LibPFASST"},{"text":"public subroutine imk_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks proc~~imk_sweep~~UsesGraph proc~imk_sweep imk_sweep module~pf_mod_hooks pf_mod_hooks proc~imk_sweep->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~imk_sweep->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Perform nsweep  sweeps on level  and set qend appropriately. Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags Calls proc~~imk_sweep~~CallsGraph proc~imk_sweep imk_sweep proc~rk_step rk_step proc~imk_sweep->proc~rk_step proc~mkrk_step mkrk_step proc~imk_sweep->proc~mkrk_step proc~imk_actually_sweep imk_actually_sweep proc~imk_sweep->proc~imk_actually_sweep proc~call_hooks call_hooks proc~rk_step->proc~call_hooks proc~pf_residual pf_residual proc~rk_step->proc~pf_residual proc~mkrk_step->proc~call_hooks proc~mkrk_step->proc~pf_residual proc~imk_actually_sweep->proc~pf_residual proc~start_timer start_timer proc~imk_actually_sweep->proc~start_timer proc~end_timer end_timer proc~imk_actually_sweep->proc~end_timer proc~call_hooks->proc~start_timer proc~call_hooks->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imk_sweep Source Code subroutine imk_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level this % t0 = t0 this % dt = dt if ( this % rk ) then call rk_step ( this , pf , t0 , dt ) else if ( this % mkrk ) then call mkrk_step ( this , pf , t0 , dt ) else call imk_actually_sweep ( this , pf , level_index , t0 , dt , nsweeps ) end if end subroutine imk_sweep","tags":"","loc":"proc/imk_sweep.html","title":"imk_sweep – LibPFASST"},{"text":"public subroutine rk_step(this, pf, t0, dt) Uses pf_mod_timer pf_mod_hooks proc~~rk_step~~UsesGraph proc~rk_step rk_step module~pf_mod_hooks pf_mod_hooks proc~rk_step->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~rk_step->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size Calls proc~~rk_step~~CallsGraph proc~rk_step rk_step proc~call_hooks call_hooks proc~rk_step->proc~call_hooks proc~pf_residual pf_residual proc~rk_step->proc~pf_residual proc~start_timer start_timer proc~call_hooks->proc~start_timer proc~end_timer end_timer proc~call_hooks->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rk_step~~CalledByGraph proc~rk_step rk_step proc~imk_sweep imk_sweep proc~imk_sweep->proc~rk_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code rk_step Source Code subroutine rk_step ( this , pf , t0 , dt ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: m !!  Loop variables real ( pfdp ) :: t !!  Time at nodes t = t0 + dt lev => pf % levels ( 1 ) do m = 1 , 5 call lev % Q ( m )% setval ( 0.0_pfdp ) end do call call_hooks ( pf , 1 , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) ! commutator_p flags=1 hack copies Q(1)%y -> Q(1)%array ! all subsequent RK stages are done on Q(m)%array call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 1 ) call lev % Q ( 2 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) ! commutator_p flags=2 hack copies Q(m)%array -> Q(m)%y ! only the Q argument in this case matters ! in order to get solution back to qend call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 5 ), lev % Q ( 5 ), lev % F ( 1 , 1 ), flags = 2 ) call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) call call_hooks ( pf , 1 , PF_POST_SWEEP ) end subroutine rk_step","tags":"","loc":"proc/rk_step.html","title":"rk_step – LibPFASST"},{"text":"public subroutine mkrk_step(this, pf, t0, dt) Uses pf_mod_timer pf_mod_hooks proc~~mkrk_step~~UsesGraph proc~mkrk_step mkrk_step module~pf_mod_hooks pf_mod_hooks proc~mkrk_step->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~mkrk_step->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size Calls proc~~mkrk_step~~CallsGraph proc~mkrk_step mkrk_step proc~call_hooks call_hooks proc~mkrk_step->proc~call_hooks proc~pf_residual pf_residual proc~mkrk_step->proc~pf_residual proc~start_timer start_timer proc~call_hooks->proc~start_timer proc~end_timer end_timer proc~call_hooks->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mkrk_step~~CalledByGraph proc~mkrk_step mkrk_step proc~imk_sweep imk_sweep proc~imk_sweep->proc~mkrk_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code mkrk_step Source Code subroutine mkrk_step ( this , pf , t0 , dt ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: m !!  Loop variables real ( pfdp ) :: t !!  Time at nodes lev => pf % levels ( 1 ) t = t0 + dt do m = 1 , 5 call lev % Q ( m )% setval ( 0.0_pfdp ) end do call call_hooks ( pf , 1 , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) call this % dexpinv ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 2 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % dexpinv ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 3 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % dexpinv ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 4 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % dexpinv ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call this % propagate ( lev % q0 , lev % Q ( 5 )) call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) call call_hooks ( pf , 1 , PF_POST_SWEEP ) end subroutine mkrk_step","tags":"","loc":"proc/mkrk_step.html","title":"mkrk_step – LibPFASST"},{"text":"public subroutine imk_actually_sweep(this, pf, level_index, t0, dt, nsweeps) Uses pf_mod_timer pf_mod_hooks proc~~imk_actually_sweep~~UsesGraph proc~imk_actually_sweep imk_actually_sweep module~pf_mod_hooks pf_mod_hooks proc~imk_actually_sweep->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~imk_actually_sweep->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Assign level pointer Loop over sweeps Loop over substeps\n  Accumulate rhs\n  Add the tau term Compute explicit function on new value\n  End substep loop Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do Calls proc~~imk_actually_sweep~~CallsGraph proc~imk_actually_sweep imk_actually_sweep proc~pf_residual pf_residual proc~imk_actually_sweep->proc~pf_residual proc~start_timer start_timer proc~imk_actually_sweep->proc~start_timer proc~end_timer end_timer proc~imk_actually_sweep->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~imk_actually_sweep~~CalledByGraph proc~imk_actually_sweep imk_actually_sweep proc~imk_sweep imk_sweep proc~imk_sweep->proc~imk_actually_sweep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code imk_actually_sweep Source Code subroutine imk_actually_sweep ( this , pf , level_index , t0 , dt , nsweeps ) use pf_mod_timer use pf_mod_hooks !>  Inputs class ( pf_imk_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  PFASST structure integer , intent ( in ) :: level_index !!  which level to sweep on real ( pfdp ), intent ( in ) :: t0 !!  Time at beginning of time step real ( pfdp ), intent ( in ) :: dt !!  time step size integer , intent ( in ) :: nsweeps !!  number of sweeps to do !>  Local variables class ( pf_level_t ), pointer :: lev !!  points to current level integer :: m , n , k !!  Loop variables real ( pfdp ) :: t !!  Time at nodes lev => pf % levels ( level_index ) !!  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps !!  Loop over sweeps ! compute integrals and add fas correction do m = 1 , lev % nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp ) do n = 1 , lev % nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 )) end do if ( level_index < pf % nlevels ) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end if end do !  Recompute the first function value if this is first sweep if ( k . eq . 1 ) then call lev % Q ( 1 )% setval ( 0.0_pfdp ) ! likely an unnecessary setting of Omega=0 call this % evaluate ( lev , t0 , 1 ) end if t = t0 ! do the sub-stepping in sweep do m = 1 , lev % nnodes - 1 !!  Loop over substeps t = t + dt * this % dtsdc ( m ) !>  Accumulate rhs call lev % Q ( m + 1 )% setval ( 0.0_pfdp ) do n = 1 , m call lev % Q ( m + 1 )% axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 )) end do !>  Add the tau term call lev % Q ( m + 1 )% axpy ( 1.0_pfdp , lev % I ( m )) !>  Compute explicit function on new value call this % evaluate ( lev , t , m + 1 ) end do !!  End substep loop call pf_residual ( pf , lev , dt ) call lev % qend % copy ( lev % Q ( lev % nnodes ), flags = 1 ) end do !  End loop on sweeps call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine imk_actually_sweep","tags":"","loc":"proc/imk_actually_sweep.html","title":"imk_actually_sweep – LibPFASST"},{"text":"public subroutine imk_initialize(this, lev) Assign explicit approximate quadrature rule\n  Make space for temporary variables Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code imk_initialize Source Code subroutine imk_initialize ( this , lev ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev integer :: m , nnodes this % npieces = 1 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes ), this % QtilE ( nnodes - 1 , nnodes )) allocate ( this % dtsdc ( nnodes - 1 )) allocate ( this % tsdc ( nnodes )) this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) this % bernoullis = 0.0_pfdp this % bernoullis ( 1 ) = - 1.0_pfdp / 2.0_pfdp this % bernoullis ( 2 ) = 1.0_pfdp / 6.0_pfdp this % bernoullis ( 4 ) = - 1.0_pfdp / 3.0e1_pfdp this % bernoullis ( 6 ) = 1.0_pfdp / 4.2e1_pfdp this % bernoullis ( 8 ) = - 1.0_pfdp / 3.0e1_pfdp this % bernoullis ( 10 ) = 5.0_pfdp / 6.6e1_pfdp this % bernoullis ( 12 ) = - 69 1.0_pfdp / 2.73e3_pfdp this % bernoullis ( 14 ) = 7.0_pfdp / 6.0_pfdp this % bernoullis ( 16 ) = - 361 7.0_pfdp / 5.10e2_pfdp this % bernoullis ( 18 ) = 4386 7.0_pfdp / 7.98e2_pfdp this % bernoullis ( 20 ) = - 17461 1.0_pfdp / 33 0.0_pfdp !>  Assign explicit approximate quadrature rule this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE !>  Make space for temporary variables call lev % ulevel % factory % create_array ( this % A , nnodes , & lev % index , lev % shape ) do m = 1 , nnodes call this % A ( m )% setval ( 0.0_pfdp ) end do end subroutine imk_initialize","tags":"","loc":"proc/imk_initialize.html","title":"imk_initialize – LibPFASST"},{"text":"public subroutine imk_integrate(this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags Contents Source Code imk_integrate Source Code subroutine imk_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: j , m do m = 1 , lev % nnodes - 1 call fintSDC ( m )% setval ( 0.0_pfdp ) do j = 1 , lev % nnodes call fintSDC ( m )% axpy ( dt * lev % sdcmats % qmat ( m , j ), fSDC ( j , 1 )) end do end do end subroutine imk_integrate","tags":"","loc":"proc/imk_integrate.html","title":"imk_integrate – LibPFASST"},{"text":"public subroutine imk_evaluate(this, lev, t, m, flags, step) Uses pf_mod_dtype proc~~imk_evaluate~~UsesGraph proc~imk_evaluate imk_evaluate module~pf_mod_dtype pf_mod_dtype proc~imk_evaluate->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imk_evaluate Source Code subroutine imk_evaluate ( this , lev , t , m , flags , step ) use pf_mod_dtype class ( pf_imk_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev integer , optional , intent ( in ) :: flags , step integer :: i real ( pfdp ) :: dt !  Propagate to get y=exp(Om) !prop needs e&#94;{Q (omega)} and apply to Y if ( this % debug ) & print * , 'level' , lev % index , 'in evaluate ' , m , '------------------' if ( this % rk ) then ! 't' in f_evals are meaningless since i have a time-independent matrix, A dt = this % dt do i = 1 , 5 call lev % Q ( i )% setval ( 0.0_pfdp ) end do call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) call this % f_eval ( lev % Q ( 1 ), t , lev % index , this % A ( 1 )) ! commutator_p flags=1 hack copies Q(1)%y -> Q(1)%array ! all subsequent RK stages are done on Q(m)%array call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 1 ) call lev % Q ( 2 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 2 )% axpy ( 0.5_pfdp * dt , lev % F ( 1 , 1 )) call this % f_eval ( lev % Q ( 2 ), t , lev % index , this % A ( 2 )) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 2 , 1 )) call lev % Q ( 3 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 3 )% axpy ( 0.5_pfdp * dt , lev % F ( 2 , 1 )) call this % f_eval ( lev % Q ( 3 ), t , lev % index , this % A ( 3 )) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 3 , 1 )) call lev % Q ( 4 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 4 )% axpy ( dt , lev % F ( 3 , 1 )) call this % f_eval ( lev % Q ( 4 ), t , lev % index , this % A ( 4 )) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 4 , 1 )) call lev % Q ( 5 )% axpy ( 1.0_pfdp , lev % Q ( 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 1 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 2 , 1 )) call lev % Q ( 5 )% axpy ( dt / 3.0_pfdp , lev % F ( 3 , 1 )) call lev % Q ( 5 )% axpy ( dt / 6.0_pfdp , lev % F ( 4 , 1 )) ! commutator_p flags=2 hack copies Q(m)%array -> Q(m)%y ! only the Q argument in this case matters ! in order to get solution back to qend call this % commutator_p ( this % A ( 1 ), lev % Q ( 1 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 2 ), lev % Q ( 2 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 3 ), lev % Q ( 3 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 4 ), lev % Q ( 4 ), lev % F ( 1 , 1 ), flags = 2 ) call this % commutator_p ( this % A ( 5 ), lev % Q ( 5 ), lev % F ( 1 , 1 ), flags = 2 ) else if ( this % debug ) then endif if ( m > 1 ) then if ( this % debug ) print * , 'propagating' call this % propagate ( lev % q0 , lev % Q ( m )) else if ( this % debug ) print * , 'copying' call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) end if if ( this % debug ) print * , 'Q' if ( this % debug ) call lev % Q ( m )% eprint () !  Compute A(y,t) call this % f_eval ( lev % Q ( m ), t , lev % index , this % A ( m )) if ( this % debug ) print * , 'A' if ( this % debug ) call this % A ( m )% eprint () !  Compute the series expansion for dexpinv if ( m > 1 ) then call this % dexpinv ( this % A ( m ), lev % Q ( m ), lev % F ( m , 1 )) else call lev % F ( 1 , 1 )% copy ( this % A ( 1 )) endif if ( this % debug ) print * , 'depxinv' if ( this % debug ) call lev % F ( m , 1 )% eprint () endif if ( this % debug ) print * , 'end evaluate ------------' end subroutine imk_evaluate","tags":"","loc":"proc/imk_evaluate.html","title":"imk_evaluate – LibPFASST"},{"text":"public subroutine imk_evaluate_all(this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imk_evaluate_all Source Code subroutine imk_evaluate_all ( this , lev , t , flags , step ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step integer :: m if ( this % rk ) then call lev % ulevel % sweeper % evaluate ( lev , t ( 1 ), 1 ) else do m = 1 , lev % nnodes call lev % ulevel % sweeper % evaluate ( lev , t ( m ), m ) end do end if end subroutine imk_evaluate_all","tags":"","loc":"proc/imk_evaluate_all.html","title":"imk_evaluate_all – LibPFASST"},{"text":"public subroutine imk_residual(this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Contents Source Code imk_residual Source Code subroutine imk_residual ( this , lev , dt , flags ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m call lev % ulevel % sweeper % integrate ( lev , lev % Q , lev % F , dt , lev % I ) ! add tau (which is 'node to node') if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m )) end do end if ! subtract out Q  (not initial condition is zero do m = 1 , lev % nnodes - 1 call lev % R ( m )% copy ( lev % I ( m )) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do end subroutine imk_residual","tags":"","loc":"proc/imk_residual.html","title":"imk_residual – LibPFASST"},{"text":"public subroutine imk_spreadq0(this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code imk_spreadq0 Source Code subroutine imk_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer m , p !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , flags = 1 ) ! set initial omega to 0 call lev % Q ( 1 )% setval ( 0.0_pfdp ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , 1 ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), flags = 1 ) call lev % Q ( m )% copy ( lev % Q ( 1 )) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p )) end do end do end subroutine imk_spreadq0","tags":"","loc":"proc/imk_spreadq0.html","title":"imk_spreadq0 – LibPFASST"},{"text":"public subroutine imk_save(lev) Save function values so that difference can be computed Arguments Type Intent Optional Attributes Name class( pf_level_t ), intent(inout) :: lev Level to save on Contents Source Code imk_save Source Code subroutine imk_save ( lev ) class ( pf_level_t ), intent ( inout ) :: lev !!  Level to save on integer :: m do m = 1 , lev % nnodes call lev % pF ( m , 1 )% copy ( lev % F ( m , 1 )) end do end subroutine imk_save","tags":"","loc":"proc/imk_save.html","title":"imk_save – LibPFASST"},{"text":"public subroutine imk_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code imk_destroy Source Code subroutine imk_destroy ( this , lev ) class ( pf_imk_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QtilE , this % QdiffE ) deallocate ( this % dtsdc ) deallocate ( this % tsdc ) call lev % ulevel % factory % destroy_array ( this % A , lev % nnodes , & lev % index , lev % shape ) end subroutine imk_destroy","tags":"","loc":"proc/imk_destroy.html","title":"imk_destroy – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level, f) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer(kind=c_int), intent(in) :: level class( pf_encap_t ), intent(inout) :: f Description Subroutine f_eval computes A(y,t)","tags":"","loc":"interface/pf_f_eval_p~10.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_dexpinv_p(this, a, omega, f) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: f The resultign-level Description Subroutine dexpinv computes Om'=F=dexpinv_Om(A)","tags":"","loc":"interface/pf_dexpinv_p.html","title":"pf_dexpinv_p – LibPFASST"},{"text":"interface public subroutine pf_propagate_p(this, q0, q) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: q0 class( pf_encap_t ), intent(inout) :: q Description Subroutine propagate   computes y_m=expm(Om_m)y_0(expm(Om_m))-1 or (expm(Om_m))y_0 or","tags":"","loc":"interface/pf_propagate_p.html","title":"pf_propagate_p – LibPFASST"},{"text":"interface public subroutine pf_commutator_p(this, a, b, out, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: b class( pf_encap_t ), intent(inout) :: out integer, intent(in), optional :: flags","tags":"","loc":"interface/pf_commutator_p.html","title":"pf_commutator_p – LibPFASST"},{"text":"public subroutine magpicard_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks proc~~magpicard_sweep~~UsesGraph proc~magpicard_sweep magpicard_sweep module~pf_mod_hooks pf_mod_hooks proc~magpicard_sweep->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~magpicard_sweep->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. this loop not OMP'd because the deferred procs are OMP'd Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags Calls proc~~magpicard_sweep~~CallsGraph proc~magpicard_sweep magpicard_sweep proc~call_hooks call_hooks proc~magpicard_sweep->proc~call_hooks proc~start_timer start_timer proc~magpicard_sweep->proc~start_timer proc~pf_residual pf_residual proc~magpicard_sweep->proc~pf_residual proc~magpicard_integrate magpicard_integrate proc~magpicard_sweep->proc~magpicard_integrate proc~end_timer end_timer proc~magpicard_sweep->proc~end_timer proc~call_hooks->proc~start_timer proc~call_hooks->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code magpicard_sweep Source Code subroutine magpicard_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_magpicard_t ), intent ( inout ) :: this type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: dt , t0 integer , intent ( in ) :: level_index integer , intent ( in ) :: nsweeps integer , optional , intent ( in ) :: flags class ( pf_level_t ), pointer :: lev integer :: m , nnodes , k real ( pfdp ) :: t lev => pf % levels ( level_index ) nnodes = lev % nnodes call call_hooks ( pf , level_index , PF_PRE_SWEEP ) call lev % Q ( 1 )% copy ( lev % q0 ) call start_timer ( pf , TLEVEL + lev % index - 1 ) do k = 1 , nsweeps ! Copy values into residual do m = 1 , nnodes - 1 call lev % R ( m )% copy ( lev % Q ( m + 1 )) end do t = t0 !$omp parallel do private(m, t) do m = 1 , nnodes !          t = t + dt*this%dtsdc(m) t = t0 + dt * lev % nodes ( m ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end do !$omp end parallel do !$omp barrier call magpicard_integrate ( this , lev , lev % Q , lev % F , dt , lev % I ) if ( this % magnus_order > 1 . and . nnodes > 2 ) then call start_timer ( pf , TAUX ) call this % compute_single_commutators ( lev % F ) call end_timer ( pf , TAUX ) endif !! this loop not OMP'd because the deferred procs are OMP'd do m = 1 , nnodes - 1 call start_timer ( pf , TAUX + 1 ) call this % compute_omega ( this % omega ( m ), lev % I , lev % F , & lev % nodes , lev % sdcmats % qmat , dt , m , this % commutator_coefs (:,:, m )) call end_timer ( pf , TAUX + 1 ) end do !$omp parallel do private(m) do m = 1 , nnodes - 1 call this % propagate_solution ( lev % Q ( 1 ), lev % Q ( m + 1 ), this % omega ( m ), lev % index ) end do !$omp end parallel do call pf_residual ( pf , lev , dt ) call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! Loop over sweeps call lev % qend % copy ( lev % Q ( nnodes )) call end_timer ( pf , TLEVEL + lev % index - 1 ) end subroutine magpicard_sweep","tags":"","loc":"proc/magpicard_sweep.html","title":"magpicard_sweep – LibPFASST"},{"text":"public subroutine magpicard_initialize(this, lev) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Calls proc~~magpicard_initialize~~CallsGraph proc~magpicard_initialize magpicard_initialize proc~get_commutator_coefs get_commutator_coefs proc~magpicard_initialize->proc~get_commutator_coefs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code magpicard_initialize Source Code subroutine magpicard_initialize ( this , lev ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev integer :: m , nnodes this % commutator_coefs = 0.0_pfdp this % npieces = 1 nnodes = lev % nnodes allocate ( this % dtsdc ( nnodes - 1 )) this % dtsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) !  SDC time step size (unscaled) call get_commutator_coefs ( this % qtype , nnodes , this % dt , this % commutator_coefs ) call lev % ulevel % factory % create_array ( this % omega , nnodes - 1 , & lev % index , lev % shape ) call lev % ulevel % factory % create_array ( this % time_ev_op , nnodes - 1 , & lev % index , lev % shape ) do m = 1 , nnodes - 1 call this % omega ( m )% setval ( 0.0_pfdp ) call this % time_ev_op ( m )% setval ( 0.0_pfdp ) end do end subroutine magpicard_initialize","tags":"","loc":"proc/magpicard_initialize.html","title":"magpicard_initialize – LibPFASST"},{"text":"public subroutine magpicard_integrate(this, lev, qSDC, fSDC, dt, fintSDC, flags) Compute SDC integral\n  fintSDC = \\int_{t_n}&#94;{t_m} fSDC dt Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags Called by proc~~magpicard_integrate~~CalledByGraph proc~magpicard_integrate magpicard_integrate proc~magpicard_sweep magpicard_sweep proc~magpicard_sweep->proc~magpicard_integrate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code magpicard_integrate Source Code subroutine magpicard_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: j , m do m = 1 , lev % nnodes - 1 call fintSDC ( m )% setval ( 0.0_pfdp ) do j = 1 , lev % nnodes call fintSDC ( m )% axpy ( dt * lev % sdcmats % qmat ( m , j ), fSDC ( j , 1 )) end do end do end subroutine magpicard_integrate","tags":"","loc":"proc/magpicard_integrate.html","title":"magpicard_integrate – LibPFASST"},{"text":"public subroutine magpicard_evaluate(this, lev, t, m, flags, step) Uses pf_mod_dtype proc~~magpicard_evaluate~~UsesGraph proc~magpicard_evaluate magpicard_evaluate module~pf_mod_dtype pf_mod_dtype proc~magpicard_evaluate->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code magpicard_evaluate Source Code subroutine magpicard_evaluate ( this , lev , t , m , flags , step ) use pf_mod_dtype class ( pf_magpicard_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev integer , optional , intent ( in ) :: flags , step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 )) end subroutine magpicard_evaluate","tags":"","loc":"proc/magpicard_evaluate.html","title":"magpicard_evaluate – LibPFASST"},{"text":"public subroutine magpicard_evaluate_all(this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~magpicard_evaluate_all~~CallsGraph proc~magpicard_evaluate_all magpicard_evaluate_all proc~pf_generic_evaluate_all pf_generic_evaluate_all proc~magpicard_evaluate_all->proc~pf_generic_evaluate_all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code magpicard_evaluate_all Source Code subroutine magpicard_evaluate_all ( this , lev , t , flags , step ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , optional , intent ( in ) :: flags , step call pf_generic_evaluate_all ( this , lev , t ) end subroutine magpicard_evaluate_all","tags":"","loc":"proc/magpicard_evaluate_all.html","title":"magpicard_evaluate_all – LibPFASST"},{"text":"public subroutine magpicard_residual(this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Contents Source Code magpicard_residual Source Code subroutine magpicard_residual ( this , lev , dt , flags ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m do m = 1 , lev % nnodes - 1 call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 )) end do lev % residual = lev % R ( lev % nnodes - 1 )% norm () end subroutine magpicard_residual","tags":"","loc":"proc/magpicard_residual.html","title":"magpicard_residual – LibPFASST"},{"text":"public subroutine magpicard_spreadq0(this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~magpicard_spreadq0~~CallsGraph proc~magpicard_spreadq0 magpicard_spreadq0 proc~pf_generic_spreadq0 pf_generic_spreadq0 proc~magpicard_spreadq0->proc~pf_generic_spreadq0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code magpicard_spreadq0 Source Code subroutine magpicard_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step call pf_generic_spreadq0 ( this , lev , t0 ) end subroutine magpicard_spreadq0","tags":"","loc":"proc/magpicard_spreadq0.html","title":"magpicard_spreadq0 – LibPFASST"},{"text":"public subroutine magpicard_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code magpicard_destroy Source Code subroutine magpicard_destroy ( this , lev ) class ( pf_magpicard_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % dtsdc , this % commutators ) call lev % ulevel % factory % destroy_array ( this % omega , lev % nnodes - 1 , & lev % index , lev % shape ) call lev % ulevel % factory % destroy_array ( this % time_ev_op , lev % nnodes - 1 , & lev % index , lev % shape ) end subroutine magpicard_destroy","tags":"","loc":"proc/magpicard_destroy.html","title":"magpicard_destroy – LibPFASST"},{"text":"public subroutine get_commutator_coefs(qtype, nnodes, dt, coefs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: qtype integer, intent(in) :: nnodes real(kind=pfdp), intent(in) :: dt real(kind=pfdp), intent(inout) :: coefs (:,:,:) Called by proc~~get_commutator_coefs~~CalledByGraph proc~get_commutator_coefs get_commutator_coefs proc~magpicard_initialize magpicard_initialize proc~magpicard_initialize->proc~get_commutator_coefs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_commutator_coefs Source Code subroutine get_commutator_coefs ( qtype , nnodes , dt , coefs ) integer , intent ( in ) :: qtype , nnodes real ( pfdp ), intent ( in ) :: dt real ( pfdp ), intent ( inout ) :: coefs (:,:,:) ! coefs has the structure coefs(coefs, magnus_order, node) ! for a given node, pass subroutines the coefs for a magnus order, then ! loop over coefs if ( qtype == 1 ) then ! we're talking Lobatto nodes, where nnodes=3 includes, t0, t_1/2, tn ! need some way to differentiate whether you want full collocation or not ! coefs(1:3, 1, 1) = dt**2 * [real(8)::11/480., -1/480., 1/480.] ! coefs(1:3, 1, 2) = dt**2 * [real(8)::1/15., 1/60., 1/15.] coefs ( 1 , 1 , 1 ) = - 1 / 4 8.d0 * dt ** 2 coefs ( 2 , 1 , 2 ) = - 1 / 1 2.d0 * dt ** 2 elseif ( qtype == 5 ) then coefs ( 1 : 3 , 1 , 1 ) = 1.d-3 * [ real ( 8 ) :: - 0.708256232441739d0 , 0.201427439334681d0 , - 0.002608155816283d0 ] coefs ( 1 : 3 , 1 , 2 ) = [ real ( 8 ) :: - 0.035291589565775d0 , 0.004482619613666d0 , - 0.000569367343553d0 ] coefs ( 1 : 3 , 1 , 3 ) = [ real ( 8 ) :: - 0.078891497044705d0 , - 0.018131905893999d0 , - 0.035152700676886d0 ] coefs ( 1 : 3 , 1 , 4 ) = [ real ( 8 ) :: - 0.071721913818656d0 , - 0.035860956909328d0 , - 0.071721913818656d0 ] coefs (:, 1 ,:) = dt ** 2 * coefs (:, 1 ,:) coefs (:, 2 , 1 ) = & [ real ( 8 ) :: 1.466782892818107d-6 , - 2.546845448743404d-6 , 7.18855795894042d-7 , & - 3.065370250683271d-7 , 6.962336322868984d-7 , - 1.96845581200288d-7 , & - 2.262216360714434d-8 , - 2.72797194008496d-9 , 8.54843541920492d-10 ] coefs (:, 2 , 2 ) = & [ real ( 8 ) :: 0.001040114336531742d0 , - 0.001714330280871491d0 , 0.0001980882752518163d0 , & - 0.00006910549596945875d0 , 0.0002905401601450182d0 , - 0.00003465884693947625d0 , & 0.0000924518848932026d0 , 0.0000125950571649574d0 , - 2.4709074423913880d-6 ] coefs (:, 2 , 3 ) = & [ real ( 8 ) :: 0.004148295975360902d0 , - 0.006387421893168941d0 , - 0.003594231910817328d0 , & 0.000997378110327084d0 , 0.0001241530237557625d0 , - 0.0003805975423160699d0 , & 0.003718384934573079d0 , 0.001693514295056844d0 , - 0.001060408584538103d0 ] coefs (:, 2 , 4 ) = & [ real ( 8 ) :: 0.003453850676072909d0 , - 0.005584950029394391d0 , - 0.007128159905937654d0 , & 0.001653439153439147d0 , 0.0d0 , - 0.001653439153439143d0 , & 0.007128159905937675d0 , 0.005584950029394475d0 , - 0.003453850676072897d0 ] coefs (:, 2 ,:) = dt ** 3 * coefs (:, 2 ,:) coefs ( 1 , 3 , 4 ) = dt ** 4 / 6 0.d0 else stop 'oh no! unsupported qtype' endif end subroutine get_commutator_coefs","tags":"","loc":"proc/get_commutator_coefs.html","title":"get_commutator_coefs – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level, f) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f","tags":"","loc":"interface/pf_f_eval_p~11.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_compute_single_commutators_p(this, f) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: f (:,:)","tags":"","loc":"interface/pf_compute_single_commutators_p.html","title":"pf_compute_single_commutators_p – LibPFASST"},{"text":"interface public subroutine pf_compute_omega_p(this, omega, integrals, f, nodes, qmat, dt, this_node, coefs) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: integrals (:) class( pf_encap_t ), intent(inout) :: f (:,:) real(kind=pfdp), intent(in) :: nodes (:) real(kind=pfdp), intent(in) :: qmat (:,:) real(kind=pfdp), intent(in) :: dt integer, intent(in) :: this_node real(kind=pfdp), intent(in) :: coefs (:,:)","tags":"","loc":"interface/pf_compute_omega_p.html","title":"pf_compute_omega_p – LibPFASST"},{"text":"interface public subroutine pf_propagate_solution_p(this, sol_t0, sol_tn, omega, level) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: sol_t0 class( pf_encap_t ), intent(inout) :: sol_tn class( pf_encap_t ), intent(inout) :: omega integer, intent(in) :: level","tags":"","loc":"interface/pf_propagate_solution_p.html","title":"pf_propagate_solution_p – LibPFASST"},{"text":"interface public subroutine pf_destroy_magpicard_p(this, Lev) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev","tags":"","loc":"interface/pf_destroy_magpicard_p.html","title":"pf_destroy_magpicard_p – LibPFASST"},{"text":"public subroutine pf_pfasst_run(pf, q0, dt, tend, nsteps, qend, flags) This is the main interface to pfasst.\n  It examines the parameters and decides which subroutine to call\n  to execute the code correctly\n  Set the number of time steps to do\n  The user can either pass in the number of time steps or\n  pass in the time step size and length of run\n  Allocate stuff for holding results Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf The complete PFASST structure class( pf_encap_t ), intent(inout) :: q0 The initial condition real(kind=pfdp), intent(in) :: dt The time step for each processor real(kind=pfdp), intent(in) :: tend The final time of run integer, intent(in), optional :: nsteps The number of time steps class( pf_encap_t ), intent(inout), optional :: qend The computed solution at tend integer, intent(in), optional :: flags (:) User defnined flags Calls proc~~pf_pfasst_run~~CallsGraph proc~pf_pfasst_run pf_pfasst_run proc~pf_block_run pf_block_run proc~pf_pfasst_run->proc~pf_block_run proc~pf_initialize_results pf_initialize_results proc~pf_pfasst_run->proc~pf_initialize_results proc~pf_dump_results pf_dump_results proc~pf_pfasst_run->proc~pf_dump_results proc~pf_check_convergence_block pf_check_convergence_block proc~pf_block_run->proc~pf_check_convergence_block proc~pf_v_cycle pf_v_cycle proc~pf_block_run->proc~pf_v_cycle proc~pf_predictor pf_predictor proc~pf_block_run->proc~pf_predictor proc~end_timer end_timer proc~pf_block_run->proc~end_timer proc~pf_broadcast pf_broadcast proc~pf_block_run->proc~pf_broadcast proc~call_hooks call_hooks proc~pf_block_run->proc~call_hooks proc~start_timer start_timer proc~pf_block_run->proc~start_timer proc~initialize_results initialize_results proc~pf_initialize_results->proc~initialize_results proc~dump_results dump_results proc~pf_dump_results->proc~dump_results proc~dump_timings dump_timings proc~pf_dump_results->proc~dump_timings proc~pf_check_convergence_block->proc~call_hooks proc~pf_check_residual pf_check_residual proc~pf_check_convergence_block->proc~pf_check_residual proc~pf_send_status pf_send_status proc~pf_check_convergence_block->proc~pf_send_status proc~restrict_time_space_fas restrict_time_space_fas proc~pf_v_cycle->proc~restrict_time_space_fas proc~pf_post pf_post proc~pf_v_cycle->proc~pf_post proc~pf_residual pf_residual proc~pf_v_cycle->proc~pf_residual proc~interpolate_time_space interpolate_time_space proc~pf_v_cycle->proc~interpolate_time_space proc~pf_send pf_send proc~pf_v_cycle->proc~pf_send proc~interpolate_q0 interpolate_q0 proc~pf_v_cycle->proc~interpolate_q0 proc~pf_recv pf_recv proc~pf_v_cycle->proc~pf_recv proc~pf_predictor->proc~end_timer proc~pf_predictor->proc~call_hooks proc~pf_predictor->proc~start_timer proc~pf_predictor->proc~restrict_time_space_fas proc~pf_predictor->proc~pf_residual proc~pf_predictor->proc~interpolate_time_space proc~pf_predictor->proc~pf_send proc~pf_predictor->proc~interpolate_q0 proc~pf_predictor->proc~pf_recv mpi_wtime mpi_wtime proc~end_timer->mpi_wtime end_timer end_timer proc~pf_broadcast->end_timer start_timer start_timer proc~pf_broadcast->start_timer proc~call_hooks->proc~end_timer proc~call_hooks->proc~start_timer proc~start_timer->mpi_wtime timer_names timer_names proc~dump_timings->timer_names proc~restrict_time_space_fas->proc~end_timer proc~restrict_time_space_fas->proc~call_hooks proc~restrict_time_space_fas->proc~start_timer proc~restrict_sdc restrict_sdc proc~restrict_time_space_fas->proc~restrict_sdc proc~pf_residual->proc~end_timer proc~pf_residual->proc~start_timer proc~interpolate_time_space->proc~end_timer proc~interpolate_time_space->proc~call_hooks proc~interpolate_time_space->proc~start_timer proc~pf_apply_mat pf_apply_mat proc~interpolate_time_space->proc~pf_apply_mat proc~pf_send->end_timer proc~pf_send->start_timer proc~interpolate_q0->proc~end_timer proc~interpolate_q0->proc~call_hooks proc~interpolate_q0->proc~start_timer proc~pf_recv->end_timer proc~pf_recv->start_timer proc~restrict_sdc->proc~pf_apply_mat var panprocpf_pfasst_runCallsGraph = svgPanZoom('#procpf_pfasst_runCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_pfasst_run Source Code subroutine pf_pfasst_run ( pf , q0 , dt , tend , nsteps , qend , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !!  The complete PFASST structure class ( pf_encap_t ), intent ( inout ) :: q0 !!  The initial condition real ( pfdp ), intent ( in ) :: dt !!  The time step for each processor real ( pfdp ), intent ( in ) :: tend !!  The final time of run integer , intent ( in ), optional :: nsteps !!  The number of time steps class ( pf_encap_t ), intent ( inout ), optional :: qend !!  The computed solution at tend integer , intent ( in ), optional :: flags (:) !!  User defnined flags !  Local variables integer :: nproc !!  Total number of processors integer :: nsteps_loc !!  local number of time steps real ( pfdp ) :: tend_loc !!  The final time of run ! make a local copy of nproc nproc = pf % comm % nproc !>  Set the number of time steps to do !!  The user can either pass in the number of time steps or !!  pass in the time step size and length of run if ( present ( nsteps )) then nsteps_loc = nsteps tend_loc = dble ( nsteps_loc * dt ) else nsteps_loc = ceiling ( tend / dt ) !  Do  sanity check on steps if ( abs ( real ( nsteps_loc , pfdp ) - tend / dt ) > dt / 10 0.0 ) then print * , 'dt=' , dt print * , 'nsteps=' , nsteps_loc print * , 'tend=' , tend stop \"Invalid nsteps\" end if end if pf % state % nsteps = nsteps_loc !>  Allocate stuff for holding results call pf_initialize_results ( pf ) !  do sanity checks on Nproc if ( mod ( nsteps , nproc ) > 0 ) stop \"ERROR: nsteps must be multiple of nproc (pf_parallel.f90).\" if ( present ( qend )) then call pf_block_run ( pf , q0 , dt , nsteps_loc , qend = qend , flags = flags ) else call pf_block_run ( pf , q0 , dt , nsteps_loc , flags = flags ) end if call pf_dump_results ( pf ) !  What we would like to do is check for !  1.  nlevels==1  and nprocs ==1 -> Serial SDC !      Predictor is either spreadQ or nothing !      Then we just call a loop on sweeps !      Communication is copy !  2.  nlevels > 1  and nprocs ==1 -> Serial MLSDC !      Predictor is needed to populate levels (or nothing) !      Then we just call a loop on MLSDC sweeps !      Communication is copy !  3.  nlevels == 1  and nprocs > 1 -> Pipelined SDC !      Predictor is just like PFASST, but on finest (only) level (or nothing) !  4.  nlevels > 1  and nprocs > 1 -> PFASST end subroutine pf_pfasst_run","tags":"","loc":"proc/pf_pfasst_run.html","title":"pf_pfasst_run – LibPFASST"},{"text":"public subroutine pf_predictor(pf, t0, dt, flags) PFASST Predictor.\n  Subroutine  to initialize the solution on each processor\n  The goal is to have a solution at each level and each node set to a consistent value\n  When this is called, the value of q0 at the fine level on each processor has been set somehow (see q0_style below) This can be broken down into four substeps\n 1. Get the  initial condition on the finest level at each node\n 2. Coarsen the initial condition to each coarser level with tau corrections\n 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent\n    (this is skipped if the fine initial conditions are already consistent)\n 4. Do some coarse grid sweeps to improve initial solutions on coarsest nodes\n 5. Interpolating coarse correction back to finer levels sweeping along the way. There are several parameters or flags that determine how things are done:\n  integer  q0_style:    can take 3 values\n           0:  Only the q0 at t=0 is valid  (default)\n           1:  The q0 at each processor is valid\n           2:  q0 and all nodes at each processor is valid\n logical  PFASST_pred:  If true, the burn-in step uses the \"PFASST predictor\" trick\n integer  nsweeps_burn: Determines how many sweeps are done on the coarse level during burn in\n integer  nsweeps_pred: Determines how many sweeps are done at the coarse level after burn in\n logical Pipeline_burn: True if coarse sweeps during burn in are pipelined  (meaningless if nsweeps_burn>1 on coarse level)\n logical Pipeline_pred: True if coarse sweeps after burn in are pipelined  (meaningless if nsweeps_pred>1 on coarse level)\n    Pipeline variables do nothing if there is only one processor\n logical  RK_pred:      If true, the coarse level is initialized with Runge-Kutta instead of the  PFASST burn in.\n                        We  will still do coarse sweeps after and correct finer levels The user defined flags(:) parameter is used to determine whether we are in a (standard) forward-in-time run (flags(1) == 1)\n or backward-in-time (for the adjoint) with a given terminal condition qend instead of initial condition q0  (flags(1) == 2).\n In the latter case, e.g., sweeper%spreadq0 has to do the correct thing (i.e., spread qend instead of q0). No time communication is performed during the predictor since all\n procesors can do the work themselves The iteration count is reset to 0, and the status is reset to\n  ITERATING. Step 1. Getting the  initial condition on the finest level at each processor\n         If we are doing multiple levels, then we need to coarsen to fine level Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction Step 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent\n         (this is skipped if the fine initial conditions are already consistent)\n The first processor does nothing, the second does one set of sweeps, the third two, etc\n Hence, this is skipped completely if nprocs=1\n If RK_pred is true, just do some RK_steps Step 4: Now we have everyone burned in, so do some coarse sweeps Step 5:  Return to fine level sweeping on any level in between coarsest and finest Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf PFASST main data structure real(kind=pfdp), intent(in) :: t0 Initial time of this processor real(kind=pfdp), intent(in) :: dt time step integer, intent(in), optional :: flags (:) User defined flags Calls proc~~pf_predictor~~CallsGraph proc~pf_predictor pf_predictor proc~end_timer end_timer proc~pf_predictor->proc~end_timer proc~restrict_time_space_fas restrict_time_space_fas proc~pf_predictor->proc~restrict_time_space_fas proc~pf_residual pf_residual proc~pf_predictor->proc~pf_residual proc~pf_send pf_send proc~pf_predictor->proc~pf_send proc~interpolate_q0 interpolate_q0 proc~pf_predictor->proc~interpolate_q0 proc~call_hooks call_hooks proc~pf_predictor->proc~call_hooks proc~pf_recv pf_recv proc~pf_predictor->proc~pf_recv proc~start_timer start_timer proc~pf_predictor->proc~start_timer proc~interpolate_time_space interpolate_time_space proc~pf_predictor->proc~interpolate_time_space mpi_wtime mpi_wtime proc~end_timer->mpi_wtime proc~restrict_time_space_fas->proc~end_timer proc~restrict_time_space_fas->proc~call_hooks proc~restrict_time_space_fas->proc~start_timer proc~restrict_sdc restrict_sdc proc~restrict_time_space_fas->proc~restrict_sdc proc~pf_residual->proc~end_timer proc~pf_residual->proc~start_timer start_timer start_timer proc~pf_send->start_timer end_timer end_timer proc~pf_send->end_timer proc~interpolate_q0->proc~end_timer proc~interpolate_q0->proc~call_hooks proc~interpolate_q0->proc~start_timer proc~call_hooks->proc~end_timer proc~call_hooks->proc~start_timer proc~pf_recv->start_timer proc~pf_recv->end_timer proc~start_timer->mpi_wtime proc~interpolate_time_space->proc~end_timer proc~interpolate_time_space->proc~call_hooks proc~interpolate_time_space->proc~start_timer proc~pf_apply_mat pf_apply_mat proc~interpolate_time_space->proc~pf_apply_mat proc~restrict_sdc->proc~pf_apply_mat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_predictor~~CalledByGraph proc~pf_predictor pf_predictor proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_predictor proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_predictor Source Code subroutine pf_predictor ( pf , t0 , dt , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf !! PFASST main data structure real ( pfdp ), intent ( in ) :: t0 !! Initial time of this processor real ( pfdp ), intent ( in ) :: dt !! time step integer , intent ( in ), optional :: flags (:) !!  User defined flags class ( pf_level_t ), pointer :: c_lev_p class ( pf_level_t ), pointer :: f_lev_p !! integer :: k !!  Loop indices integer :: level_index !!  Local variable for looping over levels real ( pfdp ) :: t0k !!  Initial time at time step k call call_hooks ( pf , 1 , PF_PRE_PREDICTOR ) call start_timer ( pf , TPREDICTOR ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'beginning predictor' !! !! Step 1. Getting the  initial condition on the finest level at each processor !!         If we are doing multiple levels, then we need to coarsen to fine level f_lev_p => pf % levels ( pf % nlevels ) if ( pf % q0_style < 2 ) then !  Spread q0 to all the nodes call f_lev_p % ulevel % sweeper % spreadq0 ( f_lev_p , t0 ) endif !! !!  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do coarsen  in predictor' if ( pf % nlevels > 1 ) then do level_index = pf % nlevels , 2 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call pf_residual ( pf , f_lev_p , dt ) call f_lev_p % ulevel % restrict ( f_lev_p , c_lev_p , f_lev_p % q0 , c_lev_p % q0 , t0 ) call restrict_time_space_fas ( pf , t0 , dt , level_index ) !  Restrict call save ( c_lev_p ) end do !  level_index = pf%nlevels, 2, -1 else level_index = 1 c_lev_p => pf % levels ( 1 ) end if !! !! Step 3. Do the \"Burn in\" step on the coarse level to make the coarse values consistent !!         (this is skipped if the fine initial conditions are already consistent) !! The first processor does nothing, the second does one set of sweeps, the third two, etc !! Hence, this is skipped completely if nprocs=1 if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do burnin  in predictor' if ( pf % q0_style . eq . 0 ) then !  The coarse level needs burn in !! If RK_pred is true, just do some RK_steps if ( pf % RK_pred ) then !  Use Runge-Kutta to get the coarse initial data !  Get new initial conditions call pf_recv ( pf , c_lev_p , 100000 + pf % rank , . true .) !  Do a RK_step call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 ) !  Send forward call pf_send ( pf , c_lev_p , 100000 + pf % rank + 1 , . false .) else !  Normal PFASST burn in level_index = 1 c_lev_p => pf % levels ( level_index ) do k = 1 , pf % rank + 1 pf % state % iter = - k t0k = t0 - ( pf % rank ) * dt + ( k - 1 ) * dt ! Remember t0=pf%rank*dt is the beginning of this time slice so t0-(pf%rank)*dt is 0 ! and we iterate up to the correct time step. ! for optimal control problem t, t0k has no influence on f_eval, so there this does something else ! Get new initial value (skip on first iteration) if ( k > 1 ) then call c_lev_p % q0 % copy ( c_lev_p % qend , flags = 0 ) ! If we are doing PFASST_pred, we use the old values at nodes, otherwise spread q0 if (. not . pf % PFASST_pred ) then call c_lev_p % ulevel % sweeper % spreadq0 ( c_lev_p , t0k ) end if end if !  Do some sweeps call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0k , dt , pf % nsweeps_burn ) end do endif !  RK_pred end if ! (q0_style .eq. 0) !! !! Step 4: Now we have everyone burned in, so do some coarse sweeps if ( pf % nlevels > 1 ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'do sweeps  in predictor' , 'Pipeline_pred' , pf % Pipeline_pred pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING if ( pf % Pipeline_pred ) then do k = 1 , c_lev_p % nsweeps_pred pf % state % iter =- ( pf % rank + 1 ) - k !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + k , . true .) !  Do a sweep call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 ) !  Send forward call pf_send ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + 1 + k , . false .) end do ! k = 1, c_lev_p%nsweeps_pred-1 else !  Don't pipeline !  Get new initial conditions call pf_recv ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank , . true .) !  Do a sweeps call c_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , c_lev_p % nsweeps_pred ) !  Send forward call pf_send ( pf , c_lev_p , c_lev_p % index * 110000 + pf % rank + 1 , . false .) endif ! (Pipeline_pred .eq. .true) then end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'returning to fine level in predictor' !! !!  Step 5:  Return to fine level sweeping on any level in between coarsest and finest do level_index = 2 , pf % nlevels !  Will do nothing with one level f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp ) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 0 ) call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 0 ) !  Do a sweep on level unless we are at the finest level if ( level_index < pf % nlevels ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps_pred ) end if end do call end_timer ( pf , TPREDICTOR ) call call_hooks ( pf , - 1 , PF_POST_PREDICTOR ) pf % state % iter = 0 pf % state % status = PF_STATUS_ITERATING pf % state % pstatus = PF_STATUS_ITERATING if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ending predictor' end subroutine pf_predictor","tags":"","loc":"proc/pf_predictor.html","title":"pf_predictor – LibPFASST"},{"text":"public subroutine pf_check_residual(pf, residual_converged) Subroutine to test residuals to determine if the current processor has converged. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf logical, intent(out) :: residual_converged Return true if residual is below tolerances Called by proc~~pf_check_residual~~CalledByGraph proc~pf_check_residual pf_check_residual proc~pf_check_convergence_block pf_check_convergence_block proc~pf_check_convergence_block->proc~pf_check_residual proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_check_convergence_block proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_check_residual Source Code subroutine pf_check_residual ( pf , residual_converged ) type ( pf_pfasst_t ), intent ( inout ) :: pf logical , intent ( out ) :: residual_converged !! Return true if residual is below tolerances residual_converged = . false . ! Check to see if relative tolerance is met if ( pf % levels ( pf % nlevels )% residual_rel < pf % rel_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , ' residual relative tol met' , pf % levels ( pf % nlevels )% residual_rel residual_converged = . true . end if ! Check to see if relative tolerance is met if ( pf % levels ( pf % nlevels )% residual < pf % abs_res_tol ) then if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'residual tol met' , pf % levels ( pf % nlevels )% residual residual_converged = . true . end if end subroutine pf_check_residual","tags":"","loc":"proc/pf_check_residual.html","title":"pf_check_residual – LibPFASST"},{"text":"public subroutine pf_check_convergence_block(pf, send_tag) Subroutine to check if the current processor has converged and\n to update the next processor on the status\n Note that if the previous processor hasn't converged yet\n (pstatus), the current processor can't be converged yet either\n Check to see if tolerances are met Until I hear the previous processor is done, recieve it's status Check to see if I am converged\n Assign status and send it forward Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: send_tag identifier for status send and receive Calls proc~~pf_check_convergence_block~~CallsGraph proc~pf_check_convergence_block pf_check_convergence_block proc~call_hooks call_hooks proc~pf_check_convergence_block->proc~call_hooks proc~pf_check_residual pf_check_residual proc~pf_check_convergence_block->proc~pf_check_residual proc~pf_send_status pf_send_status proc~pf_check_convergence_block->proc~pf_send_status proc~start_timer start_timer proc~call_hooks->proc~start_timer proc~end_timer end_timer proc~call_hooks->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_check_convergence_block~~CalledByGraph proc~pf_check_convergence_block pf_check_convergence_block proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_check_convergence_block proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_check_convergence_block Source Code subroutine pf_check_convergence_block ( pf , send_tag ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: send_tag !! identifier for status send and receive logical :: residual_converged , converged ! Shortcut for fixed iteration mode if ( pf % abs_res_tol == 0 . and . pf % rel_res_tol == 0 ) then pf % state % pstatus = PF_STATUS_ITERATING pf % state % status = PF_STATUS_ITERATING return end if call call_hooks ( pf , 1 , PF_PRE_CONVERGENCE ) !> Check to see if tolerances are met call pf_check_residual ( pf , residual_converged ) !>  Until I hear the previous processor is done, recieve it's status if ( pf % state % pstatus /= PF_STATUS_CONVERGED ) call pf_recv_status ( pf , send_tag ) !>  Check to see if I am converged converged = . false . if ( residual_converged ) then if ( pf % rank == 0 ) then converged = . true . else !  I am not the first processor, so I need to check the previous one if ( pf % state % pstatus == PF_STATUS_CONVERGED ) converged = . true . end if end if ! (residual_converged) !> Assign status and send it forward if ( converged ) then if ( pf % state % status == PF_STATUS_ITERATING ) then !  If I am converged for the first time !  then flip my flag and send the last status update pf % state % status = PF_STATUS_CONVERGED call pf_send_status ( pf , send_tag ) end if else !  I am not converged, send the news pf % state % status = PF_STATUS_ITERATING call pf_send_status ( pf , send_tag ) end if call call_hooks ( pf , 1 , PF_POST_CONVERGENCE ) end subroutine pf_check_convergence_block","tags":"","loc":"proc/pf_check_convergence_block.html","title":"pf_check_convergence_block – LibPFASST"},{"text":"public subroutine pf_block_run(pf, q0, dt, nsteps, qend, flags) PFASST controller for block mode\n  When starting a new block, broadcast new initial conditions to all procs\n  For initial block, this is done when initial conditions are set\n Reset some flags\n  Pack away your last solution\n  Everyone resets their q0\n  Just stick qend in q0\n  Update the step and t0 variables for new block\n Call the predictor to get an initial guess on all levels and all processors Start the loops over SDC sweeps Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf class( pf_encap_t ), intent(in) :: q0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsteps class( pf_encap_t ), intent(inout), optional :: qend integer, intent(in), optional :: flags (:) Calls proc~~pf_block_run~~CallsGraph proc~pf_block_run pf_block_run proc~pf_check_convergence_block pf_check_convergence_block proc~pf_block_run->proc~pf_check_convergence_block proc~pf_v_cycle pf_v_cycle proc~pf_block_run->proc~pf_v_cycle proc~pf_predictor pf_predictor proc~pf_block_run->proc~pf_predictor proc~end_timer end_timer proc~pf_block_run->proc~end_timer proc~pf_broadcast pf_broadcast proc~pf_block_run->proc~pf_broadcast proc~call_hooks call_hooks proc~pf_block_run->proc~call_hooks proc~start_timer start_timer proc~pf_block_run->proc~start_timer proc~pf_check_convergence_block->proc~call_hooks proc~pf_check_residual pf_check_residual proc~pf_check_convergence_block->proc~pf_check_residual proc~pf_send_status pf_send_status proc~pf_check_convergence_block->proc~pf_send_status proc~restrict_time_space_fas restrict_time_space_fas proc~pf_v_cycle->proc~restrict_time_space_fas proc~pf_post pf_post proc~pf_v_cycle->proc~pf_post proc~pf_residual pf_residual proc~pf_v_cycle->proc~pf_residual proc~interpolate_time_space interpolate_time_space proc~pf_v_cycle->proc~interpolate_time_space proc~pf_send pf_send proc~pf_v_cycle->proc~pf_send proc~interpolate_q0 interpolate_q0 proc~pf_v_cycle->proc~interpolate_q0 proc~pf_recv pf_recv proc~pf_v_cycle->proc~pf_recv proc~pf_predictor->proc~end_timer proc~pf_predictor->proc~call_hooks proc~pf_predictor->proc~start_timer proc~pf_predictor->proc~restrict_time_space_fas proc~pf_predictor->proc~pf_residual proc~pf_predictor->proc~interpolate_time_space proc~pf_predictor->proc~pf_send proc~pf_predictor->proc~interpolate_q0 proc~pf_predictor->proc~pf_recv mpi_wtime mpi_wtime proc~end_timer->mpi_wtime end_timer end_timer proc~pf_broadcast->end_timer start_timer start_timer proc~pf_broadcast->start_timer proc~call_hooks->proc~end_timer proc~call_hooks->proc~start_timer proc~start_timer->mpi_wtime proc~restrict_time_space_fas->proc~end_timer proc~restrict_time_space_fas->proc~call_hooks proc~restrict_time_space_fas->proc~start_timer proc~restrict_sdc restrict_sdc proc~restrict_time_space_fas->proc~restrict_sdc proc~pf_residual->proc~end_timer proc~pf_residual->proc~start_timer proc~interpolate_time_space->proc~end_timer proc~interpolate_time_space->proc~call_hooks proc~interpolate_time_space->proc~start_timer proc~pf_apply_mat pf_apply_mat proc~interpolate_time_space->proc~pf_apply_mat proc~pf_send->end_timer proc~pf_send->start_timer proc~interpolate_q0->proc~end_timer proc~interpolate_q0->proc~call_hooks proc~interpolate_q0->proc~start_timer proc~pf_recv->end_timer proc~pf_recv->start_timer proc~restrict_sdc->proc~pf_apply_mat var panprocpf_block_runCallsGraph = svgPanZoom('#procpf_block_runCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_block_run~~CalledByGraph proc~pf_block_run pf_block_run proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_block_run Source Code subroutine pf_block_run ( pf , q0 , dt , nsteps , qend , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf class ( pf_encap_t ), intent ( in ) :: q0 real ( pfdp ), intent ( in ) :: dt integer , intent ( in ) :: nsteps class ( pf_encap_t ), intent ( inout ), optional :: qend integer , intent ( in ), optional :: flags (:) class ( pf_level_t ), pointer :: lev_p !!  pointer to the one level we are operating on integer :: j , k integer :: nblocks !!  The number of blocks of steps to do integer :: nproc !!  The number of processors being used integer :: level_index_c !!  Coarsest leve in V-cycle call start_timer ( pf , TTOTAL ) pf % state % dt = dt pf % state % proc = pf % rank + 1 pf % state % step = pf % rank pf % state % t0 = pf % state % step * dt !  pointer to finest  level to start lev_p => pf % levels ( pf % nlevels ) !  Stick the initial condition into q0 (will happen on all processors) call lev_p % q0 % copy ( q0 , flags = 0 ) nproc = pf % comm % nproc nblocks = nsteps / nproc !  Decide what the coarsest level in the V-cycle is level_index_c = 1 if (. not . pf % Vcycle ) level_index_c = pf % nlevels do k = 1 , nblocks !  Loop over blocks of time steps ! print *,'Starting  step=',pf%state%step,'  block k=',k ! Each block will consist of !  1.  predictor !  2.  Vcycle until max iterations, or tolerances met !  3.  Move solution to next block !  Reset some flags !>  When starting a new block, broadcast new initial conditions to all procs !>  For initial block, this is done when initial conditions are set !> Reset some flags pf % state % iter = - 1 pf % state % itcnt = 0 pf % state % mysteps = 0 pf % state % status = PF_STATUS_PREDICTOR pf % state % pstatus = PF_STATUS_PREDICTOR pf % comm % statreq = - 66 pf % state % pfblock = k if ( k > 1 ) then if ( nproc > 1 ) then call lev_p % qend % pack ( lev_p % send ) !!  Pack away your last solution call pf_broadcast ( pf , lev_p % send , lev_p % mpibuflen , pf % comm % nproc - 1 ) call lev_p % q0 % unpack ( lev_p % send ) !!  Everyone resets their q0 else call lev_p % q0 % copy ( lev_p % qend , flags = 0 ) !!  Just stick qend in q0 end if !>  Update the step and t0 variables for new block pf % state % step = pf % state % step + pf % comm % nproc pf % state % t0 = pf % state % step * dt end if !> Call the predictor to get an initial guess on all levels and all processors call pf_predictor ( pf , pf % state % t0 , dt , flags ) !>  Start the loops over SDC sweeps pf % state % iter = 0 call call_hooks ( pf , - 1 , PF_POST_ITERATION ) call start_timer ( pf , TITERATION ) do j = 1 , pf % niters call call_hooks ( pf , - 1 , PF_PRE_ITERATION ) pf % state % iter = j !  Do a v_cycle call pf_v_cycle ( pf , k , pf % state % t0 , dt , level_index_c , pf % nlevels ) !  Check for convergence call pf_check_convergence_block ( pf , send_tag = 1111 * k + j ) !          print *,pf%rank, ' post res' call call_hooks ( pf , - 1 , PF_POST_ITERATION ) !  If we are converged, exit block if ( pf % state % status == PF_STATUS_CONVERGED ) exit end do !  Loop over the iteration in this bloc call call_hooks ( pf , - 1 , PF_POST_CONVERGENCE ) call end_timer ( pf , TITERATION ) call call_hooks ( pf , - 1 , PF_POST_STEP ) end do !  Loop over the blocks call end_timer ( pf , TTOTAL ) !  Grab the last solution for return (if wanted) if ( present ( qend )) then call qend % copy ( lev_p % qend , flags = 0 ) end if end subroutine pf_block_run","tags":"","loc":"proc/pf_block_run.html","title":"pf_block_run – LibPFASST"},{"text":"public subroutine pf_v_cycle(pf, iteration, t0, dt, level_index_c, level_index_f, flags) Execute a V-cycle between levels nfine and ncoarse Post the nonblocking receives on the all the levels that will be recieving later\n    (for single level this will be skipped)\n move from fine to coarse doing sweeps Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: iteration real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: level_index_c Coarsest level of V-cycle integer, intent(in) :: level_index_f Finest level of V-cycle integer, intent(in), optional :: flags Calls proc~~pf_v_cycle~~CallsGraph proc~pf_v_cycle pf_v_cycle proc~restrict_time_space_fas restrict_time_space_fas proc~pf_v_cycle->proc~restrict_time_space_fas proc~pf_post pf_post proc~pf_v_cycle->proc~pf_post proc~pf_residual pf_residual proc~pf_v_cycle->proc~pf_residual proc~pf_send pf_send proc~pf_v_cycle->proc~pf_send proc~interpolate_q0 interpolate_q0 proc~pf_v_cycle->proc~interpolate_q0 proc~pf_recv pf_recv proc~pf_v_cycle->proc~pf_recv proc~interpolate_time_space interpolate_time_space proc~pf_v_cycle->proc~interpolate_time_space proc~restrict_sdc restrict_sdc proc~restrict_time_space_fas->proc~restrict_sdc proc~end_timer end_timer proc~restrict_time_space_fas->proc~end_timer proc~call_hooks call_hooks proc~restrict_time_space_fas->proc~call_hooks proc~start_timer start_timer proc~restrict_time_space_fas->proc~start_timer proc~pf_residual->proc~end_timer proc~pf_residual->proc~start_timer end_timer end_timer proc~pf_send->end_timer start_timer start_timer proc~pf_send->start_timer proc~interpolate_q0->proc~end_timer proc~interpolate_q0->proc~call_hooks proc~interpolate_q0->proc~start_timer proc~pf_recv->end_timer proc~pf_recv->start_timer proc~interpolate_time_space->proc~end_timer proc~interpolate_time_space->proc~call_hooks proc~pf_apply_mat pf_apply_mat proc~interpolate_time_space->proc~pf_apply_mat proc~interpolate_time_space->proc~start_timer proc~restrict_sdc->proc~pf_apply_mat mpi_wtime mpi_wtime proc~end_timer->mpi_wtime proc~call_hooks->proc~end_timer proc~call_hooks->proc~start_timer proc~start_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_v_cycle~~CalledByGraph proc~pf_v_cycle pf_v_cycle proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_v_cycle proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_v_cycle Source Code subroutine pf_v_cycle ( pf , iteration , t0 , dt , level_index_c , level_index_f , flags ) type ( pf_pfasst_t ), intent ( inout ), target :: pf real ( pfdp ), intent ( in ) :: t0 , dt integer , intent ( in ) :: iteration integer , intent ( in ) :: level_index_c !! Coarsest level of V-cycle integer , intent ( in ) :: level_index_f !! Finest level of V-cycle integer , optional , intent ( in ) :: flags type ( pf_level_t ), pointer :: f_lev_p , c_lev_p integer :: level_index , j !>  Post the nonblocking receives on the all the levels that will be recieving later !>    (for single level this will be skipped) do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ) call pf_post ( pf , f_lev_p , f_lev_p % index * 10000 + iteration ) end do !> move from fine to coarse doing sweeps do level_index = level_index_f , level_index_c + 1 , - 1 f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false .) call restrict_time_space_fas ( pf , t0 , dt , level_index ) call save ( c_lev_p ) end do ! Do the coarsest level level_index = level_index_c f_lev_p => pf % levels ( level_index ) if ( pf % pipeline_pred ) then do j = 1 , f_lev_p % nsweeps call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . true .) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , 1 ) call pf_send ( pf , f_lev_p , f_lev_p % index * 10000 + iteration + j , . false .) end do else call pf_recv ( pf , f_lev_p , f_lev_p % index * 10000 + iteration , . true .) call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) call pf_send ( pf , f_lev_p , level_index * 10000 + iteration , . false .) endif ! Now move coarse to fine interpolating and sweeping do level_index = level_index_c + 1 , level_index_f f_lev_p => pf % levels ( level_index ); c_lev_p => pf % levels ( level_index - 1 ) call interpolate_time_space ( pf , t0 , dt , level_index , c_lev_p % Finterp ) call f_lev_p % qend % copy ( f_lev_p % Q ( f_lev_p % nnodes ), flags = 0 ) call pf_recv ( pf , f_lev_p , level_index * 10000 + iteration , . false .) if ( pf % rank /= 0 ) then ! interpolate increment to q0 -- the fine initial condition ! needs the same increment that Q(1) got, but applied to the ! new fine initial condition call interpolate_q0 ( pf , f_lev_p , c_lev_p , flags = 0 ) end if ! don't sweep on the finest level since that is only done at beginning if ( level_index < level_index_f ) then call f_lev_p % ulevel % sweeper % sweep ( pf , level_index , t0 , dt , f_lev_p % nsweeps ) else !  compute residual for diagnostics since we didn't sweep pf % state % sweep = 1 call pf_residual ( pf , f_lev_p , dt ) end if end do end subroutine pf_v_cycle","tags":"","loc":"proc/pf_v_cycle.html","title":"pf_v_cycle – LibPFASST"},{"text":"public subroutine misdcQ_oc_sweep(this, pf, level_index, t0, dt, nsweeps, flags) Uses pf_mod_timer pf_mod_hooks proc~~misdcq_oc_sweep~~UsesGraph proc~misdcq_oc_sweep misdcQ_oc_sweep module~pf_mod_hooks pf_mod_hooks proc~misdcq_oc_sweep->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer proc~misdcq_oc_sweep->module~pf_mod_timer module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags Calls proc~~misdcq_oc_sweep~~CallsGraph proc~misdcq_oc_sweep misdcQ_oc_sweep proc~call_hooks call_hooks proc~misdcq_oc_sweep->proc~call_hooks proc~pf_residual pf_residual proc~misdcq_oc_sweep->proc~pf_residual proc~start_timer start_timer proc~misdcq_oc_sweep->proc~start_timer proc~call_hooks->proc~start_timer proc~end_timer end_timer proc~call_hooks->proc~end_timer proc~pf_residual->proc~start_timer proc~pf_residual->proc~end_timer mpi_wtime mpi_wtime proc~start_timer->mpi_wtime proc~end_timer->mpi_wtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code misdcQ_oc_sweep Source Code subroutine misdcQ_oc_sweep ( this , pf , level_index , t0 , dt , nsweeps , flags ) use pf_mod_timer use pf_mod_hooks class ( pf_misdcQ_oc_t ), intent ( inout ) :: this type ( pf_pfasst_t ), target , intent ( inout ) :: pf integer , intent ( in ) :: level_index , nsweeps real ( pfdp ), intent ( in ) :: dt , t0 integer , optional , intent ( in ) :: flags !>  Local variables class ( pf_level_t ), pointer :: lev integer :: k , m , n , which , Nnodes real ( pfdp ) :: t , tend logical :: sweep_y , sweep_p integer :: step lev => pf % levels ( level_index ) !!  Assign level pointer call start_timer ( pf , TLEVEL + lev % index - 1 ) step = pf % state % step + 1 which = 0 if ( present ( flags )) which = flags if ( which . eq . 1 ) then sweep_y = . true . sweep_p = . false . else if ( which . eq . 2 ) then sweep_y = . false . sweep_p = . true . else sweep_y = . true . sweep_p = . true . end if Nnodes = lev % nnodes tend = t0 + dt do k = 1 , nsweeps call call_hooks ( pf , level_index , PF_PRE_SWEEP ) ! compute integrals and add fas correction if ( sweep_y ) then !  Forward in y do m = 1 , Nnodes - 1 call lev % I ( m )% setval ( 0.0_pfdp , 1 ) call this % I3 ( m )% setval ( 0.0_pfdp , 1 ) do n = 1 , Nnodes call lev % I ( m )% axpy ( dt * this % QdiffE ( m , n ), lev % F ( n , 1 ), 1 ) call lev % I ( m )% axpy ( dt * this % QdiffI ( m , n ), lev % F ( n , 2 ), 1 ) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( m , n ), lev % F ( n , 3 ), 1 ) call this % I3 ( m )% axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 ), 1 ) end do if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 1 ) end if end do end if if ( sweep_p ) then !  Backward in p do m = Nnodes - 1 , 1 , - 1 call lev % I ( m )% setval ( 0.0_pfdp , 2 ) call this % I3 ( m )% setval ( 0.0_pfdp , 2 ) do n = Nnodes , 1 , - 1 call lev % I ( m )% axpy ( dt * this % QdiffE ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 1 ), 2 ) call lev % I ( m )% axpy ( dt * this % QdiffI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 2 ), 2 ) call lev % I ( m )% axpy ( dt * lev % sdcmats % qmat ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 3 ), 2 ) call this % I3 ( m )% axpy ( dt * this % QtilI ( Nnodes - m , Nnodes + 1 - n ), lev % F ( n , 3 ), 2 ) end do if ( allocated ( lev % tauQ )) then call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), 2 ) end if end do end if ! do the time-stepping if ( k . eq . 1 ) then if ( sweep_y ) then call lev % Q ( 1 )% copy ( lev % q0 , 1 ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 1 ), 1 , 1 , 1 , step ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 2 ), 2 , 1 , 1 , step ) call this % f_eval ( lev % Q ( 1 ), t0 , lev % index , lev % F ( 1 , 3 ), 3 , 1 , 1 , step ) end if if ( sweep_p ) then call lev % Q ( Nnodes )% copy ( lev % qend , 2 ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 1 ), 1 , 2 , Nnodes , step ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 2 ), 2 , 2 , Nnodes , step ) call this % f_eval ( lev % Q ( Nnodes ), tend , lev % index , lev % F ( Nnodes , 3 ), 3 , 2 , Nnodes , step ) end if end if ! k .eq. 1 if ( sweep_y ) then t = t0 do m = 1 , lev % nnodes - 1 t = t + dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp , 1 ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilE ( m , n ), lev % F ( n , 1 ), 1 ) call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 2 ), 1 ) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 1 ) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( lev % Q ( m + 1 ), 1 ) do n = 1 , m call this % rhs % axpy ( dt * this % QtilI ( m , n ), lev % F ( n , 3 ), 1 ) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m ), 1 ) call this % f_comp ( lev % Q ( m + 1 ), t , dt * this % QtilI ( m , m + 1 ), this % rhs , lev % index , lev % F ( m + 1 , 3 ), 3 , 1 ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 1 ), 1 , 1 , m + 1 , step ) call this % f_eval ( lev % Q ( m + 1 ), t , lev % index , lev % F ( m + 1 , 2 ), 2 , 1 , m + 1 , step ) end do !call pf_residual(pf, lev, dt, 1) call lev % qend % copy ( lev % Q ( lev % nnodes ), 1 ) end if ! sweep_y if ( sweep_p ) then t = tend do m = Nnodes - 1 , 1 , - 1 t = t - dt * this % dtsdc ( m ) call this % rhs % setval ( 0.0_pfdp , 2 ) do n = Nnodes , m + 1 , - 1 call this % rhs % axpy ( dt * this % QtilE ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 1 ), 2 ) call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 2 ), 2 ) end do !  Add the tau term call this % rhs % axpy ( 1.0_pfdp , lev % I ( m ), 2 ) !  Add the starting value call this % rhs % axpy ( 1.0_pfdp , lev % Q ( Nnodes ), 2 ) call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 2 ), 2 , 2 ) !  Now we need to do the final subtraction for the f3 piece call this % rhs % copy ( lev % Q ( m ), 2 ) do n = Nnodes , m + 1 , - 1 call this % rhs % axpy ( dt * this % QtilI ( Nnodes - m , Nnodes - n + 1 ), lev % F ( n , 3 ), 2 ) end do call this % rhs % axpy ( - 1.0_pfdp , this % I3 ( m ), 2 ) call this % f_comp ( lev % Q ( m ), t , dt * this % QtilI ( Nnodes - m , Nnodes - m + 1 ), this % rhs , lev % index , lev % F ( m , 3 ), 3 , 2 ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , 2 , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , 2 , m , step ) end do !call pf_residual(pf, lev, dt, 2) call lev % q0 % copy ( lev % Q ( 1 ), 2 ) end if ! sweep_p if ( sweep_p . and . sweep_y ) then call pf_residual ( pf , lev , dt , 0 ) else if ( sweep_y ) then call pf_residual ( pf , lev , dt , 1 ) else if ( sweep_p ) then call pf_residual ( pf , lev , dt , 2 ) else stop \"neither sweep on p nor on y : that should not happen\" end if ! done call call_hooks ( pf , level_index , PF_POST_SWEEP ) end do ! k=1,nsweeps end subroutine misdcQ_oc_sweep","tags":"","loc":"proc/misdcq_oc_sweep.html","title":"misdcQ_oc_sweep – LibPFASST"},{"text":"public subroutine misdcQ_oc_initialize(this, lev) Array of substep sizes Make space for rhs Make space for extra integration piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code misdcQ_oc_initialize Source Code subroutine misdcQ_oc_initialize ( this , lev ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ) :: dsdc ( lev % nnodes - 1 ) integer :: m , n , nnodes this % npieces = 3 nnodes = lev % nnodes allocate ( this % QdiffE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QdiffI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % QtilE ( nnodes - 1 , nnodes )) !  S-FE allocate ( this % QtilI ( nnodes - 1 , nnodes )) !  S-BE allocate ( this % dtsdc ( nnodes - 1 )) this % QtilE = 0.0_pfdp this % QtilI = 0.0_pfdp !>  Array of substep sizes dsdc = lev % nodes ( 2 : nnodes ) - lev % nodes ( 1 : nnodes - 1 ) ! Implicit matrix if ( this % use_LUq ) then ! Get the LU this % QtilI = lev % sdcmats % qmatLU else this % QtilI = lev % sdcmats % qmatBE end if ! Explicit matrix this % QtilE = lev % sdcmats % qmatFE this % QdiffE = lev % sdcmats % qmat - this % QtilE this % QdiffI = lev % sdcmats % qmat - this % QtilI !>  Make space for rhs call lev % ulevel % factory % create_single ( this % rhs , lev % index , lev % shape ) !>  Make space for extra integration piece call lev % ulevel % factory % create_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) end subroutine misdcQ_oc_initialize","tags":"","loc":"proc/misdcq_oc_initialize.html","title":"misdcQ_oc_initialize – LibPFASST"},{"text":"public subroutine misdcQ_oc_destroy(this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Contents Source Code misdcQ_oc_destroy Source Code subroutine misdcQ_oc_destroy ( this , lev ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev deallocate ( this % QdiffE ) deallocate ( this % QdiffI ) deallocate ( this % QtilE ) deallocate ( this % QtilI ) deallocate ( this % dtsdc ) call lev % ulevel % factory % destroy_array ( this % I3 , lev % nnodes - 1 , lev % index , lev % shape ) call lev % ulevel % factory % destroy_single ( this % rhs , lev % index , lev % shape ) end subroutine misdcQ_oc_destroy","tags":"","loc":"proc/misdcq_oc_destroy.html","title":"misdcQ_oc_destroy – LibPFASST"},{"text":"public subroutine misdcQ_oc_integrate(this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags Contents Source Code misdcQ_oc_integrate Source Code subroutine misdcQ_oc_integrate ( this , lev , qSDC , fSDC , dt , fintSDC , flags ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( in ) :: lev class ( pf_encap_t ), intent ( in ) :: qSDC (:), fSDC (:, :) real ( pfdp ), intent ( in ) :: dt class ( pf_encap_t ), intent ( inout ) :: fintSDC (:) integer , optional , intent ( in ) :: flags integer :: n , m , p , which which = 0 if ( present ( flags )) which = flags do n = 1 , lev % nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call fintSDC ( n )% setval ( 0.0_pfdp , 1 ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( m , p ), 1 ) end do end do end if !  Backward in p if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call fintSDC ( lev % nnodes - n )% setval ( 0.0_pfdp , 2 ) do m = 1 , lev % nnodes do p = 1 , this % npieces call fintSDC ( lev % nnodes - n )% axpy ( dt * lev % sdcmats % qmat ( n , m ), fSDC ( lev % nnodes + 1 - m , p ), 2 ) end do end do end if end do end subroutine misdcQ_oc_integrate","tags":"","loc":"proc/misdcq_oc_integrate.html","title":"misdcQ_oc_integrate – LibPFASST"},{"text":"public subroutine misdcQ_oc_evaluate(this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code misdcQ_oc_evaluate Source Code subroutine misdcQ_oc_evaluate ( this , lev , t , m , flags , step ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this real ( pfdp ), intent ( in ) :: t integer , intent ( in ) :: m class ( pf_level_t ), intent ( inout ) :: lev integer , optional , intent ( in ) :: flags , step integer :: which , mystep which = 0 if ( present ( flags )) which = flags mystep = 1 if ( present ( step )) mystep = step call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 1 ), 1 , which , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 2 ), 2 , which , m , step ) call this % f_eval ( lev % Q ( m ), t , lev % index , lev % F ( m , 3 ), 3 , which , m , step ) end subroutine misdcQ_oc_evaluate","tags":"","loc":"proc/misdcq_oc_evaluate.html","title":"misdcQ_oc_evaluate – LibPFASST"},{"text":"public subroutine misdcQ_oc_evaluate_all(this, lev, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step Contents Source Code misdcQ_oc_evaluate_all Source Code subroutine misdcQ_oc_evaluate_all ( this , lev , t , flags , step ) !! Evaluate all function values class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t (:) integer , intent ( in ), optional :: flags , step !     call pf_generic_evaluate_all(this, lev, t, flags, step) integer :: m if (. not . present ( flags )) stop \"MISDCQ_OC EVAL_ALL WITHOUT FLAGS\" if (. not . present ( step )) stop \"MISDCQ_OC EVAL_ALL WITHOUT step\" do m = 1 , lev % nnodes call this % evaluate ( lev , t ( m ), m , flags , step ) end do end subroutine misdcQ_oc_evaluate_all","tags":"","loc":"proc/misdcq_oc_evaluate_all.html","title":"misdcQ_oc_evaluate_all – LibPFASST"},{"text":"public subroutine misdcQ_oc_residual(this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags Contents Source Code misdcQ_oc_residual Source Code subroutine misdcQ_oc_residual ( this , lev , dt , flags ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: dt integer , optional , intent ( in ) :: flags integer :: m , n , which which = 0 if ( present ( flags )) which = flags call this % integrate ( lev , lev % Q , lev % F , dt , lev % I , which ) ! add tau (which is 'node to node') if ( allocated ( lev % tauQ )) then do m = 1 , lev % nnodes - 1 call lev % I ( m )% axpy ( 1.0_pfdp , lev % tauQ ( m ), which ) end do end if ! subtract out Q do m = 1 , lev % nnodes - 1 if ( ( which . eq . 0 ) . or . ( which . eq . 1 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 1 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( 1 ), 1 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m + 1 ), 1 ) end if if ( ( which . eq . 0 ) . or . ( which . eq . 2 ) ) then call lev % R ( m )% copy ( lev % I ( m ), 2 ) call lev % R ( m )% axpy ( 1.0_pfdp , lev % Q ( lev % nnodes ), 2 ) call lev % R ( m )% axpy ( - 1.0_pfdp , lev % Q ( m ), 2 ) end if end do end subroutine misdcQ_oc_residual","tags":"","loc":"proc/misdcq_oc_residual.html","title":"misdcQ_oc_residual – LibPFASST"},{"text":"public subroutine misdcQ_oc_spreadq0(this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step Calls proc~~misdcq_oc_spreadq0~~CallsGraph proc~misdcq_oc_spreadq0 misdcQ_oc_spreadq0 proc~pf_stop pf_stop proc~misdcq_oc_spreadq0->proc~pf_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code misdcQ_oc_spreadq0 Source Code subroutine misdcQ_oc_spreadq0 ( this , lev , t0 , flags , step ) class ( pf_misdcQ_oc_t ), intent ( inout ) :: this class ( pf_level_t ), intent ( inout ) :: lev real ( pfdp ), intent ( in ) :: t0 integer , optional , intent ( in ) :: flags , step integer :: m , p , which , mystep which = 3 if ( present ( flags )) which = flags if (. not . present ( flags )) stop \"IMEXQ_OC SPREADQ0 WITHOUT FLAGS\" mystep = 1 if ( present ( step )) then mystep = step !needed for sequential version else print * , \"step not present in spreadq0\" , which stop end if select case ( which ) case ( 1 ) !  Stick initial condition into first node slot call lev % Q ( 1 )% copy ( lev % q0 , 1 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , 1 , 1 , mystep ) ! Spread F and solution to all nodes do m = 2 , lev % nnodes call lev % Q ( m )% copy ( lev % Q ( 1 ), 1 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( 1 , p ), 1 ) end do end do case ( 2 ) !  Stick terminal condition into last node slot call lev % Q ( lev % nnodes )% copy ( lev % qend , 2 ) !  Evaluate F at first spot call lev % ulevel % sweeper % evaluate ( lev , t0 , lev % nnodes , 2 , mystep ) ! Spread F and solution to all nodes do m = lev % nnodes - 1 , 1 , - 1 call lev % Q ( m )% copy ( lev % Q ( lev % nnodes ), 2 ) do p = 1 , lev % ulevel % sweeper % npieces call lev % F ( m , p )% copy ( lev % F ( lev % nnodes , p ), 2 ) end do end do case default call pf_stop ( __ FILE__ , __ LINE__ , 'Bad case in SELECT' , which ) stop end select end subroutine misdcQ_oc_spreadq0","tags":"","loc":"proc/misdcq_oc_spreadq0.html","title":"misdcQ_oc_spreadq0 – LibPFASST"},{"text":"interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward integer, intent(in), optional :: idx index of quadrature node integer, intent(in), optional :: step time step for sequential version Description This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two\n  Evaluate f_piece(y), where piece is one or two","tags":"","loc":"interface/pf_f_eval_p~12.html","title":"pf_f_eval_p – LibPFASST"},{"text":"interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward Description Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece","tags":"","loc":"interface/pf_f_comp_p~8.html","title":"pf_f_comp_p – LibPFASST"},{"text":"public subroutine pf_post(pf, level, tag, direction) Subroutine to post a receive request for a new initial condition to be received after doing some work Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(in) :: pf class(pf_level_t), intent(inout) :: level integer, intent(in) :: tag integer, intent(in), optional :: direction Called by proc~~pf_post~~CalledByGraph proc~pf_post pf_post proc~pf_v_cycle pf_v_cycle proc~pf_v_cycle->proc~pf_post proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_v_cycle_oc->proc~pf_post proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_v_cycle proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_post Source Code subroutine pf_post ( pf , level , tag , direction ) type ( pf_pfasst_t ), intent ( in ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: ierror , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'is beginning pf_post, state%pstatus=' , pf % state % pstatus , 'with tag =' , tag ierror = 0 if ( pf % rank /= 0 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 1 ) then source = pf % rank - 1 call pf % comm % post ( pf , level , tag , ierror , source ) elseif ( pf % rank /= pf % comm % nproc - 1 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 2 ) then source = pf % rank + 1 call pf % comm % post ( pf , level , tag , ierror , source ) end if if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during post' , ierror stop \"pf_parallel:pf_post\" endif if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'is leaving pf_post, state%pstatus=' , pf % state % pstatus , 'with tag =' , tag end subroutine pf_post","tags":"","loc":"proc/pf_post.html","title":"pf_post – LibPFASST"},{"text":"public subroutine pf_send_status(pf, tag, direction) Subroutine to send this processor's convergence status to the next processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in), optional :: direction Called by proc~~pf_send_status~~CalledByGraph proc~pf_send_status pf_send_status proc~pf_check_convergence_oc pf_check_convergence_oc proc~pf_check_convergence_oc->proc~pf_send_status proc~pf_check_convergence_block pf_check_convergence_block proc~pf_check_convergence_block->proc~pf_send_status proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_check_convergence_block proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_check_convergence_oc proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_send_status Source Code subroutine pf_send_status ( pf , tag , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: istatus integer :: ierror , dest if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction if ( pf % rank == 0 . and . dir == 2 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 1 ) return ierror = 0 istatus = pf % state % status if ( dir == 1 ) then dest = pf % rank + 1 elseif ( dir == 2 ) then dest = pf % rank - 1 else print * , pf % rank , 'warning: bad dir during send_status' , dir stop \"pf_parallel:pf_send_status\" end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begins send_status with status' , istatus , 'with tag =' , tag call pf % comm % send_status ( pf , tag , istatus , ierror , dest ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'ends send_status' if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during send_status' , ierror stop \"pf_parallel:pf_send_status\" endif end subroutine pf_send_status","tags":"","loc":"proc/pf_send_status.html","title":"pf_send_status – LibPFASST"},{"text":"public subroutine pf_recv_status(pf, tag, direction) Subroutine to receive the convergence status from the previous processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in), optional :: direction Contents Source Code pf_recv_status Source Code subroutine pf_recv_status ( pf , tag , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: tag integer , optional , intent ( in ) :: direction integer :: dir integer :: ierror , istatus , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default 1: send forward; set to 2 for send backwards if ( present ( direction )) dir = direction !  Return if this is the first processor if ( pf % rank == 0 . and . dir == 1 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 2 ) return if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin recv_status with pstatus=' , pf % state % pstatus , ' tag=' , tag ierror = 0 if ( dir == 1 ) then source = pf % rank - 1 elseif ( dir == 2 ) then source = pf % rank + 1 else print * , pf % rank , 'warning: bad dir in recv_status' , dir stop \"pf_parallel_oc:pf_recv_status\" end if if ( pf % debug ) print * , pf % rank , 'is receiving status backwards with tag ' , tag call pf % comm % recv_status ( pf , tag , istatus , ierror , source ) if ( ierror . eq . 0 ) then pf % state % pstatus = istatus else print * , pf % rank , 'warning: error during recv_status' , ierror stop \"pf_parallel_oc:pf_recv_status\" endif if ( pf % debug ) print * , pf % rank , 'status recvd = ' , istatus if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end recv_statuswith pstatus=' , pf % state % pstatus , 'tag=' , tag end subroutine pf_recv_status","tags":"","loc":"proc/pf_recv_status.html","title":"pf_recv_status – LibPFASST"},{"text":"public subroutine pf_send(pf, level, tag, blocking, direction) Subroutine to send the solution to the next processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(in), optional :: direction Calls proc~~pf_send~~CallsGraph proc~pf_send pf_send start_timer start_timer proc~pf_send->start_timer end_timer end_timer proc~pf_send->end_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_send~~CalledByGraph proc~pf_send pf_send proc~pf_predictor_oc pf_predictor_oc proc~pf_predictor_oc->proc~pf_send proc~pf_v_cycle pf_v_cycle proc~pf_v_cycle->proc~pf_send proc~pf_predictor pf_predictor proc~pf_predictor->proc~pf_send proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_v_cycle_oc->proc~pf_send proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_v_cycle proc~pf_block_run->proc~pf_predictor proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_send Source Code subroutine pf_send ( pf , level , tag , blocking , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf class ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , optional , intent ( in ) :: direction integer :: dir , ierror , dest if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default: send forward if ( present ( direction )) dir = direction if ( pf % rank == 0 . and . dir == 2 ) return if ( pf % rank == pf % comm % nproc - 1 . and . dir == 1 ) return if ( dir == 2 ) then call level % q0 % pack ( level % send , 2 ) dest = pf % rank - 1 else dest = pf % rank + 1 if ( present ( direction )) then !  This is for the imk sweeper where the presence of a flag matters call level % qend % pack ( level % send , 1 ) else call level % qend % pack ( level % send ) end if end if ierror = 0 call start_timer ( pf , TSEND + level % index - 1 ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin send, tag=' , tag , blocking , ' pf%state%status =' , pf % state % status call pf % comm % send ( pf , level , tag , blocking , ierror , dest ) if ( ierror /= 0 ) then print * , pf % rank , 'warning: error during send' , ierror stop \"pf_parallel:pf_send\" endif if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end send, tag=' , tag , blocking call end_timer ( pf , TSEND + level % index - 1 ) end subroutine pf_send","tags":"","loc":"proc/pf_send.html","title":"pf_send – LibPFASST"},{"text":"public subroutine pf_recv(pf, level, tag, blocking, direction) Subroutine to recieve the solution from the previous processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf type(pf_level_t), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(in), optional :: direction Calls proc~~pf_recv~~CallsGraph proc~pf_recv pf_recv start_timer start_timer proc~pf_recv->start_timer end_timer end_timer proc~pf_recv->end_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_recv~~CalledByGraph proc~pf_recv pf_recv proc~pf_predictor_oc pf_predictor_oc proc~pf_predictor_oc->proc~pf_recv proc~pf_v_cycle pf_v_cycle proc~pf_v_cycle->proc~pf_recv proc~pf_predictor pf_predictor proc~pf_predictor->proc~pf_recv proc~pf_v_cycle_oc pf_v_cycle_oc proc~pf_v_cycle_oc->proc~pf_recv proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_v_cycle proc~pf_block_run->proc~pf_predictor proc~pf_pfasst_block_oc pf_pfasst_block_oc proc~pf_pfasst_block_oc->proc~pf_predictor_oc proc~pf_pfasst_block_oc->proc~pf_v_cycle_oc proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_recv Source Code subroutine pf_recv ( pf , level , tag , blocking , direction ) type ( pf_pfasst_t ), intent ( inout ) :: pf type ( pf_level_t ), intent ( inout ) :: level integer , intent ( in ) :: tag logical , intent ( in ) :: blocking integer , optional , intent ( in ) :: direction integer :: dir , ierror , source if ( pf % comm % nproc . eq . 1 ) return dir = 1 ! default: send forward if ( present ( direction )) dir = direction ierror = 0 call start_timer ( pf , TRECEIVE + level % index - 1 ) if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'begin recv, tag=' , tag , blocking , \"pf%state%pstatus=\" , pf % state % pstatus if ( pf % rank /= 0 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 1 ) then source = pf % rank - 1 call pf % comm % recv ( pf , level , tag , blocking , ierror , source ) if ( ierror . eq . 0 ) then if ( present ( direction )) then call level % q0 % unpack ( level % recv , 1 ) else call level % q0 % unpack ( level % recv ) end if end if elseif ( pf % rank /= pf % comm % nproc - 1 . and . pf % state % pstatus == PF_STATUS_ITERATING & . and . dir == 2 ) then source = pf % rank + 1 call pf % comm % recv ( pf , level , tag , blocking , ierror , source ) if ( ierror . eq . 0 ) then if ( present ( direction )) then call level % qend % unpack ( level % recv , 2 ) else call level % qend % unpack ( level % recv ) end if end if end if if ( pf % debug ) print * , 'DEBUG --' , pf % rank , 'end recv, tag=' , tag , blocking if ( ierror . ne . 0 ) then print * , pf % rank , 'warning: mpi error during receive' , ierror stop \"pf_parallel:pf_recv\" end if call end_timer ( pf , TRECEIVE + level % index - 1 ) end subroutine pf_recv","tags":"","loc":"proc/pf_recv.html","title":"pf_recv – LibPFASST"},{"text":"public subroutine pf_broadcast(pf, y, nvar, root) Subroutine to broadcast the initial condition to all processors Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf real(kind=pfdp), intent(in) :: y (nvar) integer, intent(in) :: nvar integer, intent(in) :: root Calls proc~~pf_broadcast~~CallsGraph proc~pf_broadcast pf_broadcast start_timer start_timer proc~pf_broadcast->start_timer end_timer end_timer proc~pf_broadcast->end_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pf_broadcast~~CalledByGraph proc~pf_broadcast pf_broadcast proc~pf_block_run pf_block_run proc~pf_block_run->proc~pf_broadcast proc~pf_pfasst_run pf_pfasst_run proc~pf_pfasst_run->proc~pf_block_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pf_broadcast Source Code subroutine pf_broadcast ( pf , y , nvar , root ) type ( pf_pfasst_t ), intent ( inout ) :: pf integer , intent ( in ) :: nvar , root real ( pfdp ) , intent ( in ) :: y ( nvar ) integer :: ierror if ( pf % comm % nproc . eq . 1 ) return call start_timer ( pf , TBROADCAST ) if ( pf % debug ) print * , 'beginning broadcast' call pf % comm % broadcast ( pf , y , nvar , root , ierror ) if ( ierror /= 0 ) then print * , pf % rank , 'warning:  error during broadcast' , ierror stop \"pf_parallel:pf_broadcast\" endif call end_timer ( pf , TBROADCAST ) if ( pf % debug ) print * , 'ending broadcast' end subroutine pf_broadcast","tags":"","loc":"proc/pf_broadcast.html","title":"pf_broadcast – LibPFASST"},{"text":"public subroutine save(lev, flags) Save current solution and function value so that future corrections can be computed Arguments Type Intent Optional Attributes Name class(pf_level_t), intent(inout) :: lev Level to save on integer, intent(in), optional :: flags which component to save (state/adjoint) Contents Source Code save Source Code subroutine save ( lev , flags ) class ( pf_level_t ), intent ( inout ) :: lev !!  Level to save on integer , optional , intent ( in ) :: flags !!  which component to save (state/adjoint) integer :: m , p if ( lev % Finterp ) then if ( allocated ( lev % pFflt )) then do m = 1 , lev % nnodes do p = 1 , size ( lev % F ( 1 ,:)) call lev % pF ( m , p )% copy ( lev % F ( m , p ), flags ) end do call lev % pQ ( m )% copy ( lev % Q ( m ), flags ) end do end if else if ( allocated ( lev % pQ )) then do m = 1 , lev % nnodes call lev % pQ ( m )% copy ( lev % Q ( m ), flags ) end do end if end if end subroutine save","tags":"","loc":"proc/save.html","title":"save – LibPFASST"},{"text":"Module to restrict solutions between pfasst levels and create the FAS tau correction Uses pf_mod_dtype pf_mod_timer pf_mod_hooks module~~pf_mod_restrict~~UsesGraph module~pf_mod_restrict pf_mod_restrict module~pf_mod_dtype pf_mod_dtype module~pf_mod_restrict->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_restrict->module~pf_mod_timer module~pf_mod_hooks pf_mod_hooks module~pf_mod_restrict->module~pf_mod_hooks iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_hooks->module~pf_mod_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_restrict~~UsedByGraph module~pf_mod_restrict pf_mod_restrict module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_interpolate->module~pf_mod_restrict module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_restrict module~pf_mod_parallel_oc->module~pf_mod_interpolate module~pf_mod_parallel pf_mod_parallel module~pf_mod_parallel->module~pf_mod_restrict module~pf_mod_parallel->module~pf_mod_interpolate module~pfasst pfasst module~pfasst->module~pf_mod_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines restrict_time_space_fas restrict_sdc pf_apply_mat pf_apply_mat_backward Subroutines public subroutine restrict_time_space_fas (pf, t0, dt, level_index, flags, mystep) Restrict (in time and space) fine level to coarse and set coarse level FAS correction. Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf real(kind=pfdp), intent(in) :: t0 time at beginning of step real(kind=pfdp), intent(in) :: dt time step integer, intent(in) :: level_index defines which level to restrict integer, intent(in), optional :: flags integer, intent(in), optional :: mystep public subroutine restrict_sdc (f_lev_ptr, c_lev_ptr, f_encap_array, c_encap_array, IS_INTEGRAL, f_time, flags) Restrict (in time and space) f_sol_array  to c_sol_array\n Depending on the flag INTEGRAL, we may be restricting solutions, or integrals of F Read more… Arguments Type Intent Optional Attributes Name class( pf_level_t ), intent(inout) :: f_lev_ptr pointer to fine level class( pf_level_t ), intent(inout) :: c_lev_ptr pointer to coarse level class( pf_encap_t ), intent(inout) :: f_encap_array (:) array of fine level data to be restricted class( pf_encap_t ), intent(inout) :: c_encap_array (:) array of coarse level data to be computed logical, intent(in) :: IS_INTEGRAL flag determines if it is integral data being restricted real(kind=pfdp), intent(in) :: f_time (:) time at the fine nodes integer, intent(in), optional :: flags public subroutine pf_apply_mat (dst, a, mat, src, zero, flags) Apply a matrix (tmat or rmat) to src and add to dst.\n Mathematically this is \n     dst= dst + a mat src\n  Where dst and src are vectors, mat is a matrix, and a is a scalar\n  If the optional variable \"zero\" is provided and is true, then we compute\n     dst=  a mat src Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: dst (:) destination vector real(kind=pfdp), intent(in) :: a scalar real(kind=pfdp), intent(in) :: mat (:,:) matrix class( pf_encap_t ), intent(in) :: src (:) src vector logical, intent(in), optional :: zero If false, don't zero out the the dst variable before computing integer, intent(in), optional :: flags Used for choosing which variable to operate on Read more… public subroutine pf_apply_mat_backward (dst, a, mat, src, zero, flags) Apply a matrix (tmat or rmat) to src and add to dst. Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: dst (:) destination vector real(kind=pfdp), intent(in) :: a scalar real(kind=pfdp), intent(in) :: mat (:,:) matrix class( pf_encap_t ), intent(in) :: src (:) src vector logical, intent(in), optional :: zero If false, don't zero out the the dst variable before computing integer, intent(in), optional :: flags Used for choosing which variable to operate on Read more…","tags":"","loc":"module/pf_mod_restrict.html","title":"pf_mod_restrict – LibPFASST"},{"text":"Module to create quadrature matrices and accompanying routines Uses pf_mod_dtype pf_mod_utils module~~pf_mod_quadrature~~UsesGraph module~pf_mod_quadrature pf_mod_quadrature module~pf_mod_utils pf_mod_utils module~pf_mod_quadrature->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_quadrature->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_quadrature~~UsedByGraph module~pf_mod_quadrature pf_mod_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->module~pf_mod_quadrature proc~imexq_initialize imexQ_initialize proc~imexq_initialize->module~pf_mod_quadrature proc~pf_level_destroy pf_level_destroy proc~pf_level_destroy->module~pf_mod_quadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables qp dp eps Interfaces poly_eval Functions not_proper poly_eval poly_eval_complex Subroutines pf_init_sdcmats pf_destroy_sdcmats myLUq pf_quadrature pf_make_matrices sdc_qnodes sdc_qmats poly_diff poly_int poly_legendre poly_roots qsort Variables Type Visibility Attributes Name Initial integer, public, parameter :: qp = c_long_double integer, public, parameter :: dp = c_double real(kind=qp), public, parameter :: eps = 1.0e-23_qp Interfaces public interface poly_eval public interface poly_eval () Arguments None public function poly_eval_complex (p, n, x) result(v) Function to evaluate complex polynomial Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n complex(kind=pfqp), intent(in) :: x Return Value complex(kind=pfqp) Functions public function not_proper (flags, node) Function to decide if the restriction of the nodes is pointwise, e.g. coarse nodes are every other fine node Arguments Type Intent Optional Attributes Name integer, intent(in) :: flags (:) integer, intent(in) :: node Return Value logical public function poly_eval (p, n, x) result(v) Polynomial manipulation routines. Read more… Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n real(kind=pfqp), intent(in) :: x Return Value real(kind=pfqp) public function poly_eval_complex (p, n, x) result(v) Function to evaluate complex polynomial Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(in) :: p (0:n) integer, intent(in), value :: n complex(kind=pfqp), intent(in) :: x Return Value complex(kind=pfqp) Subroutines public subroutine pf_init_sdcmats (pf, SDCmats, nnodes, nflags) Initialize the sdcmats type with the correct nodes and quadrature matrices\n Decide what the base integration type is Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf PFASST structure type( pf_sdcmats_t ), intent(inout) :: SDCmats integer, intent(in) :: nnodes integer, intent(inout) :: nflags (nnodes) public subroutine pf_destroy_sdcmats (SDCmats) Destroy the sdcmats structure Arguments Type Intent Optional Attributes Name type( pf_sdcmats_t ), intent(inout) :: SDCmats public subroutine myLUq (Q, QLU, Nnodes, fillq) Routine to compute the LU decomposition of spectral integration matrix Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: Q (Nnodes-1,Nnodes) real(kind=pfdp), intent(inout) :: QLU (Nnodes-1,Nnodes) integer, intent(in) :: Nnodes integer, intent(in) :: fillq public subroutine pf_quadrature (qtype, nnodes, nnodes0, nodes, nflags, smat, qmat, proper, composite, no_left) Subroutine to create quadrature nodes and matrices Arguments Type Intent Optional Attributes Name integer, intent(in) :: qtype integer, intent(in) :: nnodes integer, intent(in) :: nnodes0 real(kind=pfdp), intent(out) :: nodes (nnodes) integer, intent(out) :: nflags (nnodes) real(kind=pfdp), intent(out) :: smat (nnodes-1,nnodes) real(kind=pfdp), intent(out) :: qmat (nnodes-1,nnodes) logical, intent(in) :: proper logical, intent(in) :: composite logical, intent(in) :: no_left public subroutine pf_make_matrices (SDCmats) Arguments Type Intent Optional Attributes Name type( pf_sdcmats_t ), intent(inout) :: SDCmats public subroutine sdc_qnodes (qnodes, flags, qtype, nnodes) Subroutine to compute high precision quadrature nodes. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: qnodes (nnodes) The computed quadrature nodes integer, intent(out) :: flags (nnodes) integer, intent(in), value :: qtype Type of nodes (see pf_dtype) integer, intent(in), value :: nnodes Number of nodes public subroutine sdc_qmats (qmat, smat, dst, src, flags, ndst, nsrc) Subroutine to compute the quadrature matrices Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(out) :: qmat (ndst-1,nsrc) O to dst quadrature weights real(kind=pfdp), intent(out) :: smat (ndst-1,nsrc) dst(m) to dst(m+1) quadrature weights real(kind=pfqp), intent(in) :: dst (ndst) Destination points real(kind=pfqp), intent(in) :: src (nsrc) Source points integer, intent(in) :: flags (nsrc) integer, intent(in), value :: ndst Number of destination points integer, intent(in), value :: nsrc Number of source points public subroutine poly_diff (p, n) Subroutine to differentiate polynomial (in place) Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: p (0:n) integer, intent(in), value :: n public subroutine poly_int (p, n) Subroutine to integrate polynomial (in place) Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: p (0:n) integer, intent(in), value :: n public subroutine poly_legendre (p, n) Subroutine to compute Legendre polynomial coefficients using Bonnet's recursion formula. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: p (0:n) integer, intent(in), value :: n public subroutine poly_roots (roots, p0, n) Subroutine to compute polynomial roots using the Durand-Kerner algorithm.\n The roots are assumed to be real. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(out) :: roots (n) real(kind=pfqp), intent(in) :: p0 (0:n) integer, intent(in), value :: n public recursive subroutine qsort (a) Subroutine to sort (inplace) using the quick sort algorithm.\n Adapted from http://www.fortran.com/qsort_c.f95. Arguments Type Intent Optional Attributes Name real(kind=pfqp), intent(inout) :: a (:)","tags":"","loc":"module/pf_mod_quadrature.html","title":"pf_mod_quadrature – LibPFASST"},{"text":"System of N-dimensional arrays encapsulation. When a new solution is created by a PFASST level, this encapsulation\n uses the levels 'arr_shape' attribute to create a new multi-component array with that\n shape.  Thus, the 'arr_shape' attributes of the PFASST levels should be\n set appropriately.  The last component of arr_shape is the number of components in the system For example, before calling pf_pfasst_run we can\n set the arr_shape of the coarsest level by doing: allocate(pf%levels(1)%arr_shape(3))\n   pf%levels(1)%arr_shape = [ nx, ny, 3 ] Which would imply that a 3 component system of two-dimensional solutions. The helper routines array1, array2, array3, etc can be used to\n extract pointers to a component of  encapsulated system\n performing any copies. $ Uses iso_c_binding pf_mod_dtype module~~pf_mod_ndsysarray~~UsesGraph module~pf_mod_ndsysarray pf_mod_ndsysarray module~pf_mod_dtype pf_mod_dtype module~pf_mod_ndsysarray->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_ndsysarray->iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces ndsysarray_mkdir ndsysarray_dump_numpy Derived Types ndsysarray_factory ndsysarray Functions ndsysarray_norm cast_as_ndsysarray get_array1d get_array2d get_array3d Subroutines ndsysarray_build ndsysarray_create_single ndsysarray_create_array ndsysarray_destroy ndsysarray_destroy_single ndsysarray_destroy_array ndsysarray_setval ndsysarray_copy ndsysarray_pack ndsysarray_unpack ndsysarray_axpy ndsysarray_eprint Interfaces interface Interfaces to output routines in pf_numpy.c public subroutine ndsysarray_mkdir(dname, dlen) bind(c) Subroutine to make a directory for output Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname integer, intent(in), value :: dlen interface Interfaces to output routines in pf_numpy.c public subroutine ndsysarray_dump_numpy(dname, fname, endian, dim, mpibuflen, arr_shape, array) bind(c) Subroutine to write an the array to a file Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: arr_shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Derived Types type, public, extends( pf_factory_t ) :: ndsysarray_factory Type to create and destroy systems of N-dimensional arrays Type-Bound Procedures procedure, public :: create_single => ndsysarray_create_single procedure, public :: create_array => ndsysarray_create_array procedure, public :: destroy_single => ndsysarray_destroy_single procedure, public :: destroy_array => ndsysarray_destroy_array type, public, extends( pf_encap_t ) :: ndsysarray Type for system of  N-dimensional arrays,  extends the abstract encap type Components Type Visibility Attributes Name Initial integer, public :: dim integer, public :: ncomp integer, public :: ndof integer, public, allocatable :: arr_shape (:) real(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => ndsysarray_setval procedure, public :: copy => ndsysarray_copy procedure, public :: norm => ndsysarray_norm procedure, public :: pack => ndsysarray_pack procedure, public :: unpack => ndsysarray_unpack procedure, public :: axpy => ndsysarray_axpy procedure, public :: eprint => ndsysarray_eprint Functions public function ndsysarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) public function cast_as_ndsysarray (encap_polymorph) result(ndsysarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndsysarray ),\n  pointer public function get_array1d (x, n, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:) public function get_array2d (x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:) public function get_array3d (x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine ndsysarray_build (q, arr_shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: arr_shape (:) public subroutine ndsysarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndsysarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndsysarray_destroy (encap) Subroutine to destroy array (simple) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap public subroutine ndsysarray_destroy_single (this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndsysarray_destroy_array (this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndsysarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags public subroutine ndsysarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags public subroutine ndsysarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags public subroutine ndsysarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags public subroutine ndsysarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags public subroutine ndsysarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_ndsysarray.html","title":"pf_mod_ndsysarray – LibPFASST"},{"text":"Module for providing FFTs based on fftw\n  To use this module, fftw must be installed.\n  This can be done by the libpfasst make system with the comment make fftw3 Uses pf_mod_dtype pf_mod_utils module~~pf_mod_fftpackage~~UsesGraph module~pf_mod_fftpackage pf_mod_fftpackage module~pf_mod_utils pf_mod_utils module~pf_mod_fftpackage->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_fftpackage->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables two_pi Derived Types pf_fft_t Functions get_wk_ptr_1d get_wk_ptr_2d get_wk_ptr_3d Subroutines fft_setup fft_destroy fftf fftb conv_1d conv_2d conv_3d make_lap_1d make_deriv_1d make_lap_2d make_deriv_2d make_lap_3d make_deriv_3d Variables Type Visibility Attributes Name Initial real(kind=pfdp), public, parameter :: two_pi = 6.2831853071795862_pfdp Derived Types type, public :: pf_fft_t Define the fft package Components Type Visibility Attributes Name Initial type(c_ptr), public :: ffft fftw pointers type(c_ptr), public :: ifft fftw pointers integer, public :: dim spatial number of dimensions integer, public :: nx grid sizes integer, public :: ny grid sizes integer, public :: nz grid sizes real(kind=pfdp), public :: Lx domain size real(kind=pfdp), public :: Ly domain size real(kind=pfdp), public :: Lz domain size real(kind=pfdp), public :: normfact normalization factor complex(kind=pfdp), public, pointer :: wk_1d (:) work space complex(kind=pfdp), public, pointer :: wk_2d (:,:) work space complex(kind=pfdp), public, pointer :: wk_3d (:,:,:) work space Type-Bound Procedures procedure, public :: fft_setup procedure, public :: fft_destroy procedure, public :: fftf procedure, public :: fftb generic, public :: conv => conv_1d, conv_2d, conv_3d procedure, public :: get_wk_ptr_1d procedure, public :: get_wk_ptr_2d procedure, public :: get_wk_ptr_3d procedure, public :: make_lap_1d procedure, public :: make_lap_2d procedure, public :: make_lap_3d procedure, public :: make_deriv_1d procedure, public :: make_deriv_2d procedure, public :: make_deriv_3d Functions public function get_wk_ptr_1d (this) result(wk) Routines to return the pointer to the work variable Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:) public function get_wk_ptr_2d (this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:,:) public function get_wk_ptr_3d (this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine fft_setup (this, grid_shape, dim, grid_size) Initialize the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) public subroutine fft_destroy (this) Destroy the package Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine fftf (this) Routine to take foreward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine fftb (this) Routine to take inverse or backward FFT Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine conv_1d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) public subroutine conv_2d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) public subroutine conv_3d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) public subroutine make_lap_1d (this, lap) Routines to construct spectral differential operators Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) public subroutine make_deriv_1d (this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) public subroutine make_lap_2d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) public subroutine make_deriv_2d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir public subroutine make_lap_3d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) public subroutine make_deriv_3d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir","tags":"","loc":"module/pf_mod_fftpackage.html","title":"pf_mod_fftpackage – LibPFASST"},{"text":"Module containing a collection of \"use\" statements to simplify\n  including the common main modules in writing applications that use libpfasst Uses pf_mod_dtype pf_mod_hooks pf_mod_results pf_mod_parallel pf_mod_pfasst pf_mod_comm_mpi pf_mod_imexQ module~~pfasst~~UsesGraph module~pfasst pfasst module~pf_mod_imexq pf_mod_imexQ module~pfasst->module~pf_mod_imexq module~pf_mod_comm_mpi pf_mod_comm_mpi module~pfasst->module~pf_mod_comm_mpi module~pf_mod_pfasst pf_mod_pfasst module~pfasst->module~pf_mod_pfasst module~pf_mod_dtype pf_mod_dtype module~pfasst->module~pf_mod_dtype module~pf_mod_hooks pf_mod_hooks module~pfasst->module~pf_mod_hooks module~pf_mod_results pf_mod_results module~pfasst->module~pf_mod_results module~pf_mod_parallel pf_mod_parallel module~pfasst->module~pf_mod_parallel module~pf_mod_imexq->module~pf_mod_dtype module~pf_mod_utils pf_mod_utils module~pf_mod_imexq->module~pf_mod_utils module~pf_mod_comm_mpi->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_comm_mpi->module~pf_mod_mpi module~pf_mod_pfasst->module~pf_mod_comm_mpi module~pf_mod_pfasst->module~pf_mod_dtype module~pf_mod_pfasst->module~pf_mod_results module~pf_mod_pfasst->module~pf_mod_utils iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_results->module~pf_mod_dtype module~pf_mod_results->module~pf_mod_utils module~pf_mod_parallel->module~pf_mod_pfasst module~pf_mod_parallel->module~pf_mod_dtype module~pf_mod_parallel->module~pf_mod_hooks module~pf_mod_parallel->module~pf_mod_results module~pf_mod_parallel->module~pf_mod_utils module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_parallel->module~pf_mod_interpolate module~pf_mod_restrict pf_mod_restrict module~pf_mod_parallel->module~pf_mod_restrict module~pf_mod_comm pf_mod_comm module~pf_mod_parallel->module~pf_mod_comm module~pf_mod_timer pf_mod_timer module~pf_mod_parallel->module~pf_mod_timer module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_timer module~pf_mod_interpolate->module~pf_mod_dtype module~pf_mod_interpolate->module~pf_mod_hooks module~pf_mod_interpolate->module~pf_mod_utils module~pf_mod_interpolate->module~pf_mod_restrict module~pf_mod_interpolate->module~pf_mod_timer module~pf_mod_restrict->module~pf_mod_dtype module~pf_mod_restrict->module~pf_mod_hooks module~pf_mod_restrict->module~pf_mod_timer module~pf_mod_comm->module~pf_mod_pfasst module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_timer->module~pf_mod_mpi var panmodulepfasstUsesGraph = svgPanZoom('#modulepfasstUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/pfasst.html","title":"pfasst – LibPFASST"},{"text":"Module for reading parameters for the problem Uses pf_mod_dtype pf_mod_utils module~~pf_mod_fftpackage~2~~UsesGraph module~pf_mod_fftpackage~2 pf_mod_fftpackage module~pf_mod_utils pf_mod_utils module~pf_mod_fftpackage~2->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_fftpackage~2->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables two_pi Derived Types pf_fft_t Functions get_wk_ptr_1d get_wk_ptr_2d get_wk_ptr_3d Subroutines fft_setup fft_destroy fftf fftb conv_1d conv_2d conv_3d make_lap_1d make_deriv_1d make_lap_2d make_deriv_2d make_lap_3d make_deriv_3d Variables Type Visibility Attributes Name Initial real(kind=pfdp), public, parameter :: two_pi = 6.2831853071795862_pfdp Derived Types type, public :: pf_fft_t Components Type Visibility Attributes Name Initial integer, public :: nx grid sizes integer, public :: ny grid sizes integer, public :: nz grid sizes integer, public :: dim spatial dimension integer, public :: lensavx workspace lengths integer, public :: lensavy workspace lengths integer, public :: lensavz workspace lengths real(kind=pfdp), public :: Lx domain size real(kind=pfdp), public :: Ly domain size real(kind=pfdp), public :: Lz domain size real(kind=pfdp), public :: normfact normalization factor real(kind=pfdp), public, allocatable :: wsavex (:) real(kind=pfdp), public, allocatable :: wsavey (:) real(kind=pfdp), public, allocatable :: wsavez (:) complex(kind=pfdp), public, pointer :: workhatx (:) complex(kind=pfdp), public, pointer :: workhaty (:) complex(kind=pfdp), public, pointer :: workhatz (:) complex(kind=pfdp), public, pointer :: wk_1d (:) complex(kind=pfdp), public, pointer :: wk_2d (:,:) complex(kind=pfdp), public, pointer :: wk_3d (:,:,:) Type-Bound Procedures procedure, public :: fft_setup procedure, public :: fft_destroy procedure, public :: fftf procedure, public :: fftb generic, public :: conv => conv_1d, conv_2d, conv_3d procedure, public :: get_wk_ptr_1d procedure, public :: get_wk_ptr_2d procedure, public :: get_wk_ptr_3d procedure, public :: make_lap_1d procedure, public :: make_lap_2d procedure, public :: make_lap_3d procedure, public :: make_deriv_1d procedure, public :: make_deriv_2d procedure, public :: make_deriv_3d Functions public function get_wk_ptr_1d (this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:) public function get_wk_ptr_2d (this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:,:) public function get_wk_ptr_3d (this) result(wk) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this Return Value complex(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine fft_setup (this, grid_shape, dim, grid_size) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this integer, intent(in) :: grid_shape (dim) integer, intent(in) :: dim real(kind=pfdp), intent(in), optional :: grid_size (dim) public subroutine fft_destroy (this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine fftf (this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine fftb (this) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this public subroutine conv_1d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:) public subroutine conv_2d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:) public subroutine conv_3d (this, g) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(in) :: g (:,:,:) public subroutine make_lap_1d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:) public subroutine make_deriv_1d (this, ddx) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: ddx (:) public subroutine make_lap_2d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:) public subroutine make_deriv_2d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:) integer, intent(in) :: dir public subroutine make_lap_3d (this, lap) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: lap (:,:,:) public subroutine make_deriv_3d (this, deriv, dir) Arguments Type Intent Optional Attributes Name class( pf_fft_t ), intent(inout) :: this complex(kind=pfdp), intent(inout) :: deriv (:,:,:) integer, intent(in) :: dir","tags":"","loc":"module/pf_mod_fftpackage~2.html","title":"pf_mod_fftpackage – LibPFASST"},{"text":"System of complex N-dimensional arrays encapsulation. When a new solution is created by a PFASST level, this encapsulation\n uses the levels 'arr_shape' attribute to create a new multi-component array with that\n shape.  Thus, the 'arr_shape' attributes of the PFASST levels should be\n set appropriately.  The last component of arr_shape is the number of components in the system For example, before calling pf_pfasst_run we can\n set the arr_shape of the coarsest level by doing: allocate(pf%levels(1)%arr_shape(3))\n   pf%levels(1)%arr_shape = [ nx, ny, 3 ] Which would imply that a 3 component system of two-dimensional solutions. The helper routines array1, array2, array3, etc can be used to\n extract pointers to a component of  encapsulated system\n performing any copies. Uses iso_c_binding pf_mod_dtype module~~pf_mod_zndsysarray~~UsesGraph module~pf_mod_zndsysarray pf_mod_zndsysarray module~pf_mod_dtype pf_mod_dtype module~pf_mod_zndsysarray->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_zndsysarray->iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces zndsysarray_mkdir zndsysarray_dump_numpy Derived Types zndsysarray_factory zndsysarray Functions zndsysarray_norm cast_as_zndsysarray get_array1d get_array2d get_array3d Subroutines zndsysarray_build zndsysarray_create_single zndsysarray_create_array zndsysarray_destroy zndsysarray_destroy_single zndsysarray_destroy_array zndsysarray_setval zndsysarray_copy zndsysarray_pack zndsysarray_unpack zndsysarray_axpy zndsysarray_eprint Interfaces interface Interfaces to output routines in pf_numpy.c public subroutine zndsysarray_mkdir(dname, dlen) bind(c) Subroutine to make a directory for output Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname integer, intent(in), value :: dlen interface Interfaces to output routines in pf_numpy.c public subroutine zndsysarray_dump_numpy(dname, fname, endian, dim, mpibuflen, arr_shape, array) bind(c) Subroutine to write an the array to a file Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: arr_shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Derived Types type, public, extends( pf_factory_t ) :: zndsysarray_factory Type to create and destroy the arrays Type-Bound Procedures procedure, public :: create_single => zndsysarray_create_single procedure, public :: create_array => zndsysarray_create_array procedure, public :: destroy_single => zndsysarray_destroy_single procedure, public :: destroy_array => zndsysarray_destroy_array type, public, extends( pf_encap_t ) :: zndsysarray Type to extend the abstract encap and set procedure pointers Components Type Visibility Attributes Name Initial integer, public :: dim integer, public :: ncomp integer, public :: ndof integer, public, allocatable :: arr_shape (:) complex(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => zndsysarray_setval procedure, public :: copy => zndsysarray_copy procedure, public :: norm => zndsysarray_norm procedure, public :: pack => zndsysarray_pack procedure, public :: unpack => zndsysarray_unpack procedure, public :: axpy => zndsysarray_axpy procedure, public :: eprint => zndsysarray_eprint Functions public function zndsysarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) public function cast_as_zndsysarray (encap_polymorph) result(zndsysarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( zndsysarray ),\n  pointer public function get_array1d (x, n, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:) public function get_array2d (x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:,:) public function get_array3d (x, n, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in) :: n integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine zndsysarray_build (q, arr_shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: arr_shape (:) public subroutine zndsysarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndsysarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndsysarray_destroy (encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap public subroutine zndsysarray_destroy_single (this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndsysarray_destroy_array (this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( zndsysarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndsysarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags public subroutine zndsysarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags public subroutine zndsysarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags public subroutine zndsysarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags public subroutine zndsysarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags public subroutine zndsysarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( zndsysarray ), intent(inout) :: this integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_zndsysarray.html","title":"pf_mod_zndsysarray – LibPFASST"},{"text":"Tommaso Buvoli\n  this module extends pf_sweeper_t and is used for creating an exponential sweeper \n  that solves equations of the form y' = L y + N(t,y) When extending this class, you must supply the functions phib, swpPhib, and resPhib\n  that each compute matrix-vector products of the form \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i in addition to the function f_eval for compluting the nonlinear term N(t,y).\n  The complete description of these three functions is contained below. Uses pf_mod_dtype pf_mod_utils module~~pf_mod_exp~2~~UsesGraph module~pf_mod_exp~2 pf_mod_exp module~pf_mod_utils pf_mod_utils module~pf_mod_exp~2->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_exp~2->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_phib pf_swpPhib pf_resPhib pf_f_eval_p Derived Types pf_exp_t Subroutines exp_initialize exp_sweep exp_integrate exp_residual exp_spreadq0 exp_evaluate exp_evaluate_all exp_destroy LocalDerivsAtNode weights Interfaces interface public subroutine pf_phib(this, t, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y interface public subroutine pf_swpPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y interface public subroutine pf_resPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y interface public subroutine pf_f_eval_p(this, y, t, level, n) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: n Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_exp_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: w (:,:,:) real(kind=pfdp), public, allocatable :: nodes (:) real(kind=pfdp), public, allocatable :: eta (:) class( pf_encap_t ), public, allocatable :: b (:) class( pf_encap_t ), public, allocatable :: f_old (:) class( pf_encap_t ), public, allocatable :: newF logical, public :: use_phib = .TRUE. Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval procedure(pf_phib), public :: phib procedure(pf_swpPhib), public :: swpPhib procedure(pf_resPhib), public :: resPhib procedure, public :: initialize => exp_initialize procedure, public :: sweep => exp_sweep procedure, public :: evaluate => exp_evaluate procedure, public :: integrate => exp_integrate procedure, public :: residual => exp_residual procedure, public :: spreadq0 => exp_spreadq0 procedure, public :: evaluate_all => exp_evaluate_all procedure, public :: destroy => exp_destroy procedure, public :: exp_destroy procedure, public :: exp_initialize Subroutines public subroutine exp_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine exp_sweep (this, pf, level_index, t0, dt, nsweeps, flags) $              !  Now we have to add in the tauQ\n$ Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine exp_integrate (this, lev, qSDC, fSDC, dt, fintsdc, flags) $        call LocalDerivsAtNode(this, 1, nnodes, fSDC(:,1), this%b(2:nnodes+1)) ! compute derivatives\n$        call this%b(1)%setval(real(0.0, pfdp))\n$        call this%b(1)%axpy(real(1.0, pfdp), qSDC(1))\n$        do i = 1, nnodes - 1 ! loop over integrals : compute \\int_{t_{n,i}}&#94;{t_{n, i + 1}}\n$            if (this%use_phib) then\n$                call this%phib(this%nodes(i+1), dt, this%b, fintsdc(i))\n$            else\n$                call this%resPhib(i, dt, this%b, fintsdc(i))\n$             end if\n$        end do Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintsdc (:) Integral from t_n to t_m integer, intent(in), optional :: flags public subroutine exp_residual (this, lev, dt, flags) Compute the integral of F from t_n to t_m at each node Read more… Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags public subroutine exp_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine exp_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine exp_evaluate_all (this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine exp_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level public subroutine LocalDerivsAtNode (this, i, nnodes, N_eval, N_deriv) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: nnodes class( pf_encap_t ), intent(in) :: N_eval (:) class( pf_encap_t ), intent(inout) :: N_deriv (:) public subroutine weights (this, z, x, m, W) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z real(kind=pfdp), intent(in) :: x (:) integer, intent(in) :: m real(kind=pfdp), intent(out) :: W (size(x),m+1)","tags":"","loc":"module/pf_mod_exp~2.html","title":"pf_mod_exp – LibPFASST"},{"text":"Verlet type sweeper for 2nd order problems This is intended for Hamiltonian problems of the form q'=p, p'=f(q) or x'=v, x''=f(x) So p is not momentum here, but velocity Uses pf_mod_dtype pf_mod_utils module~~pf_mod_verlet~~UsesGraph module~pf_mod_verlet pf_mod_verlet module~pf_mod_utils pf_mod_utils module~pf_mod_verlet->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_verlet->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_hamiltonian_p pf_f_eval_p pf_f_comp_p Derived Types pf_verlet_t Subroutines verlet_sweep verlet_initialize verlet_integrate verlet_residual verlet_destroy verlet_spreadq0 verlet_evaluate verlet_evaluate_all Interfaces interface public function pf_hamiltonian_p(this, y, t, level_index) result(H) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Variable real(kind=pfdp), intent(in) :: t Time of solve integer, intent(in) :: level_index Level index Return Value real(kind=pfdp) interface public subroutine pf_f_eval_p(this, y, t, level_index, f) This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_verlet_t Define sweeper type Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq integer, public :: whichQQ = 3 integer, public :: doLU real(kind=pfdp), public :: Htol real(kind=pfdp), public :: H0 real(kind=pfdp), public, ALLOCATABLE :: Qmat (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQmat (:,:) real(kind=pfdp), public, ALLOCATABLE :: Qver (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: Qtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: QQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQQver (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: DQQtil (:,:) real(kind=pfdp), public, ALLOCATABLE :: bvec (:) real(kind=pfdp), public, ALLOCATABLE :: bbarvec (:) real(kind=pfdp), public, allocatable :: dtsdc (:) real(kind=pfdp), public, allocatable :: tsdc (:) logical, public :: iqend class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval RHS function evaluations procedure(pf_f_comp_p), public :: f_comp Implicit solver procedure(pf_hamiltonian_p), public :: hamiltonian Hamiltonian procedure, public :: sweep => verlet_sweep Set the generic functions procedure, public :: initialize => verlet_initialize procedure, public :: evaluate => verlet_evaluate procedure, public :: integrate => verlet_integrate procedure, public :: residual => verlet_residual procedure, public :: spreadq0 => verlet_spreadq0 procedure, public :: evaluate_all => verlet_evaluate_all procedure, public :: destroy => verlet_destroy procedure, public :: verlet_destroy Subroutines public subroutine verlet_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform one SDC sweep on level lev_index and set qend appropriately\n  Assign level pointer\n  Add the integral term Read more… Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine verlet_initialize (this, lev) Initialize integration matrices\n  Array of substep sizes\n$       do i = 1,nnodes\n$          do j = 1,nnodes\n$             this%QQmat(i,j) =  this%bvec(j)*(1.0_pfdp-this%Qmat(j,i)/this%bvec(i))\n$          end do\n$       end do\n$       this%QQmat = matmul(this%QQmat,this%Qmat)\n  Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine verlet_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Integrate (t_n to node) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags public subroutine verlet_residual (this, lev, dt, flags) Compute residual (t_n to node) Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags public subroutine verlet_destroy (this, lev) Destroy Verlet sweeper matrices Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level public subroutine verlet_spreadq0 (this, lev, t0, flags, step) Spread the intial data for Verlet sweepers Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine verlet_evaluate (this, lev, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine verlet_evaluate_all (this, lev, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_verlet_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"module/pf_mod_verlet.html","title":"pf_mod_verlet – LibPFASST"},{"text":"Old style Asynchronous MISDC sweeper Uses pf_mod_dtype pf_mod_utils module~~pf_mod_amisdc~~UsesGraph module~pf_mod_amisdc pf_mod_amisdc module~pf_mod_utils pf_mod_utils module~pf_mod_amisdc->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_amisdc->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_amisdc~~UsedByGraph module~pf_mod_amisdc pf_mod_amisdc module~pf_mod_amisdcq pf_mod_amisdcQ module~pf_mod_amisdcq->module~pf_mod_amisdc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_f1eval_p pf_f2eval_p pf_f2comp_p pf_f3eval_p pf_f3comp_p Derived Types pf_amisdc_t Subroutines amisdc_sweep amisdc_evaluate amisdc_initialize amisdc_destroy amisdc_integrate amisdc_residual amisdc_evaluate_all Interfaces interface public subroutine pf_f1eval_p(this, y, t, level, f1) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f1 interface public subroutine pf_f2eval_p(this, y, t, level, f2) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 interface public subroutine pf_f2comp_p(this, y, t, dt, rhs, level, f2) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f2 interface public subroutine pf_f3eval_p(this, y, t, level, f3) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 interface public subroutine pf_f3comp_p(this, y, t, dt, rhs, level, f3) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f3 Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_amisdc_t Asynchronous multi-implicit sweeper type (old style) Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) Type-Bound Procedures procedure(pf_spreadq0_p), public :: spreadq0 procedure(pf_f1eval_p), public :: f1eval procedure(pf_f2eval_p), public :: f2eval procedure(pf_f2comp_p), public :: f2comp procedure(pf_f3eval_p), public :: f3eval procedure(pf_f3comp_p), public :: f3comp procedure, public :: sweep => amisdc_sweep procedure, public :: initialize => amisdc_initialize procedure, public :: evaluate => amisdc_evaluate procedure, public :: integrate => amisdc_integrate procedure, public :: residual => amisdc_residual procedure, public :: evaluate_all => amisdc_evaluate_all procedure, public :: destroy => amisdc_destroy procedure, public :: amisdc_destroy Subroutines public subroutine amisdc_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine amisdc_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m public subroutine amisdc_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine amisdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine amisdc_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) public subroutine amisdc_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt public subroutine amisdc_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_amisdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:)","tags":"","loc":"module/pf_mod_amisdc.html","title":"pf_mod_amisdc – LibPFASST"},{"text":"Module to do imex SDC sweeps in the optimal control setting Uses pf_mod_dtype pf_mod_utils module~~pf_mod_imexq_oc~~UsesGraph module~pf_mod_imexq_oc pf_mod_imexQ_oc module~pf_mod_utils pf_mod_utils module~pf_mod_imexq_oc->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_imexq_oc->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_imexQ_oc_t Subroutines imexQ_oc_sweep imexQ_oc_evaluate imexQ_oc_evaluate_all imexQ_oc_initialize imexQ_oc_integrate imexQ_oc_residual imexQ_oc_spreadq0 imexQ_oc_destroy Interfaces interface This is the interface for the routine to compute the RHS function values public subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) Evaluae f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags integer, intent(in), optional :: idx integer, intent(in), optional :: step interface This is the interface for the routine to compute the RHS function values public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_imexQ_oc_t IMEX SDC sweeper type for optimal control, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QtilE (:,:) Approximate explcit quadrature rule real(kind=pfdp), public, allocatable :: QtilI (:,:) Approximate implcit quadrature rule real(kind=pfdp), public, allocatable :: dtsdc (:) SDC step sizes real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public, allocatable :: QdiffI (:,:) qmat-QtilI logical, public :: explicit = .true. Is there an explicit piece logical, public :: implicit = .true. Is there an implicit piece class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval RHS function evaluations procedure(pf_f_comp_p), public :: f_comp Implicit solver procedure, public :: sweep => imexQ_oc_sweep Set the generic functions procedure, public :: initialize => imexQ_oc_initialize procedure, public :: evaluate => imexQ_oc_evaluate procedure, public :: integrate => imexQ_oc_integrate procedure, public :: residual => imexQ_oc_residual procedure, public :: evaluate_all => imexQ_oc_evaluate_all procedure, public :: spreadq0 => imexQ_oc_spreadq0 procedure, public :: destroy => imexQ_oc_destroy procedure, public :: imexQ_oc_destroy Subroutines public subroutine imexQ_oc_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Assign level pointer Read more… Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level this is real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine imexQ_oc_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imexQ_oc_evaluate_all (this, lev, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imexQ_oc_initialize (this, lev) Make space for rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine imexQ_oc_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags public subroutine imexQ_oc_residual (this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine imexQ_oc_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imexQ_oc_destroy (this, lev) deallocate Arguments Type Intent Optional Attributes Name class( pf_imexQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev","tags":"","loc":"module/pf_mod_imexq_oc.html","title":"pf_mod_imexQ_oc – LibPFASST"},{"text":"When a new solution is created by a PFASST level, this encapsulation\n uses the levels 'shape' attribute to create a new array with that\n shape.  Thus, the 'shape' attributes of the PFASST levels should be\n set appropriately.  For example, before calling pf_pfasst_run we can\n set the shape of the coarsest level by doing: allocate(pf%levels(1)%shape(2))\n   pf%levels(1)%shape = [ 3, 10 ] The helper routines array1, array2, array3, etc can be used to\n extract pointers to the encapsulated array from a C pointer without\n performing any copies. Uses iso_c_binding pf_mod_dtype pf_mod_utils module~~pf_mod_ndarray_oc~~UsesGraph module~pf_mod_ndarray_oc pf_mod_ndarray_oc module~pf_mod_utils pf_mod_utils module~pf_mod_ndarray_oc->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_ndarray_oc->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_ndarray_oc->iso_c_binding module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces ndarray_mkdir ndarray_dump_numpy Derived Types ndarray_oc_factory ndarray_oc Functions ndarray_oc_norm cast_as_ndarray_oc get_array1d_oc get_array2d_oc get_array3d_oc Subroutines ndarray_oc_build ndarray_oc_create_single ndarray_oc_create_array ndarray_oc_destroy ndarray_oc_destroy_single ndarray_oc_destroy_array ndarray_oc_setval ndarray_oc_copy ndarray_oc_pack ndarray_oc_unpack ndarray_oc_axpy ndarray_oc_dump_hook ndarray_oc_dump_all_hook ndarray_oc_eprint Interfaces interface public subroutine ndarray_mkdir(dname, dlen) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname integer(kind=c_int), intent(in), value :: dlen interface public subroutine ndarray_dump_numpy(dname, fname, endian, dim, shape, nvars, array) bind(c) Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer(kind=c_int), intent(in), value :: dim integer(kind=c_int), intent(in) :: shape (dim) integer(kind=c_int), intent(in), value :: nvars real(kind=pfdp), intent(in) :: array (nvars) Derived Types type, public, extends( pf_factory_t ) :: ndarray_oc_factory Type to create and destroy N-dimenstional arrays for optimal control Type-Bound Procedures procedure, public :: create_single => ndarray_oc_create_single procedure, public :: create_array => ndarray_oc_create_array procedure, public :: destroy_single => ndarray_oc_destroy_single procedure, public :: destroy_array => ndarray_oc_destroy_array type, public, extends( pf_encap_t ) :: ndarray_oc N-dimensional array type for optimal control,  extends the abstract encap type Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) real(kind=pfdp), public, allocatable :: yflatarray (:) real(kind=pfdp), public, allocatable :: pflatarray (:) Type-Bound Procedures procedure, public :: setval => ndarray_oc_setval procedure, public :: copy => ndarray_oc_copy procedure, public :: norm => ndarray_oc_norm procedure, public :: pack => ndarray_oc_pack procedure, public :: unpack => ndarray_oc_unpack procedure, public :: axpy => ndarray_oc_axpy procedure, public :: eprint => ndarray_oc_eprint Functions public function ndarray_oc_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) public function cast_as_ndarray_oc (encap_polymorph) result(ndarray_oc_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndarray_oc ),\n  pointer public function get_array1d_oc (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:) public function get_array2d_oc (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:) public function get_array3d_oc (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine ndarray_oc_build (q, shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) public subroutine ndarray_oc_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_oc_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_oc_destroy (encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap public subroutine ndarray_oc_destroy_single (this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_oc_destroy_array (this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_oc_setval (this, val, flags) Subroutine to set array to a scalar  value. Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags public subroutine ndarray_oc_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags public subroutine ndarray_oc_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags public subroutine ndarray_oc_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags public subroutine ndarray_oc_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags public subroutine ndarray_oc_dump_hook (pf, lev, state) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf type( pf_level_t ), intent(inout) :: lev type( pf_state_t ), intent(in) :: state public subroutine ndarray_oc_dump_all_hook (pf, lev, state) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev type( pf_state_t ), intent(in) :: state public subroutine ndarray_oc_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray_oc ), intent(inout) :: this integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_ndarray_oc.html","title":"pf_mod_ndarray_oc – LibPFASST"},{"text":"Used by module~~pf_mod_mpi~~UsedByGraph module~pf_mod_mpi pf_mod_mpi module~pf_mod_comm_mpi pf_mod_comm_mpi module~pf_mod_comm_mpi->module~pf_mod_mpi proc~pf_mpi_recv_status pf_mpi_recv_status proc~pf_mpi_recv_status->module~pf_mod_mpi proc~pf_mpi_send_status pf_mpi_send_status proc~pf_mpi_send_status->module~pf_mod_mpi proc~pf_mpi_recv pf_mpi_recv proc~pf_mpi_recv->module~pf_mod_mpi proc~pf_mpi_setup pf_mpi_setup proc~pf_mpi_setup->module~pf_mod_mpi proc~pf_mpi_send pf_mpi_send proc~pf_mpi_send->module~pf_mod_mpi module~pf_mod_timer pf_mod_timer module~pf_mod_timer->module~pf_mod_mpi proc~pf_mpi_wait pf_mpi_wait proc~pf_mpi_wait->module~pf_mod_mpi proc~sweep_decoupled_implicit_terms sweep_decoupled_implicit_terms proc~sweep_decoupled_implicit_terms->module~pf_mod_timer proc~sweep_coupled_implicit_terms sweep_coupled_implicit_terms proc~sweep_coupled_implicit_terms->module~pf_mod_timer proc~ark_do_n_steps ark_do_n_steps proc~ark_do_n_steps->module~pf_mod_timer module~pfasst pfasst module~pfasst->module~pf_mod_comm_mpi module~pf_mod_pfasst pf_mod_pfasst module~pfasst->module~pf_mod_pfasst module~pf_mod_parallel pf_mod_parallel module~pfasst->module~pf_mod_parallel module~pf_mod_imexq pf_mod_imexQ module~pfasst->module~pf_mod_imexq module~pf_mod_results pf_mod_results module~pfasst->module~pf_mod_results proc~verlet_sweep verlet_sweep proc~verlet_sweep->module~pf_mod_timer proc~exp_sweep exp_sweep proc~exp_sweep->module~pf_mod_timer module~pf_mod_restrict pf_mod_restrict module~pf_mod_restrict->module~pf_mod_timer module~pf_mod_pfasst->module~pf_mod_comm_mpi module~pf_mod_utils pf_mod_utils module~pf_mod_pfasst->module~pf_mod_utils module~pf_mod_pfasst->module~pf_mod_results proc~mkrk_step mkrk_step proc~mkrk_step->module~pf_mod_timer proc~imk_actually_sweep imk_actually_sweep proc~imk_actually_sweep->module~pf_mod_timer proc~amisdc_sweep amisdc_sweep proc~amisdc_sweep->module~pf_mod_timer proc~misdc_sweep misdc_sweep proc~misdc_sweep->module~pf_mod_timer proc~call_hooks call_hooks proc~call_hooks->module~pf_mod_timer module~pf_mod_utils->module~pf_mod_timer module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_timer module~pf_mod_parallel_oc->module~pf_mod_restrict module~pf_mod_parallel_oc->module~pf_mod_pfasst module~pf_mod_parallel_oc->module~pf_mod_utils module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_parallel_oc->module~pf_mod_interpolate module~pf_mod_comm pf_mod_comm module~pf_mod_parallel_oc->module~pf_mod_comm proc~rk_step rk_step proc~rk_step->module~pf_mod_timer module~pf_mod_parallel->module~pf_mod_timer module~pf_mod_parallel->module~pf_mod_restrict module~pf_mod_parallel->module~pf_mod_pfasst module~pf_mod_parallel->module~pf_mod_utils module~pf_mod_parallel->module~pf_mod_interpolate module~pf_mod_parallel->module~pf_mod_results module~pf_mod_parallel->module~pf_mod_comm module~pf_mod_interpolate->module~pf_mod_timer module~pf_mod_interpolate->module~pf_mod_restrict module~pf_mod_interpolate->module~pf_mod_utils proc~misdcq_oc_sweep misdcQ_oc_sweep proc~misdcq_oc_sweep->module~pf_mod_timer proc~misdcq_sweep misdcQ_sweep proc~misdcq_sweep->module~pf_mod_timer proc~magpicard_sweep magpicard_sweep proc~magpicard_sweep->module~pf_mod_timer proc~amisdcq_sweep amisdcQ_sweep proc~amisdcq_sweep->module~pf_mod_timer proc~imk_sweep imk_sweep proc~imk_sweep->module~pf_mod_timer proc~imexq_sweep imexQ_sweep proc~imexq_sweep->module~pf_mod_timer proc~imexq_oc_sweep imexQ_oc_sweep proc~imexq_oc_sweep->module~pf_mod_timer proc~imex_sweep imex_sweep proc~imex_sweep->module~pf_mod_timer proc~exp_sweep~2 exp_sweep proc~exp_sweep~2->module~pf_mod_timer module~pf_mod_imexq_oc pf_mod_imexQ_oc module~pf_mod_imexq_oc->module~pf_mod_utils module~pf_mod_misdcq pf_mod_misdcQ module~pf_mod_misdcq->module~pf_mod_utils module~pf_mod_amisdc pf_mod_amisdc module~pf_mod_amisdc->module~pf_mod_utils module~pf_mod_zndarray pf_mod_zndarray module~pf_mod_zndarray->module~pf_mod_utils module~pf_mod_rkstepper pf_mod_rkstepper module~pf_mod_rkstepper->module~pf_mod_utils module~pf_mod_fftpackage pf_mod_fftpackage module~pf_mod_fftpackage->module~pf_mod_utils module~pf_mod_imk pf_mod_imk module~pf_mod_imk->module~pf_mod_utils module~pf_mod_imex pf_mod_imex module~pf_mod_imex->module~pf_mod_utils module~pf_mod_ndarray_oc pf_mod_ndarray_oc module~pf_mod_ndarray_oc->module~pf_mod_utils module~pf_mod_fftpackage~2 pf_mod_fftpackage module~pf_mod_fftpackage~2->module~pf_mod_utils module~pf_mod_imexq->module~pf_mod_utils module~pf_mod_results->module~pf_mod_utils module~pf_mod_exp~2 pf_mod_exp module~pf_mod_exp~2->module~pf_mod_utils module~pf_mod_misdcq_oc pf_mod_misdcQ_oc module~pf_mod_misdcq_oc->module~pf_mod_utils module~pf_mod_exp pf_mod_exp module~pf_mod_exp->module~pf_mod_utils module~pf_mod_quadrature pf_mod_quadrature module~pf_mod_quadrature->module~pf_mod_utils proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->module~pf_mod_utils module~pf_mod_verlet pf_mod_verlet module~pf_mod_verlet->module~pf_mod_utils module~pf_mod_ndarray pf_mod_ndarray module~pf_mod_ndarray->module~pf_mod_utils module~pf_mod_misdc pf_mod_misdc module~pf_mod_misdc->module~pf_mod_utils module~pf_mod_comm->module~pf_mod_pfasst module~pf_mod_magnus_picard pf_mod_magnus_picard module~pf_mod_magnus_picard->module~pf_mod_utils proc~pf_level_setup pf_level_setup proc~pf_level_setup->module~pf_mod_quadrature proc~imexq_initialize imexQ_initialize proc~imexq_initialize->module~pf_mod_quadrature proc~pf_level_destroy pf_level_destroy proc~pf_level_destroy->module~pf_mod_quadrature module~pf_mod_amisdcq pf_mod_amisdcQ module~pf_mod_amisdcq->module~pf_mod_amisdc var panmodulepf_mod_mpiUsedByGraph = svgPanZoom('#modulepf_mod_mpiUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/pf_mod_mpi.html","title":"pf_mod_mpi – LibPFASST"},{"text":"Module to implement communication routines in  MPI. Uses pf_mod_dtype pf_mod_mpi module~~pf_mod_comm_mpi~~UsesGraph module~pf_mod_comm_mpi pf_mod_comm_mpi module~pf_mod_mpi pf_mod_mpi module~pf_mod_comm_mpi->module~pf_mod_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_comm_mpi->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_comm_mpi~~UsedByGraph module~pf_mod_comm_mpi pf_mod_comm_mpi module~pfasst pfasst module~pfasst->module~pf_mod_comm_mpi module~pf_mod_pfasst pf_mod_pfasst module~pfasst->module~pf_mod_pfasst module~pf_mod_parallel pf_mod_parallel module~pfasst->module~pf_mod_parallel module~pf_mod_pfasst->module~pf_mod_comm_mpi module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_pfasst module~pf_mod_comm pf_mod_comm module~pf_mod_parallel_oc->module~pf_mod_comm module~pf_mod_comm->module~pf_mod_pfasst module~pf_mod_parallel->module~pf_mod_pfasst module~pf_mod_parallel->module~pf_mod_comm Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables myMPI_Datatype Subroutines pf_mpi_create pf_mpi_setup pf_mpi_destroy pf_mpi_post pf_mpi_send_status pf_mpi_recv_status pf_mpi_send pf_mpi_recv pf_mpi_wait pf_mpi_broadcast Variables Type Visibility Attributes Name Initial integer, public, parameter :: myMPI_Datatype = MPI_REAL8 Subroutines public subroutine pf_mpi_create (pf_comm, mpi_comm) Subroutine to create an MPI based PFASST communicator using the MPI communicator mpi_comm .\n assign communicator Read more… Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(out) :: pf_comm integer, intent(in) :: mpi_comm public subroutine pf_mpi_setup (pf_comm, pf, ierror) Subroutine to set up the PFASST communicator.\n This should be called soon after adding levels to the PFASST controller \n  set the rank Read more… Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(inout) :: pf_comm communicator type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(inout) :: ierror error flag public subroutine pf_mpi_destroy (pf_comm) Subroutine to destroy the PFASST communicator. Arguments Type Intent Optional Attributes Name type( pf_comm_t ), intent(inout) :: pf_comm public subroutine pf_mpi_post (pf, level, tag, ierror, source) Subroutine to post receive requests. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf class( pf_level_t ), intent(inout) :: level level to send from integer, intent(in) :: tag message tag integer, intent(inout) :: ierror error flag integer, intent(in) :: source public subroutine pf_mpi_send_status (pf, tag, istatus, ierror, dest) Subroutine to send convergence status information Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: tag message tag integer, intent(in) :: istatus status flag to send integer, intent(inout) :: ierror error flag integer, intent(in) :: dest public subroutine pf_mpi_recv_status (pf, tag, istatus, ierror, source) Subroutine to receive convergence status information Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: tag message tag integer, intent(inout) :: istatus status flag to receive integer, intent(inout) :: ierror error flag integer, intent(in) :: source public subroutine pf_mpi_send (pf, level, tag, blocking, ierror, dest) Subroutine to send solutions Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: level level to send from integer, intent(in) :: tag message tag logical, intent(in) :: blocking true if send is blocking integer, intent(inout) :: ierror error flag integer, intent(in) :: dest public subroutine pf_mpi_recv (pf, level, tag, blocking, ierror, source) Subroutine to receive solutions\n Note when blocking == .false. this is actually a wait because the\n nonblocking receive  should have already been posted Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: level level to recieve into integer, intent(in) :: tag message tag logical, intent(in) :: blocking true if receive is blocking integer, intent(inout) :: ierror error flag integer, intent(in) :: source public subroutine pf_mpi_wait (pf, level, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf main pfasst structure integer, intent(in) :: level level on which to wait integer, intent(inout) :: ierror error flag public subroutine pf_mpi_broadcast (pf, y, nvar, root, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure real(kind=pfdp), intent(in) :: y (nvar) data to broadcast integer, intent(in) :: nvar size of data to broadcast integer, intent(in) :: root rank of broadcaster integer, intent(inout) :: ierror error flag","tags":"","loc":"module/pf_mod_comm_mpi.html","title":"pf_mod_comm_mpi – LibPFASST"},{"text":"Module containing the routines to create, setup, and destroy the main data structure in PFASST Uses pf_mod_dtype pf_mod_comm_mpi pf_mod_utils pf_mod_results module~~pf_mod_pfasst~~UsesGraph module~pf_mod_pfasst pf_mod_pfasst module~pf_mod_utils pf_mod_utils module~pf_mod_pfasst->module~pf_mod_utils module~pf_mod_comm_mpi pf_mod_comm_mpi module~pf_mod_pfasst->module~pf_mod_comm_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_pfasst->module~pf_mod_dtype module~pf_mod_results pf_mod_results module~pf_mod_pfasst->module~pf_mod_results module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer module~pf_mod_comm_mpi->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_comm_mpi->module~pf_mod_mpi iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_results->module~pf_mod_utils module~pf_mod_results->module~pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_timer->module~pf_mod_mpi var panmodulepf_mod_pfasstUsesGraph = svgPanZoom('#modulepf_mod_pfasstUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_pfasst~~UsedByGraph module~pf_mod_pfasst pf_mod_pfasst module~pfasst pfasst module~pfasst->module~pf_mod_pfasst module~pf_mod_parallel pf_mod_parallel module~pfasst->module~pf_mod_parallel module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_pfasst module~pf_mod_comm pf_mod_comm module~pf_mod_parallel_oc->module~pf_mod_comm module~pf_mod_comm->module~pf_mod_pfasst module~pf_mod_parallel->module~pf_mod_pfasst module~pf_mod_parallel->module~pf_mod_comm Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines pf_pfasst_create pf_pfasst_setup pf_level_setup pf_pfasst_destroy pf_level_destroy pf_read_opts pf_print_options pf_time_interpolation_matrix pf_initialize_results pf_dump_results Subroutines public subroutine pf_pfasst_create (pf, comm, nlevels, fname, nocmd) Create a PFASST object\n gather some input from a file and command line\n  fname  present,  read inputs from a file (and maybe command line)\n  fname not present, only call read_opts if we want command line read\n  set communicator Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Main pfasst object type( pf_comm_t ), intent(inout), target :: comm Communicator integer, intent(in), optional :: nlevels number of pfasst levels character(len=*), intent(in), optional :: fname Input file for pfasst parameters logical, intent(in), optional :: nocmd Determines if command line variables are to be read public subroutine pf_pfasst_setup (pf) Setup both the PFASST object and the comm object\n  loop over levels to set parameters\n  Loop over levels setting interpolation and restriction matrices (in time) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf Main pfasst structure public subroutine pf_level_setup (pf, lev) Setup (allocate) PFASST level\n If the level is already setup, calling this again will allocate\n (or deallocate) tauQ appropriately.\n do some sanity checks\n (re)allocate tauQ (may to need create/destroy tauQ dynamically  when doing AMR)\n skip the rest if we're already allocated\n allocate flat buffers for send, and recv\n allocate nodes, flags, and integration matrices\n  Allocate and compute all the matrices\n  initialize sweeper\n allocate solution and function arrays Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf Main pfasst structure class( pf_level_t ), intent(inout), target :: lev Level to set up public subroutine pf_pfasst_destroy (pf) Deallocate PFASST object\n  destroy all levels\n  deallocate pfasst pointer arrays Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf Main pfasst structure public subroutine pf_level_destroy (lev, nlevels) Deallocate PFASST level\n deallocate flat buffers for communcition\n deallocate nodes, flags, and integration matrices\n deallocate solution and function storage Read more… Arguments Type Intent Optional Attributes Name class( pf_level_t ), intent(inout) :: lev level to destroy integer :: nlevels number of pfasst levels public subroutine pf_read_opts (pf, read_cmd, fname) Subroutine to read pfasst options from file and command line\n define the namelist for reading\n set local variables to pf_pfasst defaults\n open the file \"fname\" and read the pfasst namelist\n overwrite parameters defined on  command line\n re-assign the pfasst internals\n  Sanity check Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf logical, intent(in) :: read_cmd character(len=*), intent(in), optional :: fname public subroutine pf_print_options (pf, un_opt, show_mats_opt) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in), optional :: un_opt logical, intent(in), optional :: show_mats_opt public subroutine pf_time_interpolation_matrix (f_nodes, f_nnodes, c_nodes, c_nnodes, tmat) Subroutine to make the matrices for interpolation  between noodes Arguments Type Intent Optional Attributes Name real(kind=pfdp), intent(in) :: f_nodes (0:f_nnodes-1) quadrature nodes on fine  level integer, intent(in) :: f_nnodes number of nodes on fine level real(kind=pfdp), intent(in) :: c_nodes (0:c_nnodes-1) quadrature nodes on coarse  level integer, intent(in) :: c_nnodes number of nodes on coarse  level real(kind=pfdp), intent(out) :: tmat (0:f_nnodes-1,0:c_nnodes-1) Interpolation matrix to compute public subroutine pf_initialize_results (pf) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf public subroutine pf_dump_results (pf) Subroutine to write out run parameters Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf","tags":"","loc":"module/pf_mod_pfasst.html","title":"pf_mod_pfasst – LibPFASST"},{"text":"Uses pf_mod_dtype pf_mod_utils module~~pf_mod_imex~~UsesGraph module~pf_mod_imex pf_mod_imex module~pf_mod_utils pf_mod_utils module~pf_mod_imex->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_imex->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_imex_t Subroutines imex_sweep imex_evaluate imex_initialize imex_destroy imex_integrate imex_residual imex_spreadq0 imex_evaluate_all Interfaces interface public subroutine pf_f_eval_p(this, y, t, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece interface public subroutine pf_f_comp_p(this, y, t, dt, rhs, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_imex_t IMEX SDC sweeper type (old style), extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval procedure(pf_f_comp_p), public :: f_comp procedure, public :: sweep => imex_sweep procedure, public :: initialize => imex_initialize procedure, public :: evaluate => imex_evaluate procedure, public :: integrate => imex_integrate procedure, public :: residual => imex_residual procedure, public :: spreadq0 => imex_spreadq0 procedure, public :: evaluate_all => imex_evaluate_all procedure, public :: destroy => imex_destroy procedure, public :: imex_destroy Subroutines public subroutine imex_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine imex_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m public subroutine imex_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine imex_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine imex_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) public subroutine imex_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt public subroutine imex_spreadq0 (this, lev, t0) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 public subroutine imex_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_imex_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:)","tags":"","loc":"module/pf_mod_imex.html","title":"pf_mod_imex – LibPFASST"},{"text":"Module for the calling of user defined routines from various places in the pfasst algorithm Uses pf_mod_dtype module~~pf_mod_hooks~~UsesGraph module~pf_mod_hooks pf_mod_hooks module~pf_mod_dtype pf_mod_dtype module~pf_mod_hooks->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_hooks~~UsedByGraph module~pf_mod_hooks pf_mod_hooks proc~exp_sweep exp_sweep proc~exp_sweep->module~pf_mod_hooks module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_interpolate->module~pf_mod_hooks module~pf_mod_restrict pf_mod_restrict module~pf_mod_interpolate->module~pf_mod_restrict module~pf_mod_restrict->module~pf_mod_hooks proc~imexq_oc_sweep imexQ_oc_sweep proc~imexq_oc_sweep->module~pf_mod_hooks proc~mkrk_step mkrk_step proc~mkrk_step->module~pf_mod_hooks proc~imk_actually_sweep imk_actually_sweep proc~imk_actually_sweep->module~pf_mod_hooks proc~ark_do_n_steps ark_do_n_steps proc~ark_do_n_steps->module~pf_mod_hooks module~pfasst pfasst module~pfasst->module~pf_mod_hooks module~pf_mod_parallel pf_mod_parallel module~pfasst->module~pf_mod_parallel proc~magpicard_sweep magpicard_sweep proc~magpicard_sweep->module~pf_mod_hooks proc~pf_pfasst_create pf_pfasst_create proc~pf_pfasst_create->module~pf_mod_hooks module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_hooks module~pf_mod_parallel_oc->module~pf_mod_interpolate module~pf_mod_parallel_oc->module~pf_mod_restrict proc~rk_step rk_step proc~rk_step->module~pf_mod_hooks proc~imk_sweep imk_sweep proc~imk_sweep->module~pf_mod_hooks proc~imexq_sweep imexQ_sweep proc~imexq_sweep->module~pf_mod_hooks proc~misdcq_oc_sweep misdcQ_oc_sweep proc~misdcq_oc_sweep->module~pf_mod_hooks proc~verlet_sweep verlet_sweep proc~verlet_sweep->module~pf_mod_hooks proc~misdcq_sweep misdcQ_sweep proc~misdcq_sweep->module~pf_mod_hooks proc~exp_sweep~2 exp_sweep proc~exp_sweep~2->module~pf_mod_hooks module~pf_mod_parallel->module~pf_mod_hooks module~pf_mod_parallel->module~pf_mod_interpolate module~pf_mod_parallel->module~pf_mod_restrict Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables PF_PRE_PREDICTOR PF_POST_PREDICTOR PF_PRE_ITERATION PF_POST_ITERATION PF_PRE_SWEEP PF_POST_SWEEP PF_PRE_STEP PF_POST_STEP PF_PRE_INTERP_ALL PF_POST_INTERP_ALL PF_PRE_INTERP_Q0 PF_POST_INTERP_Q0 PF_PRE_RESTRICT_ALL PF_POST_RESTRICT_ALL PF_PRE_CONVERGENCE PF_POST_CONVERGENCE PF_MAX_HOOK PF_HOOK_LOG_ONE PF_HOOK_LOG_ALL PF_HOOK_LOG_LAST hook_names Subroutines pf_add_hook call_hooks pf_logger_hook pf_logger_attach Variables Type Visibility Attributes Name Initial integer, public, parameter :: PF_PRE_PREDICTOR = 1 Define hook indices integer, public, parameter :: PF_POST_PREDICTOR = 2 Define hook indices integer, public, parameter :: PF_PRE_ITERATION = 3 Define hook indices integer, public, parameter :: PF_POST_ITERATION = 4 Define hook indices integer, public, parameter :: PF_PRE_SWEEP = 5 Define hook indices integer, public, parameter :: PF_POST_SWEEP = 6 Define hook indices integer, public, parameter :: PF_PRE_STEP = 7 Define hook indices integer, public, parameter :: PF_POST_STEP = 8 Define hook indices integer, public, parameter :: PF_PRE_INTERP_ALL = 9 Define hook indices integer, public, parameter :: PF_POST_INTERP_ALL = 10 Define hook indices integer, public, parameter :: PF_PRE_INTERP_Q0 = 11 Define hook indices integer, public, parameter :: PF_POST_INTERP_Q0 = 12 Define hook indices integer, public, parameter :: PF_PRE_RESTRICT_ALL = 13 Define hook indices integer, public, parameter :: PF_POST_RESTRICT_ALL = 14 Define hook indices integer, public, parameter :: PF_PRE_CONVERGENCE = 15 Define hook indices integer, public, parameter :: PF_POST_CONVERGENCE = 16 Define hook indices integer, public, parameter :: PF_MAX_HOOK = 16 Define hook indices integer, public, parameter :: PF_HOOK_LOG_ONE = 1 integer, public, parameter :: PF_HOOK_LOG_ALL = 7 integer, public, parameter :: PF_HOOK_LOG_LAST = PF_MAX_HOOK character(len=20), public, parameter :: hook_names (PF_HOOK_LOG_LAST) = (/'pre-predictor      ', 'post-predictor     ', 'pre-iteration      ', 'post-iteration     ', 'pre-sweep          ', 'post-sweep         ', 'pre-step           ', 'post-step          ', 'pre-interp-all     ', 'post-interp-all    ', 'pre-interp-q0      ', 'post-interp-q0     ', 'pre-restrict-all   ', 'post-restrict-all  ', 'pre-convergence    ', 'post-convergence   '/) Define hook names Subroutines public subroutine pf_add_hook (pf, level_ind, hook, proc) Subroutine to add a procedure to the hook on the given level Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure integer, intent(in) :: level_ind which pfasst level to add hook integer, intent(in) :: hook which hook to add procedure( pf_hook_p ) :: proc precudre to call from hook public subroutine call_hooks (pf, level_ind, hook) Subroutine to call hooks associated with the hook and level Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf main pfasst structure integer, intent(in) :: level_ind which pfasst level to call hook integer, intent(in) :: hook which hook to call public subroutine pf_logger_hook (pf, level, state) Subroutine defining log hook Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level type( pf_state_t ), intent(in) :: state public subroutine pf_logger_attach (pf) Subroutine to add log hook Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf","tags":"","loc":"module/pf_mod_hooks.html","title":"pf_mod_hooks – LibPFASST"},{"text":"Uses pf_mod_dtype pf_mod_utils module~~pf_mod_misdc~~UsesGraph module~pf_mod_misdc pf_mod_misdc module~pf_mod_utils pf_mod_utils module~pf_mod_misdc->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_misdc->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_misdc_t Subroutines misdc_sweep misdc_evaluate misdc_initialize misdc_destroy misdc_integrate misdc_residual misdc_evaluate_all Interfaces interface public subroutine pf_f_eval_p(this, y, t, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece interface public subroutine pf_f_comp_p(this, y, t, dt, rhs, level, f, piece) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_misdc_t Multi-implicit SDC sweeper type (old style), extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) Type-Bound Procedures procedure(pf_spreadq0_p), public :: spreadq0 procedure(pf_f_eval_p), public :: f_eval procedure(pf_f_comp_p), public :: f_comp procedure, public :: sweep => misdc_sweep procedure, public :: initialize => misdc_initialize procedure, public :: evaluate => misdc_evaluate procedure, public :: integrate => misdc_integrate procedure, public :: residual => misdc_residual procedure, public :: evaluate_all => misdc_evaluate_all procedure, public :: destroy => misdc_destroy procedure, public :: misdc_destroy Subroutines public subroutine misdc_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine misdc_evaluate (this, lev, t, m) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m public subroutine misdc_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine misdc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine misdc_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) public subroutine misdc_residual (this, lev, dt) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt public subroutine misdc_evaluate_all (this, lev, t) Arguments Type Intent Optional Attributes Name class( pf_misdc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:)","tags":"","loc":"module/pf_mod_misdc.html","title":"pf_mod_misdc – LibPFASST"},{"text":"N-dimensional array encapsulation. When a new solution is created by a PFASST level, this encapsulation\n uses the levels 'shape' attribute to create a new array with that\n shape.  Thus, the 'shape' attributes of the PFASST levels should be\n set appropriately.  For example, before calling pf_pfasst_run we can\n set the shape of the coarsest level by doing: allocate(pf%levels(1)%shape(2))\n   pf%levels(1)%shape = [ 3, 10 ] The helper routines array1, array2, array3, etc can be used to\n extract pointers to the encapsulated array without\n performing any copies. Uses iso_c_binding pf_mod_dtype pf_mod_utils module~~pf_mod_ndarray~~UsesGraph module~pf_mod_ndarray pf_mod_ndarray module~pf_mod_utils pf_mod_utils module~pf_mod_ndarray->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_ndarray->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_ndarray->iso_c_binding module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces ndarray_mkdir ndarray_dump_numpy Derived Types ndarray_factory ndarray Functions cast_as_ndarray ndarray_norm get_array1d get_array2d get_array3d Subroutines ndarray_build ndarray_create_single ndarray_create_array ndarray_destroy ndarray_destroy_single ndarray_destroy_array ndarray_setval ndarray_copy ndarray_pack ndarray_unpack ndarray_axpy ndarray_eprint Interfaces interface Interfaces to output routines in pf_numpy.c public subroutine ndarray_mkdir(dname, dlen) bind(c) Subroutine to make a directory for output Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname integer, intent(in), value :: dlen interface Interfaces to output routines in pf_numpy.c public subroutine ndarray_dump_numpy(dname, fname, endian, dim, mpibuflen, shape, array) bind(c) Subroutine to write an the array to a file Arguments Type Intent Optional Attributes Name character(len=c_char), intent(in) :: dname character(len=c_char), intent(in) :: fname character(len=c_char), intent(in) :: endian (5) integer, intent(in), value :: dim integer, intent(in), value :: mpibuflen integer, intent(in) :: shape (dim) real(kind=c_double), intent(in) :: array (mpibuflen) Derived Types type, public, extends( pf_factory_t ) :: ndarray_factory Type to create and destroy N-dimenstional arrays Type-Bound Procedures procedure, public :: create_single => ndarray_create_single procedure, public :: create_array => ndarray_create_array procedure, public :: destroy_single => ndarray_destroy_single procedure, public :: destroy_array => ndarray_destroy_array type, public, extends( pf_encap_t ) :: ndarray N-dimensional array type,  extends the abstract encap type Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) real(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => ndarray_setval procedure, public :: copy => ndarray_copy procedure, public :: norm => ndarray_norm procedure, public :: pack => ndarray_pack procedure, public :: unpack => ndarray_unpack procedure, public :: axpy => ndarray_axpy procedure, public :: eprint => ndarray_eprint Functions public function cast_as_ndarray (encap_polymorph) result(ndarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( ndarray ),\n  pointer public function ndarray_norm (this, flags) result(norm) Subroutine to define the norm of the array (here the max norm) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) public function get_array1d (x, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:) public function get_array2d (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:) public function get_array3d (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value real(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine ndarray_build (q, shape) Subroutine to allocate the array and set the size parameters Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) public subroutine ndarray_create_single (this, x, level, shape) Subroutine to  create a single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_create_array (this, x, n, level, shape) Subroutine to create an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_destroy (encap) Subroutine to destroy array Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap public subroutine ndarray_destroy_single (this, x, level, shape) Subroutine to destroy an single array Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_destroy_array (this, x, n, level, shape) Subroutine to destroy an array of arrays Arguments Type Intent Optional Attributes Name class( ndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine ndarray_setval (this, val, flags) The following are the base subroutines that all encapsulations must provide Read more… Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags public subroutine ndarray_copy (this, src, flags) Subroutine to copy an array Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags public subroutine ndarray_pack (this, z, flags) Subroutine to pack an array into a flat array for sending Arguments Type Intent Optional Attributes Name class( ndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags public subroutine ndarray_unpack (this, z, flags) Subroutine to unpack a flatarray after receiving Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags public subroutine ndarray_axpy (this, a, x, flags) Subroutine to compute y = a x + y where a is a scalar and x and y are arrays Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags public subroutine ndarray_eprint (this, flags) Subroutine to print the array to the screen (mainly for debugging purposes) Arguments Type Intent Optional Attributes Name class( ndarray ), intent(inout) :: this integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_ndarray.html","title":"pf_mod_ndarray – LibPFASST"},{"text":"Module for the storing results for eventual output Uses pf_mod_dtype pf_mod_utils module~~pf_mod_results~~UsesGraph module~pf_mod_results pf_mod_results module~pf_mod_utils pf_mod_utils module~pf_mod_results->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_results->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_results~~UsedByGraph module~pf_mod_results pf_mod_results module~pfasst pfasst module~pfasst->module~pf_mod_results module~pf_mod_pfasst pf_mod_pfasst module~pfasst->module~pf_mod_pfasst module~pf_mod_parallel pf_mod_parallel module~pfasst->module~pf_mod_parallel module~pf_mod_pfasst->module~pf_mod_results module~pf_mod_parallel->module~pf_mod_results module~pf_mod_parallel->module~pf_mod_pfasst module~pf_mod_comm pf_mod_comm module~pf_mod_parallel->module~pf_mod_comm module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_pfasst module~pf_mod_parallel_oc->module~pf_mod_comm module~pf_mod_comm->module~pf_mod_pfasst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines initialize_results dump_results dump_timings destroy_results Subroutines public subroutine initialize_results (this, nsteps_in, niters_in, nprocs_in, nsweeps_in, rank_in, lev_ind) Arguments Type Intent Optional Attributes Name class( pf_results_t ), intent(inout) :: this integer, intent(in) :: nsteps_in integer, intent(in) :: niters_in integer, intent(in) :: nprocs_in integer, intent(in) :: nsweeps_in integer, intent(in) :: rank_in integer, intent(in) :: lev_ind public subroutine dump_results (this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this public subroutine dump_timings (pf) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf public subroutine destroy_results (this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this","tags":"","loc":"module/pf_mod_results.html","title":"pf_mod_results – LibPFASST"},{"text":"Module to do interpolation between pfasst levels Uses pf_mod_dtype pf_mod_restrict pf_mod_timer pf_mod_hooks pf_mod_utils module~~pf_mod_interpolate~~UsesGraph module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_utils pf_mod_utils module~pf_mod_interpolate->module~pf_mod_utils module~pf_mod_restrict pf_mod_restrict module~pf_mod_interpolate->module~pf_mod_restrict module~pf_mod_dtype pf_mod_dtype module~pf_mod_interpolate->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_interpolate->module~pf_mod_timer module~pf_mod_hooks pf_mod_hooks module~pf_mod_interpolate->module~pf_mod_hooks module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_timer module~pf_mod_restrict->module~pf_mod_dtype module~pf_mod_restrict->module~pf_mod_timer module~pf_mod_restrict->module~pf_mod_hooks iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_hooks->module~pf_mod_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_interpolate~~UsedByGraph module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_interpolate module~pf_mod_parallel pf_mod_parallel module~pf_mod_parallel->module~pf_mod_interpolate module~pfasst pfasst module~pfasst->module~pf_mod_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines interpolate_time_space interpolate_q0 interpolate_qend Subroutines public subroutine interpolate_time_space (pf, t0, dt, level_index, F_INTERP, flags) Subroutine to interpolate (in time and space) level_index-1 to level_index\n Interpolation is done by interpolating increments. The fine function values are re-evaluated after interpolation.\n create workspaces\n set time at coarse and fine nodes\n  interpolate coarse level correction in space only\n interpolate corrections in time Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf main pfasst structure real(kind=pfdp), intent(in) :: t0 time at beginning of time interval real(kind=pfdp), intent(in) :: dt time step integer, intent(in) :: level_index defines which level to interpolate to logical, intent(in) :: F_INTERP Flag, if true, then do interp on f not sol integer, intent(in), optional :: flags public subroutine interpolate_q0 (pf, f_lev_ptr, c_lev_ptr, flags) Subroutine to update the fine initial condition from coarse increment by spatial interpolation Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: f_lev_ptr fine level class( pf_level_t ), intent(inout) :: c_lev_ptr coarse level integer, intent(in), optional :: flags public subroutine interpolate_qend (pf, f_lev_ptr, c_lev_ptr) Subroutine to update the fine terminal condition from coarse increment by spatial interpolation\n  used for adjoint solver Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf main pfasst structure class( pf_level_t ), intent(inout) :: f_lev_ptr fine level class( pf_level_t ), intent(inout) :: c_lev_ptr coarse level","tags":"","loc":"module/pf_mod_interpolate.html","title":"pf_mod_interpolate – LibPFASST"},{"text":"N-dimensional complex array encapsulation. When a new solution is created by a PFASST level, this encapsulation\n uses the levels 'shape' attribute to create a new array with that\n shape.  Thus, the 'shape' attributes of the PFASST levels should be\n set appropriately.  For example, before calling pf_pfasst_run we can\n set the shape of the coarsest level by doing: allocate(pf%levels(1)%shape(2))\n   pf%levels(1)%shape = [ 3, 10 ] The helper routines array1, array2, array3, etc can be used to\n extract pointers to the encapsulated array  without\n performing any copies. Uses iso_c_binding pf_mod_dtype pf_mod_utils module~~pf_mod_zndarray~~UsesGraph module~pf_mod_zndarray pf_mod_zndarray module~pf_mod_utils pf_mod_utils module~pf_mod_zndarray->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_zndarray->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_zndarray->iso_c_binding module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types zndarray_factory zndarray Functions cast_as_zndarray zndarray_norm get_array1d get_array2d get_array3d Subroutines zndarray_build zndarray_destroy zndarray_create_single zndarray_create_array zndarray_destroy_single zndarray_destroy_array zndarray_setval zndarray_copy zndarray_pack zndarray_unpack zndarray_axpy zndarray_eprint write_to_disk Derived Types type, public, extends( pf_factory_t ) :: zndarray_factory Type-Bound Procedures procedure, public :: create_single => zndarray_create_single procedure, public :: create_array => zndarray_create_array procedure, public :: destroy_single => zndarray_destroy_single procedure, public :: destroy_array => zndarray_destroy_array type, public, extends( pf_encap_t ) :: zndarray Components Type Visibility Attributes Name Initial integer, public :: dim integer, public, allocatable :: shape (:) complex(kind=pfdp), public, allocatable :: flatarray (:) Type-Bound Procedures procedure, public :: setval => zndarray_setval procedure, public :: copy => zndarray_copy procedure, public :: norm => zndarray_norm procedure, public :: pack => zndarray_pack procedure, public :: unpack => zndarray_unpack procedure, public :: axpy => zndarray_axpy procedure, public :: eprint => zndarray_eprint procedure, public :: write_to_disk Functions public function cast_as_zndarray (encap_polymorph) result(zndarray_obj) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: encap_polymorph Return Value type( zndarray ),\n  pointer public function zndarray_norm (this, flags) result(norm) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) public function get_array1d (x, flags) result(r) Helper function to return the array part Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in), target :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:) public function get_array2d (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:,:) public function get_array3d (x, flags) result(r) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags Return Value complex(kind=pfdp),\n  pointer, (:,:,:) Subroutines public subroutine zndarray_build (q, shape) Allocates complex ndarray Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: q integer, intent(in) :: shape (:) public subroutine zndarray_destroy (encap) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: encap public subroutine zndarray_create_single (this, x, level, shape) Wrapper routine for allocation of a single zndarray type array Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndarray_create_array (this, x, n, level, shape) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndarray_destroy_single (this, x, level, shape) Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndarray_destroy_array (this, x, n, level, shape) Wrapper routine for looped allocation of many zndarray type arrays Arguments Type Intent Optional Attributes Name class( zndarray_factory ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) public subroutine zndarray_setval (this, val, flags) Set solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags public subroutine zndarray_copy (this, src, flags) Copy solution value. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags public subroutine zndarray_pack (this, z, flags) Pack solution q into a flat array. Arguments Type Intent Optional Attributes Name class( zndarray ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags public subroutine zndarray_unpack (this, z, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags public subroutine zndarray_axpy (this, a, x, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags public subroutine zndarray_eprint (this, flags) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this integer, intent(in), optional :: flags public subroutine write_to_disk (this, filename) Arguments Type Intent Optional Attributes Name class( zndarray ), intent(inout) :: this character(len=*), intent(in) :: filename","tags":"","loc":"module/pf_mod_zndarray.html","title":"pf_mod_zndarray – LibPFASST"},{"text":"Module to do Runge-Kutta stepping Uses pf_mod_dtype pf_mod_utils module~~pf_mod_rkstepper~~UsesGraph module~pf_mod_rkstepper pf_mod_rkstepper module~pf_mod_utils pf_mod_utils module~pf_mod_rkstepper->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_rkstepper->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_ark_t Subroutines ark_do_n_steps ark_initialize ark_destroy Interfaces interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: dtq class( pf_encap_t ), intent(in) :: rhs integer, intent(in) :: level_index class( pf_encap_t ), intent(inout) :: f integer, intent(in) :: piece Derived Types type, public, abstract, extends( pf_stepper_t ) :: pf_ark_t IMEX or additive or semi-implicit Runge-Kutta stepper  type Components Type Visibility Attributes Name Initial integer, public :: npieces integer, public :: order real(kind=pfdp), public, allocatable :: AmatI (:,:) real(kind=pfdp), public, allocatable :: AmatE (:,:) real(kind=pfdp), public, allocatable :: cvec (:) real(kind=pfdp), public, allocatable :: bvecI (:) real(kind=pfdp), public, allocatable :: bvecE (:) real(kind=pfdp), public, allocatable :: QtilI (:,:) logical, public :: explicit = .true. logical, public :: implicit = .true. integer, public :: nstages Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval procedure(pf_f_comp_p), public :: f_comp procedure, public :: do_n_steps => ark_do_n_steps procedure, public :: initialize => ark_initialize procedure, public :: destroy => ark_destroy Subroutines public subroutine ark_do_n_steps (this, pf, level_index, t0, big_dt, nsteps_rk) Perform N steps of ark on level level_index and set qend appropriately.\n Assign pointer to appropriate level Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index Level of the index to step on real(kind=pfdp), intent(in) :: t0 Time at start of time interval real(kind=pfdp), intent(in) :: big_dt Size of time interval to integrato on integer, intent(in) :: nsteps_rk Number of steps to use public subroutine ark_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine ark_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_ark_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev","tags":"","loc":"module/pf_mod_rkstepper.html","title":"pf_mod_rkstepper – LibPFASST"},{"text":"Module for setting timers Uses pf_mod_dtype pf_mod_mpi module~~pf_mod_timer~~UsesGraph module~pf_mod_timer pf_mod_timer module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_timer~~UsedByGraph module~pf_mod_timer pf_mod_timer proc~sweep_decoupled_implicit_terms sweep_decoupled_implicit_terms proc~sweep_decoupled_implicit_terms->module~pf_mod_timer proc~sweep_coupled_implicit_terms sweep_coupled_implicit_terms proc~sweep_coupled_implicit_terms->module~pf_mod_timer proc~ark_do_n_steps ark_do_n_steps proc~ark_do_n_steps->module~pf_mod_timer proc~verlet_sweep verlet_sweep proc~verlet_sweep->module~pf_mod_timer proc~exp_sweep exp_sweep proc~exp_sweep->module~pf_mod_timer module~pf_mod_restrict pf_mod_restrict module~pf_mod_restrict->module~pf_mod_timer proc~mkrk_step mkrk_step proc~mkrk_step->module~pf_mod_timer proc~imk_actually_sweep imk_actually_sweep proc~imk_actually_sweep->module~pf_mod_timer proc~amisdc_sweep amisdc_sweep proc~amisdc_sweep->module~pf_mod_timer proc~misdc_sweep misdc_sweep proc~misdc_sweep->module~pf_mod_timer proc~call_hooks call_hooks proc~call_hooks->module~pf_mod_timer module~pf_mod_utils pf_mod_utils module~pf_mod_utils->module~pf_mod_timer module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_timer module~pf_mod_parallel_oc->module~pf_mod_restrict module~pf_mod_parallel_oc->module~pf_mod_utils module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_parallel_oc->module~pf_mod_interpolate module~pf_mod_pfasst pf_mod_pfasst module~pf_mod_parallel_oc->module~pf_mod_pfasst module~pf_mod_comm pf_mod_comm module~pf_mod_parallel_oc->module~pf_mod_comm proc~rk_step rk_step proc~rk_step->module~pf_mod_timer module~pf_mod_parallel pf_mod_parallel module~pf_mod_parallel->module~pf_mod_timer module~pf_mod_parallel->module~pf_mod_restrict module~pf_mod_parallel->module~pf_mod_utils module~pf_mod_parallel->module~pf_mod_interpolate module~pf_mod_parallel->module~pf_mod_pfasst module~pf_mod_results pf_mod_results module~pf_mod_parallel->module~pf_mod_results module~pf_mod_parallel->module~pf_mod_comm module~pf_mod_interpolate->module~pf_mod_timer module~pf_mod_interpolate->module~pf_mod_restrict module~pf_mod_interpolate->module~pf_mod_utils proc~misdcq_oc_sweep misdcQ_oc_sweep proc~misdcq_oc_sweep->module~pf_mod_timer proc~misdcq_sweep misdcQ_sweep proc~misdcq_sweep->module~pf_mod_timer proc~magpicard_sweep magpicard_sweep proc~magpicard_sweep->module~pf_mod_timer proc~amisdcq_sweep amisdcQ_sweep proc~amisdcq_sweep->module~pf_mod_timer proc~imk_sweep imk_sweep proc~imk_sweep->module~pf_mod_timer proc~imexq_sweep imexQ_sweep proc~imexq_sweep->module~pf_mod_timer proc~imexq_oc_sweep imexQ_oc_sweep proc~imexq_oc_sweep->module~pf_mod_timer proc~imex_sweep imex_sweep proc~imex_sweep->module~pf_mod_timer proc~exp_sweep~2 exp_sweep proc~exp_sweep~2->module~pf_mod_timer module~pf_mod_imexq_oc pf_mod_imexQ_oc module~pf_mod_imexq_oc->module~pf_mod_utils module~pf_mod_misdcq pf_mod_misdcQ module~pf_mod_misdcq->module~pf_mod_utils module~pfasst pfasst module~pfasst->module~pf_mod_parallel module~pfasst->module~pf_mod_pfasst module~pf_mod_imexq pf_mod_imexQ module~pfasst->module~pf_mod_imexq module~pfasst->module~pf_mod_results module~pf_mod_amisdc pf_mod_amisdc module~pf_mod_amisdc->module~pf_mod_utils module~pf_mod_zndarray pf_mod_zndarray module~pf_mod_zndarray->module~pf_mod_utils module~pf_mod_pfasst->module~pf_mod_utils module~pf_mod_pfasst->module~pf_mod_results module~pf_mod_rkstepper pf_mod_rkstepper module~pf_mod_rkstepper->module~pf_mod_utils module~pf_mod_fftpackage pf_mod_fftpackage module~pf_mod_fftpackage->module~pf_mod_utils module~pf_mod_imk pf_mod_imk module~pf_mod_imk->module~pf_mod_utils module~pf_mod_imex pf_mod_imex module~pf_mod_imex->module~pf_mod_utils module~pf_mod_ndarray_oc pf_mod_ndarray_oc module~pf_mod_ndarray_oc->module~pf_mod_utils module~pf_mod_fftpackage~2 pf_mod_fftpackage module~pf_mod_fftpackage~2->module~pf_mod_utils module~pf_mod_imexq->module~pf_mod_utils module~pf_mod_results->module~pf_mod_utils module~pf_mod_exp~2 pf_mod_exp module~pf_mod_exp~2->module~pf_mod_utils module~pf_mod_misdcq_oc pf_mod_misdcQ_oc module~pf_mod_misdcq_oc->module~pf_mod_utils module~pf_mod_exp pf_mod_exp module~pf_mod_exp->module~pf_mod_utils module~pf_mod_quadrature pf_mod_quadrature module~pf_mod_quadrature->module~pf_mod_utils proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->module~pf_mod_utils module~pf_mod_verlet pf_mod_verlet module~pf_mod_verlet->module~pf_mod_utils module~pf_mod_ndarray pf_mod_ndarray module~pf_mod_ndarray->module~pf_mod_utils module~pf_mod_misdc pf_mod_misdc module~pf_mod_misdc->module~pf_mod_utils module~pf_mod_magnus_picard pf_mod_magnus_picard module~pf_mod_magnus_picard->module~pf_mod_utils proc~pf_level_setup pf_level_setup proc~pf_level_setup->module~pf_mod_quadrature proc~imexq_initialize imexQ_initialize proc~imexq_initialize->module~pf_mod_quadrature proc~pf_level_destroy pf_level_destroy proc~pf_level_destroy->module~pf_mod_quadrature module~pf_mod_comm->module~pf_mod_pfasst module~pf_mod_amisdcq pf_mod_amisdcQ module~pf_mod_amisdcq->module~pf_mod_amisdc var panmodulepf_mod_timerUsedByGraph = svgPanZoom('#modulepf_mod_timerUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables TTOTAL TPREDICTOR TITERATION THOOKS TSTEP TRESIDUAL TBROADCAST TINTERPOLATE TRESTRICT TRECEIVE TSEND TLEVEL TAUX timer_names Subroutines start_timer end_timer Variables Type Visibility Attributes Name Initial integer, public, parameter :: TTOTAL = 1 integer, public, parameter :: TPREDICTOR = 2 integer, public, parameter :: TITERATION = 3 integer, public, parameter :: THOOKS = 4 integer, public, parameter :: TSTEP = 5 integer, public, parameter :: TRESIDUAL = 6 integer, public, parameter :: TBROADCAST = 7 integer, public, parameter :: TINTERPOLATE = 10 integer, public, parameter :: TRESTRICT = 20 integer, public, parameter :: TRECEIVE = 30 integer, public, parameter :: TSEND = 40 integer, public, parameter :: TLEVEL = 50 integer, public, parameter :: TAUX = 60 character(len=14), public, parameter :: timer_names (62) = (/'total       ', 'predictor   ', 'iteration   ', 'hooks       ', 'step        ', 'residual    ', 'broadcast   ', '8           ', '9           ', 'interpL1    ', 'interpL2    ', 'interpL3    ', 'interpL4    ', 'interpL5    ', 'interpL6    ', 'interpL7    ', 'interpL8    ', 'interpL9    ', 'interpL10   ', 'restrictL1  ', 'restrictL2  ', 'restrictL3  ', 'restrictL4  ', 'restrictL5  ', 'restrictL6  ', 'restrictL7  ', 'restrictL8  ', 'restrictL9  ', 'restrictL10 ', 'recvL1      ', 'recvL2      ', 'recvL3      ', 'recvL4      ', 'recvL5      ', 'recvL6      ', 'recvL7      ', 'recvL8      ', 'recvL9      ', 'recvL10     ', 'sendL1      ', 'sendL2      ', 'sendL3      ', 'sendL4      ', 'sendL5      ', 'sendL6      ', 'sendL7      ', 'sendL8      ', 'sendL9      ', 'sendL10     ', 'sweepL1     ', 'sweepL2     ', 'sweepL3     ', 'sweepL4     ', 'sweepL5     ', 'sweepL6     ', 'sweepL7     ', 'sweepL8     ', 'sweepL9     ', 'sweepL10    ', 'exp         ', 'omega       ', 'feval       '/) Subroutines public subroutine start_timer (pf, timer) Subroutine to start a timer Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: timer public subroutine end_timer (pf, timer) Subroutine to stop a timer Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: timer","tags":"","loc":"module/pf_mod_timer.html","title":"pf_mod_timer – LibPFASST"},{"text":"Module to define the main parameters, data types, and interfaces in pfasst Uses iso_c_binding module~~pf_mod_dtype~~UsesGraph module~pf_mod_dtype pf_mod_dtype iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_dtype~~UsedByGraph module~pf_mod_dtype pf_mod_dtype module~pf_mod_fftpackage pf_mod_fftpackage module~pf_mod_fftpackage->module~pf_mod_dtype module~pf_mod_utils pf_mod_utils module~pf_mod_fftpackage->module~pf_mod_utils module~pf_mod_imexq_oc pf_mod_imexQ_oc module~pf_mod_imexq_oc->module~pf_mod_dtype module~pf_mod_imexq_oc->module~pf_mod_utils module~pf_mod_misdcq pf_mod_misdcQ module~pf_mod_misdcq->module~pf_mod_dtype module~pf_mod_misdcq->module~pf_mod_utils module~pfasst pfasst module~pfasst->module~pf_mod_dtype module~pf_mod_pfasst pf_mod_pfasst module~pfasst->module~pf_mod_pfasst module~pf_mod_imexq pf_mod_imexQ module~pfasst->module~pf_mod_imexq module~pf_mod_results pf_mod_results module~pfasst->module~pf_mod_results module~pf_mod_comm_mpi pf_mod_comm_mpi module~pfasst->module~pf_mod_comm_mpi module~pf_mod_parallel pf_mod_parallel module~pfasst->module~pf_mod_parallel module~pf_mod_hooks pf_mod_hooks module~pfasst->module~pf_mod_hooks module~pf_mod_amisdc pf_mod_amisdc module~pf_mod_amisdc->module~pf_mod_dtype module~pf_mod_amisdc->module~pf_mod_utils module~pf_mod_zndarray pf_mod_zndarray module~pf_mod_zndarray->module~pf_mod_dtype module~pf_mod_zndarray->module~pf_mod_utils module~pf_mod_restrict pf_mod_restrict module~pf_mod_restrict->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_restrict->module~pf_mod_timer module~pf_mod_restrict->module~pf_mod_hooks module~pf_mod_pfasst->module~pf_mod_dtype module~pf_mod_pfasst->module~pf_mod_utils module~pf_mod_pfasst->module~pf_mod_results module~pf_mod_pfasst->module~pf_mod_comm_mpi proc~imk_evaluate imk_evaluate proc~imk_evaluate->module~pf_mod_dtype module~pf_mod_rkstepper pf_mod_rkstepper module~pf_mod_rkstepper->module~pf_mod_dtype module~pf_mod_rkstepper->module~pf_mod_utils module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_imk pf_mod_imk module~pf_mod_imk->module~pf_mod_dtype module~pf_mod_imk->module~pf_mod_utils proc~amisdc_evaluate amisdc_evaluate proc~amisdc_evaluate->module~pf_mod_dtype module~pf_mod_imex pf_mod_imex module~pf_mod_imex->module~pf_mod_dtype module~pf_mod_imex->module~pf_mod_utils proc~magpicard_evaluate magpicard_evaluate proc~magpicard_evaluate->module~pf_mod_dtype module~pf_mod_ndarray_oc pf_mod_ndarray_oc module~pf_mod_ndarray_oc->module~pf_mod_dtype module~pf_mod_ndarray_oc->module~pf_mod_utils module~pf_mod_fftpackage~2 pf_mod_fftpackage module~pf_mod_fftpackage~2->module~pf_mod_dtype module~pf_mod_fftpackage~2->module~pf_mod_utils module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_timer module~pf_mod_imexq->module~pf_mod_dtype module~pf_mod_imexq->module~pf_mod_utils module~pf_mod_results->module~pf_mod_dtype module~pf_mod_results->module~pf_mod_utils module~pf_mod_exp~2 pf_mod_exp module~pf_mod_exp~2->module~pf_mod_dtype module~pf_mod_exp~2->module~pf_mod_utils module~pf_mod_zndsysarray pf_mod_zndsysarray module~pf_mod_zndsysarray->module~pf_mod_dtype module~pf_mod_ndsysarray pf_mod_ndsysarray module~pf_mod_ndsysarray->module~pf_mod_dtype module~pf_mod_comm_mpi->module~pf_mod_dtype module~pf_mod_exp pf_mod_exp module~pf_mod_exp->module~pf_mod_dtype module~pf_mod_exp->module~pf_mod_utils module~pf_mod_misdcq_oc pf_mod_misdcQ_oc module~pf_mod_misdcq_oc->module~pf_mod_dtype module~pf_mod_misdcq_oc->module~pf_mod_utils module~pf_mod_quadrature pf_mod_quadrature module~pf_mod_quadrature->module~pf_mod_dtype module~pf_mod_quadrature->module~pf_mod_utils module~pf_mod_verlet pf_mod_verlet module~pf_mod_verlet->module~pf_mod_dtype module~pf_mod_verlet->module~pf_mod_utils module~pf_mod_parallel->module~pf_mod_dtype module~pf_mod_parallel->module~pf_mod_restrict module~pf_mod_parallel->module~pf_mod_pfasst module~pf_mod_parallel->module~pf_mod_timer module~pf_mod_parallel->module~pf_mod_utils module~pf_mod_parallel->module~pf_mod_results module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_parallel->module~pf_mod_interpolate module~pf_mod_parallel->module~pf_mod_hooks module~pf_mod_comm pf_mod_comm module~pf_mod_parallel->module~pf_mod_comm module~pf_mod_interpolate->module~pf_mod_dtype module~pf_mod_interpolate->module~pf_mod_restrict module~pf_mod_interpolate->module~pf_mod_timer module~pf_mod_interpolate->module~pf_mod_utils module~pf_mod_interpolate->module~pf_mod_hooks module~pf_mod_misdc pf_mod_misdc module~pf_mod_misdc->module~pf_mod_dtype module~pf_mod_misdc->module~pf_mod_utils proc~misdc_evaluate misdc_evaluate proc~misdc_evaluate->module~pf_mod_dtype module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_dtype module~pf_mod_parallel_oc->module~pf_mod_restrict module~pf_mod_parallel_oc->module~pf_mod_pfasst module~pf_mod_parallel_oc->module~pf_mod_timer module~pf_mod_parallel_oc->module~pf_mod_utils module~pf_mod_parallel_oc->module~pf_mod_interpolate module~pf_mod_parallel_oc->module~pf_mod_hooks module~pf_mod_parallel_oc->module~pf_mod_comm module~pf_mod_magnus_picard pf_mod_magnus_picard module~pf_mod_magnus_picard->module~pf_mod_dtype module~pf_mod_magnus_picard->module~pf_mod_utils module~pf_mod_ndarray pf_mod_ndarray module~pf_mod_ndarray->module~pf_mod_dtype module~pf_mod_ndarray->module~pf_mod_utils module~pf_mod_hooks->module~pf_mod_dtype proc~sweep_decoupled_implicit_terms sweep_decoupled_implicit_terms proc~sweep_decoupled_implicit_terms->module~pf_mod_timer proc~sweep_coupled_implicit_terms sweep_coupled_implicit_terms proc~sweep_coupled_implicit_terms->module~pf_mod_timer proc~pf_level_destroy pf_level_destroy proc~pf_level_destroy->module~pf_mod_quadrature proc~ark_do_n_steps ark_do_n_steps proc~ark_do_n_steps->module~pf_mod_timer proc~ark_do_n_steps->module~pf_mod_hooks proc~verlet_sweep verlet_sweep proc~verlet_sweep->module~pf_mod_timer proc~verlet_sweep->module~pf_mod_hooks proc~exp_sweep exp_sweep proc~exp_sweep->module~pf_mod_timer proc~exp_sweep->module~pf_mod_hooks proc~mkrk_step mkrk_step proc~mkrk_step->module~pf_mod_timer proc~mkrk_step->module~pf_mod_hooks module~pf_mod_amisdcq pf_mod_amisdcQ module~pf_mod_amisdcq->module~pf_mod_amisdc proc~amisdc_sweep amisdc_sweep proc~amisdc_sweep->module~pf_mod_timer proc~imexq_initialize imexQ_initialize proc~imexq_initialize->module~pf_mod_quadrature proc~misdc_sweep misdc_sweep proc~misdc_sweep->module~pf_mod_timer proc~pf_pfasst_create pf_pfasst_create proc~pf_pfasst_create->module~pf_mod_hooks proc~call_hooks call_hooks proc~call_hooks->module~pf_mod_timer proc~pf_level_setup pf_level_setup proc~pf_level_setup->module~pf_mod_quadrature proc~amisdcq_sweep amisdcQ_sweep proc~amisdcq_sweep->module~pf_mod_timer proc~rk_step rk_step proc~rk_step->module~pf_mod_timer proc~rk_step->module~pf_mod_hooks proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->module~pf_mod_utils proc~imexq_oc_sweep imexQ_oc_sweep proc~imexq_oc_sweep->module~pf_mod_timer proc~imexq_oc_sweep->module~pf_mod_hooks proc~imk_actually_sweep imk_actually_sweep proc~imk_actually_sweep->module~pf_mod_timer proc~imk_actually_sweep->module~pf_mod_hooks module~pf_mod_comm->module~pf_mod_pfasst proc~imex_sweep imex_sweep proc~imex_sweep->module~pf_mod_timer proc~magpicard_sweep magpicard_sweep proc~magpicard_sweep->module~pf_mod_timer proc~magpicard_sweep->module~pf_mod_hooks proc~imk_sweep imk_sweep proc~imk_sweep->module~pf_mod_timer proc~imk_sweep->module~pf_mod_hooks proc~imexq_sweep imexQ_sweep proc~imexq_sweep->module~pf_mod_timer proc~imexq_sweep->module~pf_mod_hooks proc~misdcq_oc_sweep misdcQ_oc_sweep proc~misdcq_oc_sweep->module~pf_mod_timer proc~misdcq_oc_sweep->module~pf_mod_hooks proc~misdcq_sweep misdcQ_sweep proc~misdcq_sweep->module~pf_mod_timer proc~misdcq_sweep->module~pf_mod_hooks proc~exp_sweep~2 exp_sweep proc~exp_sweep~2->module~pf_mod_timer proc~exp_sweep~2->module~pf_mod_hooks var panmodulepf_mod_dtypeUsedByGraph = svgPanZoom('#modulepf_mod_dtypeUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables pfdp pfqp ZERO ONE TWO THREE HALF PF_MAXLEVS PF_MAX_HOOKS SDC_GAUSS_LOBATTO SDC_GAUSS_RADAU SDC_CLENSHAW_CURTIS SDC_UNIFORM SDC_GAUSS_LEGENDRE SDC_CHEBYSHEV PF_STATUS_ITERATING PF_STATUS_CONVERGED PF_STATUS_PREDICTOR Interfaces pf_encap_norm_p pf_hook_p pf_sweep_p pf_evaluate_p pf_evaluate_all_p pf_initialize_p pf_destroy_sweeper_p pf_integrate_p pf_residual_p pf_spreadq0_p pf_destroy_p pf_do_n_steps_p pf_initialize_stepper_p pf_destroy_stepper_p pf_transfer_p pf_encap_create_single_p pf_encap_create_array_p pf_encap_destroy_single_p pf_encap_destroy_array_p pf_encap_setval_p pf_encap_copy_p pf_encap_pack_p pf_encap_unpack_p pf_encap_axpy_p pf_encap_eprint_p pf_post_p pf_recv_p pf_recv_status_p pf_send_p pf_send_status_p pf_wait_p pf_broadcast_p pf_results_p Derived Types pf_state_t pf_hook_t pf_sweeper_t pf_stepper_t pf_encap_t pf_factory_t pf_user_level_t pf_sdcmats_t pf_level_t pf_comm_t pf_results_t pf_pfasst_t Variables Type Visibility Attributes Name Initial integer, public, parameter :: pfdp = selected_real_kind(15, 307) static pfasst paramters\n  Defines double precision type for all real and complex variables integer, public, parameter :: pfqp = selected_real_kind(33, 4931) Defines quad precision type for all real and complex variables real(kind=pfdp), public, parameter :: ZERO = 0.0_pfdp real(kind=pfdp), public, parameter :: ONE = 1.0_pfdp real(kind=pfdp), public, parameter :: TWO = 2.0_pfdp real(kind=pfdp), public, parameter :: THREE = 3.0_pfdp real(kind=pfdp), public, parameter :: HALF = 0.5_pfdp integer, public, parameter :: PF_MAXLEVS = 4 integer, public, parameter :: PF_MAX_HOOKS = 32 integer, public, parameter :: SDC_GAUSS_LOBATTO = 1 Quadrature node varieties integer, public, parameter :: SDC_GAUSS_RADAU = 2 integer, public, parameter :: SDC_CLENSHAW_CURTIS = 3 integer, public, parameter :: SDC_UNIFORM = 4 integer, public, parameter :: SDC_GAUSS_LEGENDRE = 5 integer, public, parameter :: SDC_CHEBYSHEV = 6 integer, public, parameter :: PF_STATUS_ITERATING = 1 States of operation integer, public, parameter :: PF_STATUS_CONVERGED = 2 integer, public, parameter :: PF_STATUS_PREDICTOR = 3 Interfaces interface Interfaces for subroutines public function pf_encap_norm_p(this, flags) result(norm) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this integer, intent(in), optional :: flags Return Value real(kind=pfdp) interface Interfaces for subroutines public subroutine pf_hook_p(pf, level, state) hooks subroutines Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level type( pf_state_t ), intent(in) :: state interface Interfaces for subroutines public subroutine pf_sweep_p(this, pf, level_index, t0, dt, nsweeps, flags) SDC sweeper subroutines Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_evaluate_p(this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step interface Interfaces for subroutines public subroutine pf_evaluate_all_p(this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step interface Interfaces for subroutines public subroutine pf_initialize_p(this, lev) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev interface Interfaces for subroutines public subroutine pf_destroy_sweeper_p(this) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this interface Interfaces for subroutines public subroutine pf_integrate_p(this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt Time step size class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_residual_p(this, Lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev real(kind=pfdp), intent(in) :: dt Time step size integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_spreadq0_p(this, Lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev real(kind=pfdp), intent(in) :: t0 Time at beginning of step; if flags == 2, time at end of step integer, intent(in), optional :: flags integer, intent(in), optional :: step interface Interfaces for subroutines public subroutine pf_destroy_p(this, Lev) Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev interface Interfaces for subroutines public subroutine pf_do_n_steps_p(this, pf, level_index, t0, big_dt, nsteps_rk) time stepper interfaces Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: big_dt Time step size integer, intent(in) :: nsteps_rk interface Interfaces for subroutines public subroutine pf_initialize_stepper_p(this, lev) Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev interface Interfaces for subroutines public subroutine pf_destroy_stepper_p(this, Lev) Arguments Type Intent Optional Attributes Name class( pf_stepper_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev interface Interfaces for subroutines public subroutine pf_transfer_p(this, levelF, levelG, qF, qG, t, flags) transfer interfaces used for restriction and interpolation Arguments Type Intent Optional Attributes Name class( pf_user_level_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: levelF class( pf_level_t ), intent(inout) :: levelG class( pf_encap_t ), intent(inout) :: qF class( pf_encap_t ), intent(inout) :: qG real(kind=pfdp), intent(in) :: t integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_create_single_p(this, x, level, shape) encapsulation interfaces Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) interface Interfaces for subroutines public subroutine pf_encap_create_array_p(this, x, n, level, shape) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) interface Interfaces for subroutines public subroutine pf_encap_destroy_single_p(this, x, level, shape) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x integer, intent(in) :: level integer, intent(in) :: shape (:) interface Interfaces for subroutines public subroutine pf_encap_destroy_array_p(this, x, n, level, shape) Arguments Type Intent Optional Attributes Name class( pf_factory_t ), intent(inout) :: this class( pf_encap_t ), intent(inout), allocatable :: x (:) integer, intent(in) :: n integer, intent(in) :: level integer, intent(in) :: shape (:) interface Interfaces for subroutines public subroutine pf_encap_setval_p(this, val, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: val integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_copy_p(this, src, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: src integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_pack_p(this, z, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(in) :: this real(kind=pfdp), intent(out) :: z (:) integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_unpack_p(this, z, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z (:) integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_axpy_p(this, a, x, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: a class( pf_encap_t ), intent(in) :: x integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_encap_eprint_p(this, flags) Arguments Type Intent Optional Attributes Name class( pf_encap_t ), intent(inout) :: this integer, intent(in), optional :: flags interface Interfaces for subroutines public subroutine pf_post_p(pf, level, tag, ierror, source) communicator interfaces Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag integer, intent(inout) :: ierror integer, intent(in) :: source interface Interfaces for subroutines public subroutine pf_recv_p(pf, level, tag, blocking, ierror, source) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(inout) :: ierror integer, intent(in) :: source interface Interfaces for subroutines public subroutine pf_recv_status_p(pf, tag, istatus, ierror, source) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: tag integer, intent(inout) :: istatus integer, intent(inout) :: ierror integer, intent(in) :: source interface Interfaces for subroutines public subroutine pf_send_p(pf, level, tag, blocking, ierror, dest) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(inout) :: ierror integer, intent(in) :: dest interface Interfaces for subroutines public subroutine pf_send_status_p(pf, tag, istatus, ierror, dest) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in) :: istatus integer, intent(inout) :: ierror integer, intent(in) :: dest interface Interfaces for subroutines public subroutine pf_wait_p(pf, level, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(in) :: pf integer, intent(in) :: level integer, intent(inout) :: ierror interface Interfaces for subroutines public subroutine pf_broadcast_p(pf, y, nvar, root, ierror) Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf real(kind=pfdp), intent(in) :: y (nvar) integer, intent(in) :: nvar integer, intent(in) :: root integer, intent(inout) :: ierror interface Interfaces for subroutines public subroutine pf_results_p(this) Arguments Type Intent Optional Attributes Name type( pf_results_t ), intent(inout) :: this Derived Types type, public, bind(c) :: pf_state_t The type that holds the state of the system Components Type Visibility Attributes Name Initial real(kind=pfdp), public :: t0 Time at beginning of this time step real(kind=pfdp), public :: dt Time step size integer, public :: nsteps total number of time steps integer, public :: pfblock pfasst block being worked on integer, public :: iter current iteration number integer, public :: step current time step number assigned to processor integer, public :: level which level is currently being operated on integer, public :: hook which hook integer, public :: proc which processor integer, public :: sweep sweep number integer, public :: status status (iterating, converged etc) integer, public :: pstatus previous rank's status integer, public :: itcnt total iterations by this processor integer, public :: skippedy skipped sweeps for state (for mixed integration) integer, public :: mysteps steps I did type, public :: pf_hook_t Abstract hook type: hooks call diagnostic routines from various places in code Components Type Visibility Attributes Name Initial procedure( pf_hook_p ), public, pointer, nopass :: proc type, public, abstract :: pf_sweeper_t The abstract SDC sweeper type (must be extended) Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq Type-Bound Procedures procedure(pf_sweep_p), public :: sweep procedure(pf_initialize_p), public :: initialize procedure(pf_evaluate_p), public :: evaluate procedure(pf_integrate_p), public :: integrate procedure(pf_evaluate_all_p), public :: evaluate_all procedure(pf_residual_p), public :: residual procedure(pf_spreadq0_p), public :: spreadq0 procedure(pf_destroy_p), public :: destroy type, public, abstract :: pf_stepper_t The abstract time stepper type (must be extended) Components Type Visibility Attributes Name Initial integer, public :: npieces integer, public :: order Type-Bound Procedures procedure(pf_do_n_steps_p), public :: do_n_steps procedure(pf_initialize_stepper_p), public :: initialize procedure(pf_destroy_stepper_p), public :: destroy type, public, abstract :: pf_encap_t The abstract data type of the solution (must be extended) Type-Bound Procedures procedure(pf_encap_setval_p), public :: setval procedure(pf_encap_copy_p), public :: copy procedure(pf_encap_norm_p), public :: norm procedure(pf_encap_pack_p), public :: pack procedure(pf_encap_unpack_p), public :: unpack procedure(pf_encap_axpy_p), public :: axpy procedure(pf_encap_eprint_p), public :: eprint type, public, abstract :: pf_factory_t Abstract type for creation and destruction of objects Type-Bound Procedures procedure(pf_encap_create_single_p), public :: create_single procedure(pf_encap_create_array_p), public :: create_array procedure(pf_encap_destroy_single_p), public :: destroy_single procedure(pf_encap_destroy_array_p), public :: destroy_array type, public, abstract :: pf_user_level_t The absract definition of level which is inherited  to include problem dependent stuff Components Type Visibility Attributes Name Initial class( pf_factory_t ), public, allocatable :: factory class( pf_sweeper_t ), public, allocatable :: sweeper class( pf_stepper_t ), public, allocatable :: stepper Type-Bound Procedures procedure(pf_transfer_p), public :: restrict procedure(pf_transfer_p), public :: interpolate type, public :: pf_sdcmats_t The type to store quadrature matrices Components Type Visibility Attributes Name Initial integer, public :: nnodes integer, public :: qtype real(kind=pfdp), public, allocatable :: qnodes (:) real(kind=pfdp), public, allocatable :: Qmat (:,:) real(kind=pfdp), public, allocatable :: QmatFE (:,:) real(kind=pfdp), public, allocatable :: QmatBE (:,:) real(kind=pfdp), public, allocatable :: QmatTrap (:,:) real(kind=pfdp), public, allocatable :: QmatVer (:,:) real(kind=pfdp), public, allocatable :: QmatLU (:,:) real(kind=pfdp), public, allocatable :: s0mat (:,:) logical, public :: use_proper_nodes = .false. logical, public :: use_composite_nodes = .false. logical, public :: use_no_left_q = .false. type, public :: pf_level_t Data type of a PFASST level Components Type Visibility Attributes Name Initial integer, public :: index = -1 level number (1 is the coarsest) integer, public :: nnodes = -1 number of sdc nodes integer, public :: nsteps_rk = -1 number of rk steps to perform integer, public :: nsweeps = -1 number of sdc sweeps to perform integer, public :: nsweeps_pred = -1 number of coarse sdc sweeps to perform predictor in predictor logical, public :: Finterp = .false. interpolate functions instead of solutions integer, public :: mpibuflen = -1 size of solution in pfdp units real(kind=pfdp), public :: error holds the user defined error real(kind=pfdp), public :: residual holds the user defined residual real(kind=pfdp), public :: residual_rel holds the user defined relative residual (scaled by solution magnitude) class( pf_user_level_t ), public, allocatable :: ulevel user customized level info real(kind=pfdp), public, allocatable :: send (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: recv (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: nodes (:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: rmat (:,:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix real(kind=pfdp), public, allocatable :: tmat (:,:) Simple data storage at each level\n send buffer\n recv buffer\n list of SDC nodes\n time restriction matrix\n time interpolation matrix integer, public, allocatable :: nflags (:) sdc node flags class( pf_encap_t ), public, allocatable :: Q (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: pQ (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: R (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: I (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: Fflt (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: tauQ (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: pFflt (:) Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: q0 Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, allocatable :: qend Solution variable storage\n solution at sdc nodes\n unknowns at sdc nodes, previous sweep\n full residuals\n 0 to node integrals\n functions values at sdc nodes (flat)\n fas correction in Q form\n functions at sdc nodes, previous sweep (flat)\n initial condition \n solution at end time class( pf_encap_t ), public, pointer :: F (:,:) Function  storage\n functions values at sdc nodes\n functions at sdc nodes, previous sweep class( pf_encap_t ), public, pointer :: pF (:,:) Function  storage\n functions values at sdc nodes\n functions at sdc nodes, previous sweep integer, public, allocatable :: shape (:) user defined shape array type( pf_sdcmats_t ), public, allocatable :: sdcmats logical, public :: allocated = .false. type, public :: pf_comm_t Data type to define the communicator Components Type Visibility Attributes Name Initial integer, public :: nproc = -1 integer, public :: comm = -1 integer, public, pointer :: recvreq (:) integer, public, pointer :: sendreq (:) integer, public :: statreq type(c_ptr), public, pointer :: pfs (:) type(c_ptr), public, pointer :: pfpth (:,:) procedure( pf_post_p ), public, pointer, nopass :: post Procedure interfaces procedure( pf_recv_p ), public, pointer, nopass :: recv procedure( pf_recv_status_p ), public, pointer, nopass :: recv_status procedure( pf_send_p ), public, pointer, nopass :: send procedure( pf_send_status_p ), public, pointer, nopass :: send_status procedure( pf_wait_p ), public, pointer, nopass :: wait procedure( pf_broadcast_p ), public, pointer, nopass :: broadcast type, public :: pf_results_t Type for storing results for later output Components Type Visibility Attributes Name Initial real(kind=pfdp), public, allocatable :: errors (:,:,:) real(kind=pfdp), public, allocatable :: residuals (:,:,:) integer, public :: nsteps integer, public :: niters integer, public :: nprocs integer, public :: p_index integer, public :: nblocks integer, public :: nsweeps integer, public :: rank integer, public :: level procedure( pf_results_p ), public, pointer, nopass :: dump procedure( pf_results_p ), public, pointer, nopass :: destroy type, public :: pf_pfasst_t The main PFASST data type which includes pretty much everythingl Components Type Visibility Attributes Name Initial integer, public :: nlevels = -1 Mandatory parameters (must be set on command line or input file)\n number of pfasst levels integer, public :: niters = 5 Optional parameters\n number of PFASST iterations to do integer, public :: qtype = SDC_GAUSS_LOBATTO type of nodes logical, public :: use_proper_nodes = .false. logical, public :: use_composite_nodes = .false. logical, public :: use_no_left_q = .false. integer, public :: nsweeps (PF_MAXLEVS) = 1 number of sweeps at each levels integer, public :: nsweeps_pred (PF_MAXLEVS) = 1 number of sweeps during predictor integer, public :: nnodes (PF_MAXLEVS) = 3 number of nodes real(kind=pfdp), public :: abs_res_tol = 0.d0 absolute convergence tolerance real(kind=pfdp), public :: rel_res_tol = 0.d0 relative convergence tolerance logical, public :: PFASST_pred = .true. true if the PFASST type predictor is used logical, public :: pipeline_pred = .false. true if coarse sweeps after burn in are pipelined  (if nsweeps_pred>1 on coarse level) integer, public :: nsweeps_burn = 1 number of sdc sweeps to perform during coarse level burn in integer, public :: q0_style = 0 q0 can take 3 values\n  0:  Only the q0 at t=0 is valid  (default)\n  1:  The q0 at each processor is valid\n  2:  q0 and all nodes at each processor is valid logical, public :: Vcycle = .true. decides if Vcycles are done logical, public :: Finterp = .false. True if transfer functions operate on rhs logical, public :: use_LUq = .true. True if LU type implicit matrix is used integer, public :: taui0 = -999999 iteration cutoff for tau inclusion logical, public :: use_rk_stepper = .false. RK and Parareal options\n decides if RK steps are used instead of the sweeps integer, public :: nsteps_rk (PF_MAXLEVS) = 3 number of runge-kutta nodes logical, public :: RK_pred = .false. true if the coarse level is initialized with Runge-Kutta instead of PFASST logical, public :: debug = .false. If true, debug diagnostics are printed logical, public :: save_residuals = .false. If true, residuals are saved and output logical, public :: save_timings = .false. If true, timings are saved and  output logical, public :: echo_timings = .false. If true, timings are  output to screen logical, public :: save_errors = .false. If true, errors  are saved and output integer, public :: rank = -1 rank of current processor type( pf_state_t ), public, allocatable :: state pf objects\n  Describes where in the algorithm proc is type( pf_level_t ), public, allocatable :: levels (:) Holds the levels type( pf_comm_t ), public, pointer :: comm Points to communicator type( pf_results_t ), public, allocatable :: results (:) Hold results for each level type( pf_hook_t ), public, allocatable :: hooks (:,:,:) hooks variables\n  Holds the hooks integer, public, allocatable :: nhooks (:,:) Holds the number hooks double precision, public :: timers (100) = 0.0d0 timing variables double precision, public :: runtimes (100) = 0.0d0 character(len=512), public :: outdir output directory","tags":"","loc":"module/pf_mod_dtype.html","title":"pf_mod_dtype – LibPFASST"},{"text":"Module of the  the derived sweeper class for doing MISDC sweeps for an equation of the form y' = f_1(y) + f_2(y) + f_3(y) The f_1 piece is treated explicitly and f_2 and f_3 implicitly\n  Afer this sweeper is initialized (usually in main), the locgical flags can be changed if desired Uses pf_mod_dtype pf_mod_utils module~~pf_mod_misdcq~~UsesGraph module~pf_mod_misdcq pf_mod_misdcQ module~pf_mod_utils pf_mod_utils module~pf_mod_misdcq->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_misdcq->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_misdcQ_t Subroutines misdcQ_sweep misdcQ_initialize misdcQ_destroy misdcQ_integrate misdcQ_evaluate misdcQ_evaluate_all misdcQ_residual misdcQ_spreadq0 Interfaces interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_misdcQ_t Multi-implicit SDC sweeper type, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) real(kind=pfdp), public, allocatable :: dtsdc (:) class( pf_encap_t ), public, allocatable :: I3 (:) class( pf_encap_t ), public, allocatable :: rhs Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval procedure(pf_f_comp_p), public :: f_comp procedure, public :: sweep => misdcQ_sweep procedure, public :: initialize => misdcQ_initialize procedure, public :: integrate => misdcQ_integrate procedure, public :: residual => misdcQ_residual procedure, public :: spreadq0 => misdcQ_spreadq0 procedure, public :: evaluate_all => misdcQ_evaluate_all procedure, public :: evaluate => misdcQ_evaluate procedure, public :: destroy => misdcQ_destroy procedure, public :: misdcQ_destroy Subroutines public subroutine misdcQ_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Assign level pointer Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine misdcQ_initialize (this, lev) Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine misdcQ_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine misdcQ_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags public subroutine misdcQ_evaluate (this, lev, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine misdcQ_evaluate_all (this, lev, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine misdcQ_residual (this, lev, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags public subroutine misdcQ_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"module/pf_mod_misdcq.html","title":"pf_mod_misdcQ – LibPFASST"},{"text":"Module of parallel PFASST routines for optimal control problems. Uses pf_mod_pfasst pf_mod_interpolate pf_mod_restrict pf_mod_utils pf_mod_timer pf_mod_dtype pf_mod_hooks pf_mod_comm module~~pf_mod_parallel_oc~~UsesGraph module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_parallel_oc->module~pf_mod_interpolate module~pf_mod_utils pf_mod_utils module~pf_mod_parallel_oc->module~pf_mod_utils module~pf_mod_restrict pf_mod_restrict module~pf_mod_parallel_oc->module~pf_mod_restrict module~pf_mod_pfasst pf_mod_pfasst module~pf_mod_parallel_oc->module~pf_mod_pfasst module~pf_mod_comm pf_mod_comm module~pf_mod_parallel_oc->module~pf_mod_comm module~pf_mod_dtype pf_mod_dtype module~pf_mod_parallel_oc->module~pf_mod_dtype module~pf_mod_hooks pf_mod_hooks module~pf_mod_parallel_oc->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer module~pf_mod_parallel_oc->module~pf_mod_timer module~pf_mod_interpolate->module~pf_mod_utils module~pf_mod_interpolate->module~pf_mod_restrict module~pf_mod_interpolate->module~pf_mod_dtype module~pf_mod_interpolate->module~pf_mod_hooks module~pf_mod_interpolate->module~pf_mod_timer module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_timer module~pf_mod_restrict->module~pf_mod_dtype module~pf_mod_restrict->module~pf_mod_hooks module~pf_mod_restrict->module~pf_mod_timer module~pf_mod_pfasst->module~pf_mod_utils module~pf_mod_pfasst->module~pf_mod_dtype module~pf_mod_comm_mpi pf_mod_comm_mpi module~pf_mod_pfasst->module~pf_mod_comm_mpi module~pf_mod_results pf_mod_results module~pf_mod_pfasst->module~pf_mod_results module~pf_mod_comm->module~pf_mod_pfasst iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_comm_mpi->module~pf_mod_dtype module~pf_mod_comm_mpi->module~pf_mod_mpi module~pf_mod_results->module~pf_mod_utils module~pf_mod_results->module~pf_mod_dtype var panmodulepf_mod_parallel_ocUsesGraph = svgPanZoom('#modulepf_mod_parallel_ocUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines pf_predictor_oc pf_check_residual_oc pf_check_convergence_oc pf_pfasst_block_oc pf_v_cycle_oc Subroutines public subroutine pf_predictor_oc (pf, t0, dt, flags) Step 1. Getting the  initial condition on the finest level at each processor\n         If we are doing multiple levels, then we need to coarsen to fine level\n  Step 2:   Proceed fine to coarse levels coarsening the fine solution and computing tau correction\n If RK_pred is true, just do some RK_steps Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf PFASST main data structure real(kind=pfdp), intent(in) :: t0 Initial time of this processor real(kind=pfdp), intent(in) :: dt time step integer, intent(in), optional :: flags (:) User defined flags public subroutine pf_check_residual_oc (pf, residual_converged) Subroutine to test residuals to determine if the current processor has converged. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf logical, intent(out) :: residual_converged Return true if residual is below tolerances public subroutine pf_check_convergence_oc (pf, send_tag, flags) Test residuals to determine if the current processor has converged,\n adapted to optimal control. Can probably be removed, when pf_pfasst_block_oc\n is changed to use pf_check_convergence of pf_check_convergence_old. Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: send_tag integer, intent(in), optional :: flags public subroutine pf_pfasst_block_oc (pf, dt, nsteps, predict, flags, step) Routine to do the pfasst iterations for optimal control problems on one block of processors until completion.\n  Each processor will do either a fixed number of iterations, or iterate until a tolerance is met\n  On calling, it is assumed that the levels are already loaded with the initial guesses Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsteps logical, intent(in) :: predict integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine pf_v_cycle_oc (pf, iteration, t0, dt, level_index_c, level_index_f, flags) Post the nonblocking receives on the all the levels that will be recieving later\n    (for single level this will be skipped)\n move from fine to coarse doing sweeps Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: iteration real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: level_index_c Coarsest level of V-cycle integer, intent(in) :: level_index_f Finest level of V-cycle integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_parallel_oc.html","title":"pf_mod_parallel_oc – LibPFASST"},{"text":"Module with useful subroutines that don't  fit in other modules Uses pf_mod_dtype pf_mod_timer module~~pf_mod_utils~~UsesGraph module~pf_mod_utils pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_utils~~UsedByGraph module~pf_mod_utils pf_mod_utils module~pf_mod_imexq_oc pf_mod_imexQ_oc module~pf_mod_imexq_oc->module~pf_mod_utils module~pf_mod_misdcq pf_mod_misdcQ module~pf_mod_misdcq->module~pf_mod_utils module~pf_mod_amisdc pf_mod_amisdc module~pf_mod_amisdc->module~pf_mod_utils module~pf_mod_zndarray pf_mod_zndarray module~pf_mod_zndarray->module~pf_mod_utils module~pf_mod_pfasst pf_mod_pfasst module~pf_mod_pfasst->module~pf_mod_utils module~pf_mod_results pf_mod_results module~pf_mod_pfasst->module~pf_mod_results module~pf_mod_rkstepper pf_mod_rkstepper module~pf_mod_rkstepper->module~pf_mod_utils module~pf_mod_fftpackage pf_mod_fftpackage module~pf_mod_fftpackage->module~pf_mod_utils module~pf_mod_imk pf_mod_imk module~pf_mod_imk->module~pf_mod_utils module~pf_mod_imex pf_mod_imex module~pf_mod_imex->module~pf_mod_utils module~pf_mod_ndarray_oc pf_mod_ndarray_oc module~pf_mod_ndarray_oc->module~pf_mod_utils module~pf_mod_fftpackage~2 pf_mod_fftpackage module~pf_mod_fftpackage~2->module~pf_mod_utils module~pf_mod_imexq pf_mod_imexQ module~pf_mod_imexq->module~pf_mod_utils module~pf_mod_results->module~pf_mod_utils module~pf_mod_exp~2 pf_mod_exp module~pf_mod_exp~2->module~pf_mod_utils module~pf_mod_misdcq_oc pf_mod_misdcQ_oc module~pf_mod_misdcq_oc->module~pf_mod_utils module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_utils module~pf_mod_parallel_oc->module~pf_mod_pfasst module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_parallel_oc->module~pf_mod_interpolate module~pf_mod_comm pf_mod_comm module~pf_mod_parallel_oc->module~pf_mod_comm module~pf_mod_exp pf_mod_exp module~pf_mod_exp->module~pf_mod_utils module~pf_mod_quadrature pf_mod_quadrature module~pf_mod_quadrature->module~pf_mod_utils proc~pf_init_sdcmats pf_init_sdcmats proc~pf_init_sdcmats->module~pf_mod_utils module~pf_mod_verlet pf_mod_verlet module~pf_mod_verlet->module~pf_mod_utils module~pf_mod_parallel pf_mod_parallel module~pf_mod_parallel->module~pf_mod_utils module~pf_mod_parallel->module~pf_mod_pfasst module~pf_mod_parallel->module~pf_mod_results module~pf_mod_parallel->module~pf_mod_interpolate module~pf_mod_parallel->module~pf_mod_comm module~pf_mod_interpolate->module~pf_mod_utils module~pf_mod_misdc pf_mod_misdc module~pf_mod_misdc->module~pf_mod_utils module~pf_mod_magnus_picard pf_mod_magnus_picard module~pf_mod_magnus_picard->module~pf_mod_utils module~pf_mod_ndarray pf_mod_ndarray module~pf_mod_ndarray->module~pf_mod_utils proc~pf_level_destroy pf_level_destroy proc~pf_level_destroy->module~pf_mod_quadrature module~pf_mod_amisdcq pf_mod_amisdcQ module~pf_mod_amisdcq->module~pf_mod_amisdc module~pf_mod_comm->module~pf_mod_pfasst module~pfasst pfasst module~pfasst->module~pf_mod_pfasst module~pfasst->module~pf_mod_imexq module~pfasst->module~pf_mod_results module~pfasst->module~pf_mod_parallel proc~imexq_initialize imexQ_initialize proc~imexq_initialize->module~pf_mod_quadrature proc~pf_level_setup pf_level_setup proc~pf_level_setup->module~pf_mod_quadrature var panmodulepf_mod_utilsUsedByGraph = svgPanZoom('#modulepf_mod_utilsUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines pf_residual pf_generic_residual pf_generic_evaluate_all pf_generic_spreadq0 pf_stop Subroutines public subroutine pf_residual (pf, lev, dt, flag) Compute full residual at each node and measure its size Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flag public subroutine pf_generic_residual (this, lev, dt, flags) Generic residual\n Each sweeper can define its own residual, or use this generic one\n This routine is in the \"Q\" form, so the residual approximates\n R(m)=y(t_n) + \\int_{t_n}&#94;t_m f(y,s) ds - y(t_m)\n  Compute the integral of F from t_n to t_m at each node Read more… Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine pf_generic_evaluate_all (this, lev, t, flags, step) Generic evaluate all\n Each sweeper can define its own evaluate_all or use this generic one Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine pf_generic_spreadq0 (this, lev, t0) Generic routine to spread initial conditions\n Each sweeper can define its own spreadq0 or use this generic one Arguments Type Intent Optional Attributes Name class( pf_sweeper_t ), intent(in) :: this class( pf_level_t ), intent(inout) :: lev Level on which to spread real(kind=pfdp), intent(in) :: t0 time at beginning of interval public subroutine pf_stop (pf_file, Nline, msg, N) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: pf_file integer, intent(in) :: Nline character(len=*), intent(in) :: msg integer, intent(in), optional :: N","tags":"","loc":"module/pf_mod_utils.html","title":"pf_mod_utils – LibPFASST"},{"text":"IMEX Sweeper Module\n  Module of the  the derived sweeper class for doing IMEX sweeps for an equation of the form y' = f_1(y) + f_2(y) The f_1 piece is treated explicitly and f_2 implicitl\n  Afer this sweeper is initialized (usually in main), the logical flags can be changed if desired explicit:  Make false if there is no explicit piece\n\n implicit:  Make false if there is no implicit piece The user needs to supply the feval and fcomp routines for a given example Uses pf_mod_dtype pf_mod_utils module~~pf_mod_imexq~~UsesGraph module~pf_mod_imexq pf_mod_imexQ module~pf_mod_utils pf_mod_utils module~pf_mod_imexq->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_imexq->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_imexq~~UsedByGraph module~pf_mod_imexq pf_mod_imexQ module~pfasst pfasst module~pfasst->module~pf_mod_imexq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_imexQ_t Subroutines imexQ_sweep imexQ_initialize imexQ_destroy imexQ_integrate imexQ_residual imexQ_spreadq0 imexQ_evaluate imexQ_evaluate_all Interfaces interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece) This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two \n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece) Solve the equation y - dtq*f_2(y) =rhs Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_2 of solution y integer, intent(in) :: piece Which piece to evaluate Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_imexQ_t IMEX SDC sweeper type, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QtilE (:,:) Approximate explicit quadrature rule real(kind=pfdp), public, allocatable :: QtilI (:,:) Approximate implicit quadrature rule real(kind=pfdp), public, allocatable :: dtsdc (:) SDC step sizes real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public, allocatable :: QdiffI (:,:) qmat-QtilI logical, public :: explicit = .true. True if there is an explicit piece logical, public :: implicit = .true. True if there an implicit piece class( pf_encap_t ), public, allocatable :: rhs holds rhs for implicit solve Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval RHS function evaluations procedure(pf_f_comp_p), public :: f_comp Implicit solver procedure, public :: sweep => imexQ_sweep Set the generic functions procedure, public :: initialize => imexQ_initialize procedure, public :: evaluate => imexQ_evaluate procedure, public :: integrate => imexQ_integrate procedure, public :: residual => imexQ_residual procedure, public :: spreadq0 => imexQ_spreadq0 procedure, public :: evaluate_all => imexQ_evaluate_all procedure, public :: destroy => imexQ_destroy procedure, public :: imexQ_destroy Subroutines public subroutine imexQ_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform nsweep SDC sweeps on level level_index and set qend appropriately.\n  Assign level pointer Read more… Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine imexQ_initialize (this, lev) Subroutine to initialize matrices and space for sweeper\n  Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level public subroutine imexQ_destroy (this, lev) Subroutine to deallocate sweeper Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level public subroutine imexQ_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Subroutine to compute  Picard integral of function values Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintSDC (:) Integral from t_n to t_m integer, intent(in), optional :: flags public subroutine imexQ_residual (this, lev, dt, flags) Subroutine to compute  Residual Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags public subroutine imexQ_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imexQ_evaluate (this, lev, t, m, flags, step) Subroutine to evaluate function value at node m Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imexQ_evaluate_all (this, lev, t, flags, step) Subroutine to evaluate the function values at all nodes Arguments Type Intent Optional Attributes Name class( pf_imexQ_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"module/pf_mod_imexq.html","title":"pf_mod_imexQ – LibPFASST"},{"text":"Tommaso Buvoli\n  this module extends pf_sweeper_t and is used for creating an exponential sweeper \n  that solves equations of the form y' = L y + N(t,y) When extending this class, you must supply the functions phib, swpPhib, and resPhib\n  that each compute matrix-vector products of the form \\sum_{i=0}&#94;n t&#94;i \\varphi_i(tL)b_i in addition to the function f_eval for compluting the nonlinear term N(t,y).\n  The complete description of these three functions is contained below. Uses pf_mod_dtype pf_mod_utils module~~pf_mod_exp~~UsesGraph module~pf_mod_exp pf_mod_exp module~pf_mod_utils pf_mod_utils module~pf_mod_exp->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_exp->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_phib pf_swpPhib pf_resPhib pf_f_eval_p Derived Types pf_exp_t Subroutines exp_initialize exp_sweep exp_integrate exp_residual exp_spreadq0 exp_evaluate exp_evaluate_all exp_destroy LocalDerivsAtNode weights Interfaces interface public subroutine pf_phib(this, t, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: t real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y interface public subroutine pf_swpPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y interface public subroutine pf_resPhib(this, j, h, b, y) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: j real(kind=pfdp), intent(in) :: h class( pf_encap_t ), intent(in) :: b (:) class( pf_encap_t ), intent(inout) :: y interface public subroutine pf_f_eval_p(this, y, t, level, n) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: n Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_exp_t Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: w (:,:,:) real(kind=pfdp), public, allocatable :: nodes (:) real(kind=pfdp), public, allocatable :: eta (:) class( pf_encap_t ), public, allocatable :: b (:) class( pf_encap_t ), public, allocatable :: f_old (:) class( pf_encap_t ), public, allocatable :: newF logical, public :: use_phib = .TRUE. Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval procedure(pf_phib), public :: phib procedure(pf_swpPhib), public :: swpPhib procedure(pf_resPhib), public :: resPhib procedure, public :: initialize => exp_initialize procedure, public :: sweep => exp_sweep procedure, public :: evaluate => exp_evaluate procedure, public :: integrate => exp_integrate procedure, public :: residual => exp_residual procedure, public :: spreadq0 => exp_spreadq0 procedure, public :: evaluate_all => exp_evaluate_all procedure, public :: destroy => exp_destroy procedure, public :: exp_destroy procedure, public :: exp_initialize Subroutines public subroutine exp_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine exp_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine exp_integrate (this, lev, qSDC, fSDC, dt, fintsdc, flags) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev Current level class( pf_encap_t ), intent(in) :: qSDC (:) Solution values class( pf_encap_t ), intent(in) :: fSDC (:,:) RHS Function values real(kind=pfdp), intent(in) :: dt Time step class( pf_encap_t ), intent(inout) :: fintsdc (:) Integral from t_n to t_m integer, intent(in), optional :: flags public subroutine exp_residual (this, lev, dt, flags) Compute the integral of F from t_n to t_m at each node Read more… Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: dt Time step integer, intent(in), optional :: flags public subroutine exp_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine exp_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t Time at which to evaluate integer, intent(in) :: m Node at which to evaluate integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine exp_evaluate_all (this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level real(kind=pfdp), intent(in) :: t (:) Array of times at each node integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine exp_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev Current level public subroutine LocalDerivsAtNode (this, i, nnodes, N_eval, N_deriv) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this integer, intent(in) :: i integer, intent(in) :: nnodes class( pf_encap_t ), intent(in) :: N_eval (:) class( pf_encap_t ), intent(inout) :: N_deriv (:) public subroutine weights (this, z, x, m, W) Arguments Type Intent Optional Attributes Name class( pf_exp_t ), intent(inout) :: this real(kind=pfdp), intent(in) :: z real(kind=pfdp), intent(in) :: x (:) integer, intent(in) :: m real(kind=pfdp), intent(out) :: W (size(x),m+1)","tags":"","loc":"module/pf_mod_exp.html","title":"pf_mod_exp – LibPFASST"},{"text":"Asynchronous multi-implicit sweeper Uses pf_mod_amisdc module~~pf_mod_amisdcq~~UsesGraph module~pf_mod_amisdcq pf_mod_amisdcQ module~pf_mod_amisdc pf_mod_amisdc module~pf_mod_amisdcq->module~pf_mod_amisdc module~pf_mod_utils pf_mod_utils module~pf_mod_amisdc->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_amisdc->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi var panmodulepf_mod_amisdcqUsesGraph = svgPanZoom('#modulepf_mod_amisdcqUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types pf_amisdcQ_t Subroutines sweep_coupled_implicit_terms sweep_decoupled_implicit_terms amisdcQ_sweep amisdcQ_initialize amisdcQ_destroy amisdcQ_integrate Derived Types type, public, abstract, extends( pf_amisdc_t ) :: pf_amisdcQ_t Asynchronous multi-implicit sweeper type Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: SdiffE (:,:) real(kind=pfdp), public, allocatable :: SdiffI (:,:) real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) logical, public :: use_LUq_ = .true. Type-Bound Procedures procedure(pf_spreadq0_p), public :: spreadq0 procedure(pf_f1eval_p), public :: f1eval procedure(pf_f2eval_p), public :: f2eval procedure(pf_f2comp_p), public :: f2comp procedure(pf_f3eval_p), public :: f3eval procedure(pf_f3comp_p), public :: f3comp procedure, public :: evaluate => amisdc_evaluate procedure, public :: residual => amisdc_residual procedure, public :: evaluate_all => amisdc_evaluate_all procedure, public :: amisdc_destroy procedure, public :: sweep => amisdcQ_sweep procedure, public :: initialize => amisdcQ_initialize procedure, public :: integrate => amisdcQ_integrate procedure, public :: destroy => amisdcQ_destroy procedure, public :: sweep_coupled_implicit_terms procedure, public :: sweep_decoupled_implicit_terms procedure, public :: amisdcQ_destroy Subroutines public subroutine sweep_coupled_implicit_terms (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine sweep_decoupled_implicit_terms (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine amisdcQ_sweep (this, pf, lev, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt public subroutine amisdcQ_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev public subroutine amisdcQ_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(inout) :: lev public subroutine amisdcQ_integrate (this, lev, qSDC, fSDC, dt, fintSDC) Arguments Type Intent Optional Attributes Name class( pf_amisdcQ_t ), intent(inout) :: this class(pf_level_t), intent(in) :: lev class(pf_encap_t), intent(in) :: qSDC (:) class(pf_encap_t), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class(pf_encap_t), intent(inout) :: fintSDC (:)","tags":"","loc":"module/pf_mod_amisdcq.html","title":"pf_mod_amisdcQ – LibPFASST"},{"text":"This module implements fully implicit Munthe-Kaas Runge Kutta methods using explicit SDC sweeping The equation to be solved is y'=A(y,t)y where A is a matrix and (y)\\ is  a vector or matrix or if Lax_pair = true Y'=[A(Y,t),Y] where both A and Y are matrices We solve this by finding the solution to Q' = dexpinv_Q(A) Using PFASST Uses pf_mod_dtype pf_mod_utils module~~pf_mod_imk~~UsesGraph module~pf_mod_imk pf_mod_imk module~pf_mod_utils pf_mod_utils module~pf_mod_imk->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_imk->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_f_eval_p pf_dexpinv_p pf_propagate_p pf_commutator_p Derived Types pf_imk_t Subroutines imk_sweep rk_step mkrk_step imk_actually_sweep imk_initialize imk_integrate imk_evaluate imk_evaluate_all imk_residual imk_spreadq0 imk_save imk_destroy Interfaces interface public subroutine pf_f_eval_p(this, y, t, level, f) Subroutine f_eval computes A(y,t) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer(kind=c_int), intent(in) :: level class( pf_encap_t ), intent(inout) :: f interface public subroutine pf_dexpinv_p(this, a, omega, f) Subroutine dexpinv computes Om'=F=dexpinv_Om(A) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: f The resultign-level interface public subroutine pf_propagate_p(this, q0, q) Subroutine propagate   computes y_m=expm(Om_m)y_0(expm(Om_m))-1 or (expm(Om_m))y_0 or Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: q0 class( pf_encap_t ), intent(inout) :: q interface public subroutine pf_commutator_p(this, a, b, out, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: a class( pf_encap_t ), intent(inout) :: b class( pf_encap_t ), intent(inout) :: out integer, intent(in), optional :: flags Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_imk_t Implicit Munthe-Kaas Runge-Kutta sweeper type, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq class( pf_encap_t ), public, allocatable :: A (:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: dtsdc (:) real(kind=pfdp), public, allocatable :: tsdc (:) real(kind=pfdp), public, allocatable :: QdiffE (:,:) qmat-QtilE real(kind=pfdp), public :: bernoullis (20) real(kind=pfdp), public :: t0 real(kind=pfdp), public :: dt integer, public :: qtype integer, public :: nterms logical, public :: Lax_pair logical, public :: use_SDC logical, public :: debug logical, public :: mkrk logical, public :: rk Type-Bound Procedures procedure(pf_destroy_p), public :: destroy procedure, public :: sweep => imk_sweep procedure, public :: initialize => imk_initialize procedure, public :: evaluate => imk_evaluate procedure, public :: integrate => imk_integrate procedure, public :: residual => imk_residual procedure, public :: spreadq0 => imk_spreadq0 procedure, public :: evaluate_all => imk_evaluate_all procedure, public :: imk_destroy procedure(pf_f_eval_p), public :: f_eval procedure(pf_dexpinv_p), public :: dexpinv procedure(pf_propagate_p), public :: propagate procedure(pf_commutator_p), public :: commutator_p Subroutines public subroutine imk_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Perform nsweep  sweeps on level  and set qend appropriately. Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do integer, intent(in), optional :: flags public subroutine rk_step (this, pf, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size public subroutine mkrk_step (this, pf, t0, dt) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size public subroutine imk_actually_sweep (this, pf, level_index, t0, dt, nsweeps) Assign level pointer Read more… Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this Inputs type( pf_pfasst_t ), intent(inout), target :: pf PFASST structure integer, intent(in) :: level_index which level to sweep on real(kind=pfdp), intent(in) :: t0 Time at beginning of time step real(kind=pfdp), intent(in) :: dt time step size integer, intent(in) :: nsweeps number of sweeps to do public subroutine imk_initialize (this, lev) Assign explicit approximate quadrature rule\n  Make space for temporary variables Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine imk_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags public subroutine imk_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imk_evaluate_all (this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imk_residual (this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine imk_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine imk_save (lev) Save function values so that difference can be computed Arguments Type Intent Optional Attributes Name class( pf_level_t ), intent(inout) :: lev Level to save on public subroutine imk_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_imk_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev","tags":"","loc":"module/pf_mod_imk.html","title":"pf_mod_imk – LibPFASST"},{"text":"This module implements fully implicit Magnus method using explicit Picard sweeping Uses pf_mod_dtype pf_mod_utils module~~pf_mod_magnus_picard~~UsesGraph module~pf_mod_magnus_picard pf_mod_magnus_picard module~pf_mod_utils pf_mod_utils module~pf_mod_magnus_picard->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_magnus_picard->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_f_eval_p pf_compute_single_commutators_p pf_compute_omega_p pf_propagate_solution_p pf_destroy_magpicard_p Derived Types pf_magpicard_t Subroutines magpicard_sweep magpicard_initialize magpicard_integrate magpicard_evaluate magpicard_evaluate_all magpicard_residual magpicard_spreadq0 magpicard_destroy get_commutator_coefs Interfaces interface public subroutine pf_f_eval_p(this, y, t, level, f) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y real(kind=pfdp), intent(in) :: t integer, intent(in) :: level class( pf_encap_t ), intent(inout) :: f interface public subroutine pf_compute_single_commutators_p(this, f) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: f (:,:) interface public subroutine pf_compute_omega_p(this, omega, integrals, f, nodes, qmat, dt, this_node, coefs) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: omega class( pf_encap_t ), intent(inout) :: integrals (:) class( pf_encap_t ), intent(inout) :: f (:,:) real(kind=pfdp), intent(in) :: nodes (:) real(kind=pfdp), intent(in) :: qmat (:,:) real(kind=pfdp), intent(in) :: dt integer, intent(in) :: this_node real(kind=pfdp), intent(in) :: coefs (:,:) interface public subroutine pf_propagate_solution_p(this, sol_t0, sol_tn, omega, level) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: sol_t0 class( pf_encap_t ), intent(inout) :: sol_tn class( pf_encap_t ), intent(inout) :: omega integer, intent(in) :: level interface public subroutine pf_destroy_magpicard_p(this, Lev) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: Lev Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_magpicard_t Magnus Picard sweeper type, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: dtsdc (:) integer, public :: magnus_order integer, public :: qtype real(kind=pfdp), public :: dt real(kind=pfdp), public :: commutator_coefs (9,3,4) complex(kind=pfdp), public, allocatable :: commutators (:,:,:) class( pf_encap_t ), public, allocatable :: omega (:) class( pf_encap_t ), public, allocatable :: time_ev_op (:) Type-Bound Procedures procedure, public :: sweep => magpicard_sweep procedure, public :: initialize => magpicard_initialize procedure, public :: evaluate => magpicard_evaluate procedure, public :: integrate => magpicard_integrate procedure, public :: residual => magpicard_residual procedure, public :: spreadq0 => magpicard_spreadq0 procedure, public :: evaluate_all => magpicard_evaluate_all procedure(pf_f_eval_p), public :: f_eval procedure(pf_compute_single_commutators_p), public :: compute_single_commutators procedure(pf_compute_omega_p), public :: compute_omega procedure(pf_propagate_solution_p), public :: propagate_solution procedure(pf_destroy_magpicard_p), public :: destroy procedure, public :: magpicard_destroy Subroutines public subroutine magpicard_sweep (this, pf, level_index, t0, dt, nsweeps, flags) this loop not OMP'd because the deferred procs are OMP'd Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags public subroutine magpicard_initialize (this, lev) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine magpicard_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Compute SDC integral\n  fintSDC = \\int_{t_n}&#94;{t_m} fSDC dt Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags public subroutine magpicard_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine magpicard_evaluate_all (this, lev, t, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine magpicard_residual (this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine magpicard_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine magpicard_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_magpicard_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine get_commutator_coefs (qtype, nnodes, dt, coefs) Arguments Type Intent Optional Attributes Name integer, intent(in) :: qtype integer, intent(in) :: nnodes real(kind=pfdp), intent(in) :: dt real(kind=pfdp), intent(inout) :: coefs (:,:,:)","tags":"","loc":"module/pf_mod_magnus_picard.html","title":"pf_mod_magnus_picard – LibPFASST"},{"text":"Module of routines to run  PFASST Uses pf_mod_pfasst pf_mod_interpolate pf_mod_restrict pf_mod_utils pf_mod_timer pf_mod_dtype pf_mod_hooks pf_mod_comm pf_mod_results module~~pf_mod_parallel~~UsesGraph module~pf_mod_parallel pf_mod_parallel module~pf_mod_interpolate pf_mod_interpolate module~pf_mod_parallel->module~pf_mod_interpolate module~pf_mod_utils pf_mod_utils module~pf_mod_parallel->module~pf_mod_utils module~pf_mod_restrict pf_mod_restrict module~pf_mod_parallel->module~pf_mod_restrict module~pf_mod_pfasst pf_mod_pfasst module~pf_mod_parallel->module~pf_mod_pfasst module~pf_mod_comm pf_mod_comm module~pf_mod_parallel->module~pf_mod_comm module~pf_mod_dtype pf_mod_dtype module~pf_mod_parallel->module~pf_mod_dtype module~pf_mod_hooks pf_mod_hooks module~pf_mod_parallel->module~pf_mod_hooks module~pf_mod_timer pf_mod_timer module~pf_mod_parallel->module~pf_mod_timer module~pf_mod_results pf_mod_results module~pf_mod_parallel->module~pf_mod_results module~pf_mod_interpolate->module~pf_mod_utils module~pf_mod_interpolate->module~pf_mod_restrict module~pf_mod_interpolate->module~pf_mod_dtype module~pf_mod_interpolate->module~pf_mod_hooks module~pf_mod_interpolate->module~pf_mod_timer module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_timer module~pf_mod_restrict->module~pf_mod_dtype module~pf_mod_restrict->module~pf_mod_hooks module~pf_mod_restrict->module~pf_mod_timer module~pf_mod_pfasst->module~pf_mod_utils module~pf_mod_pfasst->module~pf_mod_dtype module~pf_mod_pfasst->module~pf_mod_results module~pf_mod_comm_mpi pf_mod_comm_mpi module~pf_mod_pfasst->module~pf_mod_comm_mpi module~pf_mod_comm->module~pf_mod_pfasst iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_hooks->module~pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi module~pf_mod_results->module~pf_mod_utils module~pf_mod_results->module~pf_mod_dtype module~pf_mod_comm_mpi->module~pf_mod_dtype module~pf_mod_comm_mpi->module~pf_mod_mpi var panmodulepf_mod_parallelUsesGraph = svgPanZoom('#modulepf_mod_parallelUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_parallel~~UsedByGraph module~pf_mod_parallel pf_mod_parallel module~pfasst pfasst module~pfasst->module~pf_mod_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines pf_pfasst_run pf_predictor pf_check_residual pf_check_convergence_block pf_block_run pf_v_cycle Subroutines public subroutine pf_pfasst_run (pf, q0, dt, tend, nsteps, qend, flags) This is the main interface to pfasst.\n  It examines the parameters and decides which subroutine to call\n  to execute the code correctly\n  Set the number of time steps to do\n  The user can either pass in the number of time steps or\n  pass in the time step size and length of run\n  Allocate stuff for holding results Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf The complete PFASST structure class( pf_encap_t ), intent(inout) :: q0 The initial condition real(kind=pfdp), intent(in) :: dt The time step for each processor real(kind=pfdp), intent(in) :: tend The final time of run integer, intent(in), optional :: nsteps The number of time steps class( pf_encap_t ), intent(inout), optional :: qend The computed solution at tend integer, intent(in), optional :: flags (:) User defnined flags public subroutine pf_predictor (pf, t0, dt, flags) PFASST Predictor.\n  Subroutine  to initialize the solution on each processor\n  The goal is to have a solution at each level and each node set to a consistent value\n  When this is called, the value of q0 at the fine level on each processor has been set somehow (see q0_style below) Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf PFASST main data structure real(kind=pfdp), intent(in) :: t0 Initial time of this processor real(kind=pfdp), intent(in) :: dt time step integer, intent(in), optional :: flags (:) User defined flags public subroutine pf_check_residual (pf, residual_converged) Subroutine to test residuals to determine if the current processor has converged. Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf logical, intent(out) :: residual_converged Return true if residual is below tolerances public subroutine pf_check_convergence_block (pf, send_tag) Subroutine to check if the current processor has converged and\n to update the next processor on the status\n Note that if the previous processor hasn't converged yet\n (pstatus), the current processor can't be converged yet either\n Check to see if tolerances are met Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout) :: pf integer, intent(in) :: send_tag identifier for status send and receive public subroutine pf_block_run (pf, q0, dt, nsteps, qend, flags) PFASST controller for block mode\n  When starting a new block, broadcast new initial conditions to all procs\n  For initial block, this is done when initial conditions are set\n Reset some flags\n  Pack away your last solution\n  Everyone resets their q0\n  Just stick qend in q0\n  Update the step and t0 variables for new block\n Call the predictor to get an initial guess on all levels and all processors Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf class( pf_encap_t ), intent(in) :: q0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsteps class( pf_encap_t ), intent(inout), optional :: qend integer, intent(in), optional :: flags (:) public subroutine pf_v_cycle (pf, iteration, t0, dt, level_index_c, level_index_f, flags) Execute a V-cycle between levels nfine and ncoarse Read more… Arguments Type Intent Optional Attributes Name type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: iteration real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: level_index_c Coarsest level of V-cycle integer, intent(in) :: level_index_f Finest level of V-cycle integer, intent(in), optional :: flags","tags":"","loc":"module/pf_mod_parallel.html","title":"pf_mod_parallel – LibPFASST"},{"text":"Module of the  the derived sweeper class for doing MISDC sweeps for an equation of the form y' = f_1(y) + f_2(y) + f_3(y) The f_1 piece is treated explicitly and f_2 and f_3 implicitly\n  Afer this sweeper is initialized (usually in main), the locgical flags can be changed if desired Uses pf_mod_dtype pf_mod_utils module~~pf_mod_misdcq_oc~~UsesGraph module~pf_mod_misdcq_oc pf_mod_misdcQ_oc module~pf_mod_utils pf_mod_utils module~pf_mod_misdcq_oc->module~pf_mod_utils module~pf_mod_dtype pf_mod_dtype module~pf_mod_misdcq_oc->module~pf_mod_dtype module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_timer->module~pf_mod_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces pf_f_eval_p pf_f_comp_p Derived Types pf_misdcQ_oc_t Subroutines misdcQ_oc_sweep misdcQ_oc_initialize misdcQ_oc_destroy misdcQ_oc_integrate misdcQ_oc_evaluate misdcQ_oc_evaluate_all misdcQ_oc_residual misdcQ_oc_spreadq0 Interfaces interface public subroutine pf_f_eval_p(this, y, t, level_index, f, piece, flags, idx, step) This is the interface for the routine to compute the RHS function values\n  Evaluate f_piece(y), where piece is one or two\n  Evaluate f_piece(y), where piece is one or two Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(in) :: y Argument for evaluation real(kind=pfdp), intent(in) :: t Time at evaluation integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f RHS function value integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward integer, intent(in), optional :: idx index of quadrature node integer, intent(in), optional :: step time step for sequential version interface public subroutine pf_f_comp_p(this, y, t, dtq, rhs, level_index, f, piece, flags) Solve the equation y - dtq*f_n(y) =rhs where n is given by the argument piece Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_encap_t ), intent(inout) :: y Solution of implicit solve real(kind=pfdp), intent(in) :: t Time of solve real(kind=pfdp), intent(in) :: dtq dt*quadrature weight class( pf_encap_t ), intent(in) :: rhs RHS for solve integer, intent(in) :: level_index Level index class( pf_encap_t ), intent(inout) :: f f_n of solution y integer, intent(in) :: piece Which piece to evaluate integer, intent(in) :: flags forward or backward Derived Types type, public, abstract, extends( pf_sweeper_t ) :: pf_misdcQ_oc_t Multi-implicit SDC sweeper type for optimal control, extends abstract sweeper Components Type Visibility Attributes Name Initial integer, public :: npieces logical, public :: use_LUq real(kind=pfdp), public, allocatable :: QdiffE (:,:) real(kind=pfdp), public, allocatable :: QdiffI (:,:) real(kind=pfdp), public, allocatable :: QtilE (:,:) real(kind=pfdp), public, allocatable :: QtilI (:,:) real(kind=pfdp), public, allocatable :: dtsdc (:) class( pf_encap_t ), public, allocatable :: I3 (:) class( pf_encap_t ), public, allocatable :: rhs Type-Bound Procedures procedure(pf_f_eval_p), public :: f_eval procedure(pf_f_comp_p), public :: f_comp procedure, public :: sweep => misdcQ_oc_sweep procedure, public :: initialize => misdcQ_oc_initialize procedure, public :: integrate => misdcQ_oc_integrate procedure, public :: residual => misdcQ_oc_residual procedure, public :: spreadq0 => misdcQ_oc_spreadq0 procedure, public :: evaluate_all => misdcQ_oc_evaluate_all procedure, public :: evaluate => misdcQ_oc_evaluate procedure, public :: destroy => misdcQ_oc_destroy procedure, public :: misdcQ_oc_destroy Subroutines public subroutine misdcQ_oc_sweep (this, pf, level_index, t0, dt, nsweeps, flags) Assign level pointer Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this type( pf_pfasst_t ), intent(inout), target :: pf integer, intent(in) :: level_index real(kind=pfdp), intent(in) :: t0 real(kind=pfdp), intent(in) :: dt integer, intent(in) :: nsweeps integer, intent(in), optional :: flags public subroutine misdcQ_oc_initialize (this, lev) Array of substep sizes Read more… Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine misdcQ_oc_destroy (this, lev) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev public subroutine misdcQ_oc_integrate (this, lev, qSDC, fSDC, dt, fintSDC, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(in) :: lev class( pf_encap_t ), intent(in) :: qSDC (:) class( pf_encap_t ), intent(in) :: fSDC (:,:) real(kind=pfdp), intent(in) :: dt class( pf_encap_t ), intent(inout) :: fintSDC (:) integer, intent(in), optional :: flags public subroutine misdcQ_oc_evaluate (this, lev, t, m, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t integer, intent(in) :: m integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine misdcQ_oc_evaluate_all (this, lev, t, flags, step) Evaluate all function values Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t (:) integer, intent(in), optional :: flags integer, intent(in), optional :: step public subroutine misdcQ_oc_residual (this, lev, dt, flags) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: dt integer, intent(in), optional :: flags public subroutine misdcQ_oc_spreadq0 (this, lev, t0, flags, step) Arguments Type Intent Optional Attributes Name class( pf_misdcQ_oc_t ), intent(inout) :: this class( pf_level_t ), intent(inout) :: lev real(kind=pfdp), intent(in) :: t0 integer, intent(in), optional :: flags integer, intent(in), optional :: step","tags":"","loc":"module/pf_mod_misdcq_oc.html","title":"pf_mod_misdcQ_oc – LibPFASST"},{"text":"Module of communication wrappers Uses pf_mod_pfasst module~~pf_mod_comm~~UsesGraph module~pf_mod_comm pf_mod_comm module~pf_mod_pfasst pf_mod_pfasst module~pf_mod_comm->module~pf_mod_pfasst module~pf_mod_utils pf_mod_utils module~pf_mod_pfasst->module~pf_mod_utils module~pf_mod_comm_mpi pf_mod_comm_mpi module~pf_mod_pfasst->module~pf_mod_comm_mpi module~pf_mod_dtype pf_mod_dtype module~pf_mod_pfasst->module~pf_mod_dtype module~pf_mod_results pf_mod_results module~pf_mod_pfasst->module~pf_mod_results module~pf_mod_utils->module~pf_mod_dtype module~pf_mod_timer pf_mod_timer module~pf_mod_utils->module~pf_mod_timer module~pf_mod_comm_mpi->module~pf_mod_dtype module~pf_mod_mpi pf_mod_mpi module~pf_mod_comm_mpi->module~pf_mod_mpi iso_c_binding iso_c_binding module~pf_mod_dtype->iso_c_binding module~pf_mod_results->module~pf_mod_utils module~pf_mod_results->module~pf_mod_dtype module~pf_mod_timer->module~pf_mod_dtype module~pf_mod_timer->module~pf_mod_mpi var panmodulepf_mod_commUsesGraph = svgPanZoom('#modulepf_mod_commUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~pf_mod_comm~~UsedByGraph module~pf_mod_comm pf_mod_comm module~pf_mod_parallel_oc pf_mod_parallel_oc module~pf_mod_parallel_oc->module~pf_mod_comm module~pf_mod_parallel pf_mod_parallel module~pf_mod_parallel->module~pf_mod_comm module~pfasst pfasst module~pfasst->module~pf_mod_parallel Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines pf_post pf_send_status pf_recv_status pf_send pf_recv pf_broadcast save Subroutines public subroutine pf_post (pf, level, tag, direction) Subroutine to post a receive request for a new initial condition to be received after doing some work Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(in) :: pf class(pf_level_t), intent(inout) :: level integer, intent(in) :: tag integer, intent(in), optional :: direction public subroutine pf_send_status (pf, tag, direction) Subroutine to send this processor's convergence status to the next processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in), optional :: direction public subroutine pf_recv_status (pf, tag, direction) Subroutine to receive the convergence status from the previous processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf integer, intent(in) :: tag integer, intent(in), optional :: direction public subroutine pf_send (pf, level, tag, blocking, direction) Subroutine to send the solution to the next processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf class(pf_level_t), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(in), optional :: direction public subroutine pf_recv (pf, level, tag, blocking, direction) Subroutine to recieve the solution from the previous processor Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf type(pf_level_t), intent(inout) :: level integer, intent(in) :: tag logical, intent(in) :: blocking integer, intent(in), optional :: direction public subroutine pf_broadcast (pf, y, nvar, root) Subroutine to broadcast the initial condition to all processors Arguments Type Intent Optional Attributes Name type(pf_pfasst_t), intent(inout) :: pf real(kind=pfdp), intent(in) :: y (nvar) integer, intent(in) :: nvar integer, intent(in) :: root public subroutine save (lev, flags) Save current solution and function value so that future corrections can be computed Arguments Type Intent Optional Attributes Name class(pf_level_t), intent(inout) :: lev Level to save on integer, intent(in), optional :: flags which component to save (state/adjoint)","tags":"","loc":"module/pf_mod_comm.html","title":"pf_mod_comm – LibPFASST"}]}